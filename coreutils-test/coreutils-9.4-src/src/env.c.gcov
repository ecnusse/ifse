        -:    0:Source:src/env.c
        -:    0:Graph:env.gcno
        -:    0:Data:env.gcda
        -:    0:Runs:4
        -:    1:/* env - run a program in a modified environment
        -:    2:   Copyright (C) 1986-2023 Free Software Foundation, Inc.
        -:    3:
        -:    4:   This program is free software: you can redistribute it and/or modify
        -:    5:   it under the terms of the GNU General Public License as published by
        -:    6:   the Free Software Foundation, either version 3 of the License, or
        -:    7:   (at your option) any later version.
        -:    8:
        -:    9:   This program is distributed in the hope that it will be useful,
        -:   10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   12:   GNU General Public License for more details.
        -:   13:
        -:   14:   You should have received a copy of the GNU General Public License
        -:   15:   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
        -:   16:
        -:   17:/* Richard Mlynarik and David MacKenzie */
        -:   18:
        -:   19:#include <config.h>
        -:   20:#include <stdio.h>
        -:   21:#include <sys/types.h>
        -:   22:#include <getopt.h>
        -:   23:#include <c-ctype.h>
        -:   24:#include <signal.h>
        -:   25:
        -:   26:#include "system.h"
        -:   27:#include "operand2sig.h"
        -:   28:#include "quote.h"
        -:   29:#include "sig2str.h"
        -:   30:
        -:   31:/* The official name of this program (e.g., no 'g' prefix).  */
        -:   32:#define PROGRAM_NAME "env"
        -:   33:
        -:   34:#define AUTHORS \
        -:   35:  proper_name ("Richard Mlynarik"), \
        -:   36:  proper_name ("David MacKenzie"), \
        -:   37:  proper_name ("Assaf Gordon")
        -:   38:
        -:   39:/* Array of envvars to unset.  */
        -:   40:static char const **usvars;
        -:   41:static size_t usvars_alloc;
        -:   42:static idx_t usvars_used;
        -:   43:
        -:   44:/* Annotate the output with extra info to aid the user.  */
        -:   45:static bool dev_debug;
        -:   46:
        -:   47:/* Buffer and length of extracted envvars in -S strings.  */
        -:   48:static char *varname;
        -:   49:static idx_t vnlen;
        -:   50:
        -:   51:/* Possible actions on each signal.  */
        -:   52:enum SIGNAL_MODE {
        -:   53:  UNCHANGED = 0,
        -:   54:  DEFAULT,       /* Set to default handler (SIG_DFL).  */
        -:   55:  DEFAULT_NOERR, /* Ditto, but ignore sigaction(2) errors.  */
        -:   56:  IGNORE,        /* Set to ignore (SIG_IGN).  */
        -:   57:  IGNORE_NOERR   /* Ditto, but ignore sigaction(2) errors.  */
        -:   58:};
        -:   59:static enum SIGNAL_MODE *signals;
        -:   60:
        -:   61:/* Set of signals to block.  */
        -:   62:static sigset_t block_signals;
        -:   63:
        -:   64:/* Set of signals to unblock.  */
        -:   65:static sigset_t unblock_signals;
        -:   66:
        -:   67:/* Whether signal mask adjustment requested.  */
        -:   68:static bool sig_mask_changed;
        -:   69:
        -:   70:/* Whether to list non default handling.  */
        -:   71:static bool report_signal_handling;
        -:   72:
        -:   73:/* The isspace characters in the C locale.  */
        -:   74:#define C_ISSPACE_CHARS " \t\n\v\f\r"
        -:   75:
        -:   76:static char const shortopts[] = "+C:iS:u:v0" C_ISSPACE_CHARS;
        -:   77:
        -:   78:/* For long options that have no equivalent short option, use a
        -:   79:   non-character as a pseudo short option, starting with CHAR_MAX + 1.  */
        -:   80:enum
        -:   81:{
        -:   82:  DEFAULT_SIGNAL_OPTION = CHAR_MAX + 1,
        -:   83:  IGNORE_SIGNAL_OPTION,
        -:   84:  BLOCK_SIGNAL_OPTION,
        -:   85:  LIST_SIGNAL_HANDLING_OPTION,
        -:   86:};
        -:   87:
        -:   88:static struct option const longopts[] =
        -:   89:{
        -:   90:  {"ignore-environment", no_argument, nullptr, 'i'},
        -:   91:  {"null", no_argument, nullptr, '0'},
        -:   92:  {"unset", required_argument, nullptr, 'u'},
        -:   93:  {"chdir", required_argument, nullptr, 'C'},
        -:   94:  {"default-signal", optional_argument, nullptr, DEFAULT_SIGNAL_OPTION},
        -:   95:  {"ignore-signal",  optional_argument, nullptr, IGNORE_SIGNAL_OPTION},
        -:   96:  {"block-signal",   optional_argument, nullptr, BLOCK_SIGNAL_OPTION},
        -:   97:  {"list-signal-handling", no_argument, nullptr,  LIST_SIGNAL_HANDLING_OPTION},
        -:   98:  {"debug", no_argument, nullptr, 'v'},
        -:   99:  {"split-string", required_argument, nullptr, 'S'},
        -:  100:  {GETOPT_HELP_OPTION_DECL},
        -:  101:  {GETOPT_VERSION_OPTION_DECL},
        -:  102:  {nullptr, 0, nullptr, 0}
        -:  103:};
        -:  104:
        -:  105:void
function usage called 0 returned 0% blocks executed 0%
    #####:  106:usage (int status)
        -:  107:{
    #####:  108:  if (status != EXIT_SUCCESS)
branch  0 never executed
branch  1 never executed
    #####:  109:    emit_try_help ();
call    0 never executed
        -:  110:  else
        -:  111:    {
    #####:  112:      printf (_("\
call    0 never executed
        -:  113:Usage: %s [OPTION]... [-] [NAME=VALUE]... [COMMAND [ARG]...]\n"),
        -:  114:              program_name);
    #####:  115:      fputs (_("\
call    0 never executed
        -:  116:Set each NAME to VALUE in the environment and run COMMAND.\n\
        -:  117:"), stdout);
        -:  118:
    #####:  119:      emit_mandatory_arg_note ();
call    0 never executed
        -:  120:
    #####:  121:      fputs (_("\
call    0 never executed
        -:  122:  -i, --ignore-environment  start with an empty environment\n\
        -:  123:  -0, --null           end each output line with NUL, not newline\n\
        -:  124:  -u, --unset=NAME     remove variable from the environment\n\
        -:  125:"), stdout);
    #####:  126:      fputs (_("\
call    0 never executed
        -:  127:  -C, --chdir=DIR      change working directory to DIR\n\
        -:  128:"), stdout);
    #####:  129:      fputs (_("\
call    0 never executed
        -:  130:  -S, --split-string=S  process and split S into separate arguments;\n\
        -:  131:                        used to pass multiple arguments on shebang lines\n\
        -:  132:"), stdout);
    #####:  133:      fputs (_("\
call    0 never executed
        -:  134:      --block-signal[=SIG]    block delivery of SIG signal(s) to COMMAND\n\
        -:  135:"), stdout);
    #####:  136:      fputs (_("\
call    0 never executed
        -:  137:      --default-signal[=SIG]  reset handling of SIG signal(s) to the default\n\
        -:  138:"), stdout);
    #####:  139:      fputs (_("\
call    0 never executed
        -:  140:      --ignore-signal[=SIG]   set handling of SIG signal(s) to do nothing\n\
        -:  141:"), stdout);
    #####:  142:      fputs (_("\
call    0 never executed
        -:  143:      --list-signal-handling  list non default signal handling to stderr\n\
        -:  144:"), stdout);
    #####:  145:      fputs (_("\
call    0 never executed
        -:  146:  -v, --debug          print verbose information for each processing step\n\
        -:  147:"), stdout);
    #####:  148:      fputs (HELP_OPTION_DESCRIPTION, stdout);
call    0 never executed
    #####:  149:      fputs (VERSION_OPTION_DESCRIPTION, stdout);
call    0 never executed
    #####:  150:      fputs (_("\
call    0 never executed
        -:  151:\n\
        -:  152:A mere - implies -i.  If no COMMAND, print the resulting environment.\n\
        -:  153:"), stdout);
    #####:  154:      fputs (_("\
call    0 never executed
        -:  155:\n\
        -:  156:SIG may be a signal name like 'PIPE', or a signal number like '13'.\n\
        -:  157:Without SIG, all known signals are included.  Multiple signals can be\n\
        -:  158:comma-separated.  An empty SIG argument is a no-op.\n\
        -:  159:"), stdout);
    #####:  160:      emit_exec_status (PROGRAM_NAME);
call    0 never executed
    #####:  161:      emit_ancillary_info (PROGRAM_NAME);
call    0 never executed
        -:  162:    }
    #####:  163:  exit (status);
        -:  164:}
        -:  165:
        -:  166:static void
function append_unset_var called 0 returned 0% blocks executed 0%
    #####:  167:append_unset_var (char const *var)
        -:  168:{
    #####:  169:  if (usvars_used == usvars_alloc)
branch  0 never executed
branch  1 never executed
    #####:  170:    usvars = x2nrealloc (usvars, &usvars_alloc, sizeof *usvars);
call    0 never executed
    #####:  171:  usvars[usvars_used++] = var;
    #####:  172:}
        -:  173:
        -:  174:static void
function unset_envvars called 4 returned 100% blocks executed 23%
        4:  175:unset_envvars (void)
        -:  176:{
       4*:  177:  for (idx_t i = 0; i < usvars_used; ++i)
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
        -:  178:    {
    #####:  179:      devmsg ("unset:    %s\n", usvars[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  180:
    #####:  181:      if (unsetenv (usvars[i]))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  182:        error (EXIT_CANCELED, errno, _("cannot unset %s"),
call    0 never executed
call    1 never executed
        -:  183:               quote (usvars[i]));
        -:  184:    }
        4:  185:}
        -:  186:
        -:  187:/* Return a pointer to the end of a valid ${VARNAME} string, or nullptr.
        -:  188:   'str' should point to the '$' character.
        -:  189:   First letter in VARNAME must be alpha or underscore,
        -:  190:   rest of letters are alnum or underscore.
        -:  191:   Any other character is an error.  */
        -:  192:ATTRIBUTE_PURE
        -:  193:static char const *
function scan_varname called 0 returned 0% blocks executed 0%
    #####:  194:scan_varname (char const *str)
        -:  195:{
    #####:  196:  if (str[1] == '{' && (c_isalpha (str[2]) || str[2] == '_'))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:  197:    {
    #####:  198:      char const *end = str + 3;
    #####:  199:      while (c_isalnum (*end) || *end == '_')
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  200:        ++end;
    #####:  201:      if (*end == '}')
branch  0 never executed
branch  1 never executed
    #####:  202:        return end;
        -:  203:    }
        -:  204:
    #####:  205:  return nullptr;
        -:  206:}
        -:  207:
        -:  208:/* Return a pointer to a static buffer containing the VARNAME as
        -:  209:   extracted from a '${VARNAME}' string.
        -:  210:   The returned string will be NUL terminated.
        -:  211:   The returned pointer should not be freed.
        -:  212:   Return nullptr if not a valid ${VARNAME} syntax.  */
        -:  213:static char *
function extract_varname called 0 returned 0% blocks executed 0%
    #####:  214:extract_varname (char const *str)
        -:  215:{
        -:  216:  idx_t i;
        -:  217:  char const *p;
        -:  218:
    #####:  219:  p = scan_varname (str);
    #####:  220:  if (!p)
branch  0 never executed
branch  1 never executed
    #####:  221:    return nullptr;
        -:  222:
        -:  223:  /* -2 and +2 (below) account for the '${' prefix.  */
    #####:  224:  i = p - str - 2;
        -:  225:
    #####:  226:  if (i >= vnlen)
branch  0 never executed
branch  1 never executed
        -:  227:    {
    #####:  228:      vnlen = i + 1;
    #####:  229:      varname = xrealloc (varname, vnlen);
call    0 never executed
        -:  230:    }
        -:  231:
    #####:  232:  memcpy (varname, str + 2, i);
    #####:  233:  varname[i] = 0;
        -:  234:
    #####:  235:  return varname;
        -:  236:}
        -:  237:
        -:  238:/* Temporary buffer used by --split-string processing.  */
        -:  239:struct splitbuf
        -:  240:{
        -:  241:  /* Buffer address, arg count, and half the number of elements in the buffer.
        -:  242:     ARGC and ARGV are as in 'main', and ARGC + 1 <= HALF_ALLOC so
        -:  243:     that the upper half of ARGV can be used for string contents.
        -:  244:     This may waste up to half the space but keeps the code simple,
        -:  245:     which is better for this rarely-used but security-sensitive code.
        -:  246:
        -:  247:     ARGV[0] is not initialized; that is the caller's responsibility
        -:  248:     after finalization.
        -:  249:
        -:  250:     During assembly, ARGV[I] (where 0 < I < ARGC) contains the offset
        -:  251:     of the Ith string (relative to ARGV + HALF_ALLOC), so that
        -:  252:     reallocating ARGV does not change the validity of its contents.
        -:  253:     The integer offset is cast to char * during assembly, and is
        -:  254:     converted to a true char * pointer on finalization.
        -:  255:
        -:  256:     During assembly, ARGV[ARGC] contains the offset of the first
        -:  257:     unused string byte (relative to ARGV + HALF_ALLOC).  */
        -:  258:  char **argv;
        -:  259:  int argc;
        -:  260:  idx_t half_alloc;
        -:  261:
        -:  262:  /* The number of extra argv slots to keep room for.  */
        -:  263:  int extra_argc;
        -:  264:
        -:  265:  /* Whether processing should act as if the most recent character
        -:  266:     seen was a separator.  */
        -:  267:  bool sep;
        -:  268:};
        -:  269:
        -:  270:/* Expand SS so that it has at least one more argv slot and at least
        -:  271:   one more string byte.  */
        -:  272:static void
function splitbuf_grow called 0 returned 0% blocks executed 0%
    #####:  273:splitbuf_grow (struct splitbuf *ss)
        -:  274:{
    #####:  275:  idx_t old_half_alloc = ss->half_alloc;
    #####:  276:  idx_t string_bytes = (intptr_t) ss->argv[ss->argc];
    #####:  277:  ss->argv = xpalloc (ss->argv, &ss->half_alloc, 1,
call    0 never executed
        -:  278:                      MIN (INT_MAX, IDX_MAX), 2 * sizeof *ss->argv);
    #####:  279:  memmove (ss->argv + ss->half_alloc, ss->argv + old_half_alloc, string_bytes);
    #####:  280:}
        -:  281:
        -:  282:/* In SS, append C to the last string.  */
        -:  283:static void
function splitbuf_append_byte called 0 returned 0% blocks executed 0%
    #####:  284:splitbuf_append_byte (struct splitbuf *ss, char c)
        -:  285:{
    #####:  286:  idx_t string_bytes = (intptr_t) ss->argv[ss->argc];
    #####:  287:  if (ss->half_alloc * sizeof *ss->argv <= string_bytes)
branch  0 never executed
branch  1 never executed
    #####:  288:    splitbuf_grow (ss);
call    0 never executed
    #####:  289:  ((char *) (ss->argv + ss->half_alloc))[string_bytes] = c;
    #####:  290:  ss->argv[ss->argc] = (char *) (intptr_t) (string_bytes + 1);
    #####:  291:}
        -:  292:
        -:  293:/* If SS's most recent character was a separator, finish off its
        -:  294:   previous argument and start a new one.  */
        -:  295:static void
function check_start_new_arg called 0 returned 0% blocks executed 0%
    #####:  296:check_start_new_arg (struct splitbuf *ss)
        -:  297:{
    #####:  298:  if (ss->sep)
branch  0 never executed
branch  1 never executed
        -:  299:    {
    #####:  300:      splitbuf_append_byte (ss, '\0');
call    0 never executed
    #####:  301:      int argc = ss->argc;
    #####:  302:      if (ss->half_alloc <= argc + ss->extra_argc + 1)
branch  0 never executed
branch  1 never executed
    #####:  303:        splitbuf_grow (ss);
call    0 never executed
    #####:  304:      ss->argv[argc + 1] = ss->argv[argc];
    #####:  305:      ss->argc = argc + 1;
    #####:  306:      ss->sep = false;
        -:  307:    }
    #####:  308:}
        -:  309:
        -:  310:/* All additions to SS have been made.  Convert its offsets to pointers,
        -:  311:   and return the resulting argument vector.  */
        -:  312:static char **
function splitbuf_finishup called 0 returned 0% blocks executed 0%
    #####:  313:splitbuf_finishup (struct splitbuf *ss)
        -:  314:{
    #####:  315:  int argc = ss->argc;
    #####:  316:  char **argv = ss->argv;
    #####:  317:  char *stringbase = (char *) (ss->argv + ss->half_alloc);
    #####:  318:  for (int i = 1; i < argc; i++)
branch  0 never executed
branch  1 never executed
    #####:  319:    argv[i] = stringbase + (intptr_t) argv[i];
    #####:  320:  return argv;
        -:  321:}
        -:  322:
        -:  323:/* Return a newly-allocated argv-like array,
        -:  324:   by parsing and splitting the input 'str'.
        -:  325:
        -:  326:   'extra_argc' is the number of additional elements to allocate
        -:  327:   in the array (on top of the number of args required to split 'str').
        -:  328:
        -:  329:   Store into *argc the number of arguments found (plus 1 for
        -:  330:   the program name).
        -:  331:
        -:  332:   Example:
        -:  333:     int argc;
        -:  334:     char **argv = build_argv ("A=B uname -k', 3, &argc);
        -:  335:   Results in:
        -:  336:     argc = 4
        -:  337:     argv[0] = [not initialized]
        -:  338:     argv[1] = "A=B"
        -:  339:     argv[2] = "uname"
        -:  340:     argv[3] = "-k"
        -:  341:     argv[4,5,6,7] = [allocated due to extra_argc + 1, but not initialized]
        -:  342:
        -:  343:   To free allocated memory:
        -:  344:     free (argv);
        -:  345:   However, 'env' does not free since it's about to exec or exit anyway
        -:  346:   and the complexity of keeping track of the storage that may have been
        -:  347:   allocated via multiple calls to build_argv is not worth the hassle.  */
        -:  348:static char **
function build_argv called 0 returned 0% blocks executed 0%
    #####:  349:build_argv (char const *str, int extra_argc, int *argc)
        -:  350:{
    #####:  351:  bool dq = false, sq = false;
        -:  352:  struct splitbuf ss;
    #####:  353:  ss.argv = xnmalloc (extra_argc + 2, 2 * sizeof *ss.argv);
call    0 never executed
    #####:  354:  ss.argc = 1;
    #####:  355:  ss.half_alloc = extra_argc + 2;
    #####:  356:  ss.extra_argc = extra_argc;
    #####:  357:  ss.sep = true;
    #####:  358:  ss.argv[ss.argc] = 0;
        -:  359:
        -:  360:  /* In the following loop,
        -:  361:     'break' causes the character 'newc' to be added to *dest,
        -:  362:     'continue' skips the character.  */
    #####:  363:  while (*str)
branch  0 never executed
branch  1 never executed
        -:  364:    {
    #####:  365:      char newc = *str; /* Default: add the next character.  */
        -:  366:
    #####:  367:      switch (*str)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:  368:        {
    #####:  369:        case '\'':
    #####:  370:          if (dq)
branch  0 never executed
branch  1 never executed
    #####:  371:            break;
    #####:  372:          sq = !sq;
    #####:  373:          check_start_new_arg (&ss);
call    0 never executed
    #####:  374:          ++str;
    #####:  375:          continue;
        -:  376:
    #####:  377:        case '"':
    #####:  378:          if (sq)
branch  0 never executed
branch  1 never executed
    #####:  379:            break;
    #####:  380:          dq = !dq;
    #####:  381:          check_start_new_arg (&ss);
call    0 never executed
    #####:  382:          ++str;
    #####:  383:          continue;
        -:  384:
    #####:  385:        case ' ': case '\t': case '\n': case '\v': case '\f': case '\r':
        -:  386:          /* Start a new argument if outside quotes.  */
    #####:  387:          if (sq || dq)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  388:            break;
    #####:  389:          ss.sep = true;
    #####:  390:          str += strspn (str, C_ISSPACE_CHARS);
    #####:  391:          continue;
        -:  392:
    #####:  393:        case '#':
    #####:  394:          if (!ss.sep)
branch  0 never executed
branch  1 never executed
    #####:  395:            break;
    #####:  396:          goto eos; /* '#' as first char terminates the string.  */
        -:  397:
    #####:  398:        case '\\':
        -:  399:          /* Backslash inside single-quotes is not special, except \\
        -:  400:             and \'.  */
    #####:  401:          if (sq && str[1] != '\\' && str[1] != '\'')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  402:            break;
        -:  403:
        -:  404:          /* Skip the backslash and examine the next character.  */
    #####:  405:          newc = *++str;
    #####:  406:          switch (newc)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -:  407:            {
    #####:  408:            case '"': case '#': case '$': case '\'': case '\\':
        -:  409:              /* Pass escaped character as-is.  */
    #####:  410:              break;
        -:  411:
    #####:  412:            case '_':
    #####:  413:              if (!dq)
branch  0 never executed
branch  1 never executed
        -:  414:                {
    #####:  415:                  ++str;  /* '\_' outside double-quotes is arg separator.  */
    #####:  416:                  ss.sep = true;
    #####:  417:                  continue;
        -:  418:                }
    #####:  419:              newc = ' ';  /* '\_' inside double-quotes is space.  */
    #####:  420:              break;
        -:  421:
    #####:  422:            case 'c':
    #####:  423:              if (dq)
branch  0 never executed
branch  1 never executed
    #####:  424:                error (EXIT_CANCELED, 0,
call    0 never executed
        -:  425:                       _("'\\c' must not appear in double-quoted -S string"));
    #####:  426:              goto eos; /* '\c' terminates the string.  */
        -:  427:
    #####:  428:            case 'f': newc = '\f'; break;
    #####:  429:            case 'n': newc = '\n'; break;
    #####:  430:            case 'r': newc = '\r'; break;
    #####:  431:            case 't': newc = '\t'; break;
    #####:  432:            case 'v': newc = '\v'; break;
        -:  433:
    #####:  434:            case '\0':
    #####:  435:              error (EXIT_CANCELED, 0,
call    0 never executed
        -:  436:                     _("invalid backslash at end of string in -S"));
        -:  437:
    #####:  438:            default:
    #####:  439:              error (EXIT_CANCELED, 0,
call    0 never executed
        -:  440:                     _("invalid sequence '\\%c' in -S"), newc);
        -:  441:            }
    #####:  442:          break;
        -:  443:
    #####:  444:        case '$':
        -:  445:          /* ${VARNAME} are not expanded inside single-quotes.  */
    #####:  446:          if (sq)
branch  0 never executed
branch  1 never executed
    #####:  447:            break;
        -:  448:
        -:  449:          /* Store the ${VARNAME} value.  */
    #####:  450:          {
    #####:  451:            char *n = extract_varname (str);
call    0 never executed
    #####:  452:            if (!n)
branch  0 never executed
branch  1 never executed
    #####:  453:              error (EXIT_CANCELED, 0,
call    0 never executed
        -:  454:                     _("only ${VARNAME} expansion is supported, error at: %s"),
        -:  455:                     str);
        -:  456:
    #####:  457:            char *v = getenv (n);
call    0 never executed
    #####:  458:            if (v)
branch  0 never executed
branch  1 never executed
        -:  459:              {
    #####:  460:                check_start_new_arg (&ss);
call    0 never executed
    #####:  461:                devmsg ("expanding ${%s} into %s\n", n, quote (v));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  462:                for (; *v; v++)
branch  0 never executed
branch  1 never executed
    #####:  463:                  splitbuf_append_byte (&ss, *v);
call    0 never executed
        -:  464:              }
        -:  465:            else
    #####:  466:              devmsg ("replacing ${%s} with null string\n", n);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  467:
    #####:  468:            str = strchr (str, '}') + 1;
    #####:  469:            continue;
        -:  470:          }
        -:  471:        }
        -:  472:
    #####:  473:      check_start_new_arg (&ss);
call    0 never executed
    #####:  474:      splitbuf_append_byte (&ss, newc);
call    0 never executed
    #####:  475:      ++str;
        -:  476:    }
        -:  477:
    #####:  478:  if (dq || sq)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  479:    error (EXIT_CANCELED, 0, _("no terminating quote in -S string"));
call    0 never executed
        -:  480:
    #####:  481: eos:
    #####:  482:  splitbuf_append_byte (&ss, '\0');
call    0 never executed
    #####:  483:  *argc = ss.argc;
    #####:  484:  return splitbuf_finishup (&ss);
call    0 never executed
        -:  485:}
        -:  486:
        -:  487:/* Process an "-S" string and create the corresponding argv array.
        -:  488:   Update the given argc/argv parameters with the new argv.
        -:  489:
        -:  490:   Example: if executed as:
        -:  491:      $ env -S"-i -C/tmp A=B" foo bar
        -:  492:   The input argv is:
        -:  493:      argv[0] = "env"
        -:  494:      argv[1] = "-S-i -C/tmp A=B"
        -:  495:      argv[2] = "foo"
        -:  496:      argv[3] = "bar"
        -:  497:      argv[4] = nullptr
        -:  498:   This function will modify argv to be:
        -:  499:      argv[0] = "env"
        -:  500:      argv[1] = "-i"
        -:  501:      argv[2] = "-C/tmp"
        -:  502:      argv[3] = "A=B"
        -:  503:      argv[4] = "foo"
        -:  504:      argv[5] = "bar"
        -:  505:      argv[6] = nullptr
        -:  506:   argc will be updated from 4 to 6.
        -:  507:   optind will be reset to 0 to force getopt_long to rescan all arguments.  */
        -:  508:static void
function parse_split_string called 0 returned 0% blocks executed 0%
    #####:  509:parse_split_string (char const *str, int *orig_optind,
        -:  510:                    int *orig_argc, char ***orig_argv)
        -:  511:{
    #####:  512:  int extra_argc = *orig_argc - *orig_optind, newargc;
    #####:  513:  char **newargv = build_argv (str, extra_argc, &newargc);
call    0 never executed
        -:  514:
        -:  515:  /* Restore argv[0] - the 'env' executable name.  */
    #####:  516:  *newargv = (*orig_argv)[0];
        -:  517:
        -:  518:  /* Print parsed arguments.  */
    #####:  519:  if (dev_debug && 1 < newargc)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  520:    {
    #####:  521:      devmsg ("split -S:  %s\n", quote (str));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  522:      devmsg (" into:    %s\n", quote (newargv[1]));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  523:      for (int i = 2; i < newargc; i++)
branch  0 never executed
branch  1 never executed
    #####:  524:        devmsg ("     &    %s\n", quote (newargv[i]));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:  525:    }
        -:  526:
        -:  527:  /* Add remaining arguments and terminating null from the original
        -:  528:     command line.  */
    #####:  529:  memcpy (newargv + newargc, *orig_argv + *orig_optind,
    #####:  530:          (extra_argc + 1) * sizeof *newargv);
        -:  531:
        -:  532:  /* Set new values for original getopt variables.  */
    #####:  533:  *orig_argc = newargc + extra_argc;
    #####:  534:  *orig_argv = newargv;
    #####:  535:  *orig_optind = 0; /* Tell getopt to restart from first argument.  */
    #####:  536:}
        -:  537:
        -:  538:static void
function parse_signal_action_params called 0 returned 0% blocks executed 0%
    #####:  539:parse_signal_action_params (char const *optarg, bool set_default)
        -:  540:{
        -:  541:  char signame[SIG2STR_MAX];
        -:  542:  char *opt_sig;
        -:  543:  char *optarg_writable;
        -:  544:
    #####:  545:  if (! optarg)
branch  0 never executed
branch  1 never executed
        -:  546:    {
        -:  547:      /* Without an argument, reset all signals.
        -:  548:         Some signals cannot be set to ignore or default (e.g., SIGKILL,
        -:  549:         SIGSTOP on most OSes, and SIGCONT on AIX.) - so ignore errors.  */
    #####:  550:      for (int i = 1 ; i <= SIGNUM_BOUND; i++)
branch  0 never executed
branch  1 never executed
    #####:  551:        if (sig2str (i, signame) == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  552:          signals[i] = set_default ? DEFAULT_NOERR : IGNORE_NOERR;
branch  0 never executed
branch  1 never executed
    #####:  553:      return;
        -:  554:    }
        -:  555:
    #####:  556:  optarg_writable = xstrdup (optarg);
call    0 never executed
        -:  557:
    #####:  558:  opt_sig = strtok (optarg_writable, ",");
call    0 never executed
    #####:  559:  while (opt_sig)
branch  0 never executed
branch  1 never executed
        -:  560:    {
    #####:  561:      int signum = operand2sig (opt_sig, signame);
call    0 never executed
        -:  562:      /* operand2sig accepts signal 0 (EXIT) - but we reject it.  */
    #####:  563:      if (signum == 0)
branch  0 never executed
branch  1 never executed
    #####:  564:        error (0, 0, _("%s: invalid signal"), quote (opt_sig));
call    0 never executed
    #####:  565:      if (signum <= 0)
branch  0 never executed
branch  1 never executed
    #####:  566:        usage (exit_failure);
call    0 never executed
        -:  567:
    #####:  568:      signals[signum] = set_default ? DEFAULT : IGNORE;
branch  0 never executed
branch  1 never executed
        -:  569:
    #####:  570:      opt_sig = strtok (nullptr, ",");
call    0 never executed
        -:  571:    }
        -:  572:
    #####:  573:  free (optarg_writable);
        -:  574:}
        -:  575:
        -:  576:static void
function reset_signal_handlers called 3 returned 100% blocks executed 14%
        3:  577:reset_signal_handlers (void)
        -:  578:{
      195:  579:  for (int i = 1; i <= SIGNUM_BOUND; i++)
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
        -:  580:    {
        -:  581:      struct sigaction act;
        -:  582:
      192:  583:      if (signals[i] == UNCHANGED)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      192:  584:        continue;
        -:  585:
    #####:  586:      bool ignore_errors = (signals[i] == DEFAULT_NOERR
    #####:  587:                            || signals[i] == IGNORE_NOERR);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  588:
    #####:  589:      bool set_to_default = (signals[i] == DEFAULT
    #####:  590:                             || signals[i] == DEFAULT_NOERR);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  591:
    #####:  592:      int sig_err = sigaction (i, nullptr, &act);
call    0 never executed
        -:  593:
    #####:  594:      if (sig_err && !ignore_errors)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  595:        error (EXIT_CANCELED, errno,
call    0 never executed
        -:  596:               _("failed to get signal action for signal %d"), i);
        -:  597:
    #####:  598:      if (! sig_err)
branch  0 never executed
branch  1 never executed
        -:  599:        {
    #####:  600:          act.sa_handler = set_to_default ? SIG_DFL : SIG_IGN;
branch  0 never executed
branch  1 never executed
    #####:  601:          sig_err = sigaction (i, &act, nullptr);
call    0 never executed
    #####:  602:          if (sig_err && !ignore_errors)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  603:            error (EXIT_CANCELED, errno,
call    0 never executed
        -:  604:                   _("failed to set signal action for signal %d"), i);
        -:  605:        }
        -:  606:
    #####:  607:      if (dev_debug)
branch  0 never executed
branch  1 never executed
        -:  608:        {
        -:  609:          char signame[SIG2STR_MAX];
    #####:  610:          sig2str (i, signame);
call    0 never executed
    #####:  611:          devmsg ("Reset signal %s (%d) to %s%s\n",
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
        -:  612:                  signame, i,
        -:  613:                  set_to_default ? "DEFAULT" : "IGNORE",
        -:  614:                  sig_err ? " (failure ignored)" : "");
        -:  615:        }
        -:  616:    }
        3:  617:}
        -:  618:
        -:  619:
        -:  620:static void
function parse_block_signal_params called 0 returned 0% blocks executed 0%
    #####:  621:parse_block_signal_params (char const *optarg, bool block)
        -:  622:{
        -:  623:  char signame[SIG2STR_MAX];
        -:  624:  char *opt_sig;
        -:  625:  char *optarg_writable;
        -:  626:
    #####:  627:  if (! optarg)
branch  0 never executed
branch  1 never executed
        -:  628:    {
        -:  629:      /* Without an argument, reset all signals.  */
    #####:  630:      sigfillset (block ? &block_signals : &unblock_signals);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  631:      sigemptyset (block ? &unblock_signals : &block_signals);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  632:    }
    #####:  633:  else if (! sig_mask_changed)
branch  0 never executed
branch  1 never executed
        -:  634:    {
        -:  635:      /* Initialize the sets.  */
    #####:  636:      sigemptyset (&block_signals);
call    0 never executed
    #####:  637:      sigemptyset (&unblock_signals);
call    0 never executed
        -:  638:    }
        -:  639:
    #####:  640:  sig_mask_changed = true;
        -:  641:
    #####:  642:  if (! optarg)
branch  0 never executed
branch  1 never executed
    #####:  643:    return;
        -:  644:
    #####:  645:  optarg_writable = xstrdup (optarg);
call    0 never executed
        -:  646:
    #####:  647:  opt_sig = strtok (optarg_writable, ",");
call    0 never executed
    #####:  648:  while (opt_sig)
branch  0 never executed
branch  1 never executed
        -:  649:    {
    #####:  650:      int signum = operand2sig (opt_sig, signame);
call    0 never executed
        -:  651:      /* operand2sig accepts signal 0 (EXIT) - but we reject it.  */
    #####:  652:      if (signum == 0)
branch  0 never executed
branch  1 never executed
    #####:  653:        error (0, 0, _("%s: invalid signal"), quote (opt_sig));
call    0 never executed
    #####:  654:      if (signum <= 0)
branch  0 never executed
branch  1 never executed
    #####:  655:        usage (exit_failure);
call    0 never executed
        -:  656:
    #####:  657:      sigaddset (block ? &block_signals : &unblock_signals, signum);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  658:      sigdelset (block ? &unblock_signals : &block_signals, signum);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  659:
    #####:  660:      opt_sig = strtok (nullptr, ",");
call    0 never executed
        -:  661:    }
        -:  662:
    #####:  663:  free (optarg_writable);
        -:  664:}
        -:  665:
        -:  666:static void
function set_signal_proc_mask called 0 returned 0% blocks executed 0%
    #####:  667:set_signal_proc_mask (void)
        -:  668:{
        -:  669:  /* Get the existing signal mask */
        -:  670:  sigset_t set;
        -:  671:  char const *debug_act;
        -:  672:
    #####:  673:  sigemptyset (&set);
call    0 never executed
        -:  674:
    #####:  675:  if (sigprocmask (0, nullptr, &set))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  676:    error (EXIT_CANCELED, errno, _("failed to get signal process mask"));
call    0 never executed
        -:  677:
    #####:  678:  for (int i = 1; i <= SIGNUM_BOUND; i++)
branch  0 never executed
branch  1 never executed
        -:  679:    {
    #####:  680:      if (sigismember (&block_signals, i))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  681:        {
    #####:  682:          sigaddset (&set, i);
call    0 never executed
    #####:  683:          debug_act = "BLOCK";
        -:  684:        }
    #####:  685:      else if (sigismember (&unblock_signals, i))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  686:        {
    #####:  687:          sigdelset (&set, i);
call    0 never executed
    #####:  688:          debug_act = "UNBLOCK";
        -:  689:        }
        -:  690:      else
        -:  691:        {
    #####:  692:          debug_act = nullptr;
        -:  693:        }
        -:  694:
    #####:  695:      if (dev_debug && debug_act)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  696:        {
        -:  697:          char signame[SIG2STR_MAX];
    #####:  698:          sig2str (i, signame);
call    0 never executed
    #####:  699:          devmsg ("signal %s (%d) mask set to %s\n",
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  700:                  signame, i, debug_act);
        -:  701:        }
        -:  702:    }
        -:  703:
    #####:  704:  if (sigprocmask (SIG_SETMASK, &set, nullptr))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  705:    error (EXIT_CANCELED, errno, _("failed to set signal process mask"));
call    0 never executed
    #####:  706:}
        -:  707:
        -:  708:static void
function list_signal_handling called 0 returned 0% blocks executed 0%
    #####:  709:list_signal_handling (void)
        -:  710:{
        -:  711:  sigset_t set;
        -:  712:  char signame[SIG2STR_MAX];
        -:  713:
    #####:  714:  sigemptyset (&set);
call    0 never executed
    #####:  715:  if (sigprocmask (0, nullptr, &set))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  716:    error (EXIT_CANCELED, errno, _("failed to get signal process mask"));
call    0 never executed
        -:  717:
    #####:  718:  for (int i = 1; i <= SIGNUM_BOUND; i++)
branch  0 never executed
branch  1 never executed
        -:  719:    {
        -:  720:      struct sigaction act;
    #####:  721:      if (sigaction (i, nullptr, &act))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  722:        continue;
        -:  723:
    #####:  724:      char const *ignored = act.sa_handler == SIG_IGN ? "IGNORE" : "";
branch  0 never executed
branch  1 never executed
    #####:  725:      char const *blocked = sigismember (&set, i) ? "BLOCK" : "";
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  726:      char const *connect = *ignored && *blocked ? "," : "";
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  727:
    #####:  728:      if (! *ignored && ! *blocked)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  729:        continue;
        -:  730:
    #####:  731:      sig2str (i, signame);
call    0 never executed
    #####:  732:      fprintf (stderr, "%-10s (%2d): %s%s%s\n", signame, i,
call    0 never executed
        -:  733:               blocked, connect, ignored);
        -:  734:    }
    #####:  735:}
        -:  736:
        -:  737:static void
function initialize_signals called 4 returned 100% blocks executed 100%
        4:  738:initialize_signals (void)
        -:  739:{
        4:  740:  signals = xmalloc ((sizeof *signals) * (SIGNUM_BOUND + 1));
call    0 returned 100%
        -:  741:
      264:  742:  for (int i = 0 ; i <= SIGNUM_BOUND; i++)
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
      260:  743:    signals[i] = UNCHANGED;
        -:  744:
        4:  745:  return;
        -:  746:}
        -:  747:
        -:  748:int
function main called 4 returned 100% blocks executed 33%
        4:  749:main (int argc, char **argv)
        -:  750:{
        -:  751:  int optc;
        4:  752:  bool ignore_environment = false;
        4:  753:  bool opt_nul_terminate_output = false;
        4:  754:  char const *newdir = nullptr;
        -:  755:
        -:  756:  initialize_main (&argc, &argv);
        4:  757:  set_program_name (argv[0]);
call    0 returned 100%
        4:  758:  setlocale (LC_ALL, "");
call    0 returned 100%
        -:  759:  bindtextdomain (PACKAGE, LOCALEDIR);
        -:  760:  textdomain (PACKAGE);
        -:  761:
        4:  762:  initialize_exit_failure (EXIT_CANCELED);
call    0 returned 100%
        4:  763:  atexit (close_stdout);
call    0 returned 100%
        -:  764:
        4:  765:  initialize_signals ();
call    0 returned 100%
        -:  766:
        4:  767:  while ((optc = getopt_long (argc, argv, shortopts, longopts, nullptr)) != -1)
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  768:    {
    #####:  769:      switch (optc)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
        -:  770:        {
    #####:  771:        case 'i':
    #####:  772:          ignore_environment = true;
    #####:  773:          break;
    #####:  774:        case 'u':
    #####:  775:          append_unset_var (optarg);
call    0 never executed
    #####:  776:          break;
    #####:  777:        case 'v':
    #####:  778:          dev_debug = true;
    #####:  779:          break;
    #####:  780:        case '0':
    #####:  781:          opt_nul_terminate_output = true;
    #####:  782:          break;
    #####:  783:        case DEFAULT_SIGNAL_OPTION:
    #####:  784:          parse_signal_action_params (optarg, true);
call    0 never executed
    #####:  785:          parse_block_signal_params (optarg, false);
call    0 never executed
    #####:  786:          break;
    #####:  787:        case IGNORE_SIGNAL_OPTION:
    #####:  788:          parse_signal_action_params (optarg, false);
call    0 never executed
    #####:  789:          break;
    #####:  790:        case BLOCK_SIGNAL_OPTION:
    #####:  791:          parse_block_signal_params (optarg, true);
call    0 never executed
    #####:  792:          break;
    #####:  793:        case LIST_SIGNAL_HANDLING_OPTION:
    #####:  794:          report_signal_handling = true;
    #####:  795:          break;
    #####:  796:        case 'C':
    #####:  797:          newdir = optarg;
    #####:  798:          break;
    #####:  799:        case 'S':
    #####:  800:          parse_split_string (optarg, &optind, &argc, &argv);
call    0 never executed
    #####:  801:          break;
    #####:  802:        case ' ': case '\t': case '\n': case '\v': case '\f': case '\r':
        -:  803:          /* These are undocumented options.  Attempt to detect
        -:  804:             incorrect shebang usage with extraneous space, e.g.:
        -:  805:                #!/usr/bin/env -i command
        -:  806:             In which case argv[1] == "-i command".  */
        -:  807:          error (0, 0, _("invalid option -- '%c'"), optc);
        -:  808:          error (0, 0, _("use -[v]S to pass options in shebang lines"));
    #####:  809:          usage (EXIT_CANCELED);
call    0 never executed
        -:  810:
    #####:  811:        case_GETOPT_HELP_CHAR;
call    0 never executed
    #####:  812:        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  813:        default:
    #####:  814:          usage (EXIT_CANCELED);
call    0 never executed
        -:  815:        }
        -:  816:    }
        -:  817:
        4:  818:  if (optind < argc && STREQ (argv[optind], "-"))
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  819:    {
    #####:  820:      ignore_environment = true;
    #####:  821:      ++optind;
        -:  822:    }
        -:  823:
        4:  824:  if (ignore_environment)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  825:    {
    #####:  826:      devmsg ("cleaning environ\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  827:      static char *dummy_environ[] = { nullptr };
    #####:  828:      environ = dummy_environ;
        -:  829:    }
        -:  830:  else
        4:  831:    unset_envvars ();
call    0 returned 100%
        -:  832:
        -:  833:  char *eq;
        4:  834:  while (optind < argc && (eq = strchr (argv[optind], '=')))
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
        -:  835:    {
    #####:  836:      devmsg ("setenv:   %s\n", argv[optind]);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  837:
    #####:  838:      if (putenv (argv[optind]))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  839:        {
    #####:  840:          *eq = '\0';
    #####:  841:          error (EXIT_CANCELED, errno, _("cannot set %s"),
call    0 never executed
call    1 never executed
        -:  842:                 quote (argv[optind]));
        -:  843:        }
    #####:  844:      optind++;
        -:  845:    }
        -:  846:
        4:  847:  bool program_specified = optind < argc;
        -:  848:
       4*:  849:  if (opt_nul_terminate_output && program_specified)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        -:  850:    {
        -:  851:      error (0, 0, _("cannot specify --null (-0) with command"));
    #####:  852:      usage (EXIT_CANCELED);
call    0 never executed
        -:  853:    }
        -:  854:
       4*:  855:  if (newdir && ! program_specified)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        -:  856:    {
        -:  857:      error (0, 0, _("must specify command with --chdir (-C)"));
    #####:  858:      usage (EXIT_CANCELED);
call    0 never executed
        -:  859:    }
        -:  860:
        4:  861:  if (! program_specified)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        -:  862:    {
        -:  863:      /* Print the environment and exit.  */
        1:  864:      char *const *e = environ;
       52:  865:      while (*e)
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
      51*:  866:        printf ("%s%c", *e++, opt_nul_terminate_output ? '\0' : '\n');
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        1:  867:      return EXIT_SUCCESS;
        -:  868:    }
        -:  869:
        3:  870:  reset_signal_handlers ();
call    0 returned 100%
        3:  871:  if (sig_mask_changed)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  872:    set_signal_proc_mask ();
call    0 never executed
        -:  873:
        3:  874:  if (report_signal_handling)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  875:    list_signal_handling ();
call    0 never executed
        -:  876:
        3:  877:  if (newdir)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  878:    {
    #####:  879:      devmsg ("chdir:    %s\n", quoteaf (newdir));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:  880:
    #####:  881:      if (chdir (newdir) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  882:        error (EXIT_CANCELED, errno, _("cannot change directory to %s"),
call    0 never executed
call    1 never executed
        -:  883:               quoteaf (newdir));
        -:  884:    }
        -:  885:
        3:  886:  if (dev_debug)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  887:    {
    #####:  888:      devmsg ("executing: %s\n", argv[optind]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  889:      for (int i=optind; i<argc; ++i)
branch  0 never executed
branch  1 never executed
    #####:  890:        devmsg ("   arg[%d]= %s\n", i-optind, quote (argv[i]));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:  891:    }
        -:  892:
        3:  893:  execvp (argv[optind], &argv[optind]);
        -:  894:
       3*:  895:  int exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3:  896:  error (0, errno, "%s", quote (argv[optind]));
call    0 returned 100%
        -:  897:
        3:  898:  if (exit_status == EXIT_ENOENT && strpbrk (argv[optind], C_ISSPACE_CHARS))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  899:    error (0, 0, _("use -[v]S to pass options in shebang lines"));
        -:  900:
        3:  901:  main_exit (exit_status);
        -:  902:}
