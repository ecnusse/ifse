        -:    0:Source:src/dd.c
        -:    0:Graph:dd.gcno
        -:    0:Data:dd.gcda
        -:    0:Runs:5
        -:    1:/* dd -- convert a file while copying it.
        -:    2:   Copyright (C) 1985-2023 Free Software Foundation, Inc.
        -:    3:
        -:    4:   This program is free software: you can redistribute it and/or modify
        -:    5:   it under the terms of the GNU General Public License as published by
        -:    6:   the Free Software Foundation, either version 3 of the License, or
        -:    7:   (at your option) any later version.
        -:    8:
        -:    9:   This program is distributed in the hope that it will be useful,
        -:   10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   12:   GNU General Public License for more details.
        -:   13:
        -:   14:   You should have received a copy of the GNU General Public License
        -:   15:   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
        -:   16:
        -:   17:/* Written by Paul Rubin, David MacKenzie, and Stuart Kemp. */
        -:   18:
        -:   19:#include <config.h>
        -:   20:
        -:   21:#include <sys/types.h>
        -:   22:#include <signal.h>
        -:   23:#include <stdckdint.h>
        -:   24:
        -:   25:#include "system.h"
        -:   26:#include "alignalloc.h"
        -:   27:#include "close-stream.h"
        -:   28:#include "fd-reopen.h"
        -:   29:#include "gethrxtime.h"
        -:   30:#include "human.h"
        -:   31:#include "ioblksize.h"
        -:   32:#include "long-options.h"
        -:   33:#include "quote.h"
        -:   34:#include "verror.h"
        -:   35:#include "xstrtol.h"
        -:   36:#include "xtime.h"
        -:   37:
        -:   38:/* The official name of this program (e.g., no 'g' prefix).  */
        -:   39:#define PROGRAM_NAME "dd"
        -:   40:
        -:   41:#define AUTHORS \
        -:   42:  proper_name ("Paul Rubin"), \
        -:   43:  proper_name ("David MacKenzie"), \
        -:   44:  proper_name ("Stuart Kemp")
        -:   45:
        -:   46:/* Use SA_NOCLDSTOP as a proxy for whether the sigaction machinery is
        -:   47:   present.  */
        -:   48:#ifndef SA_NOCLDSTOP
        -:   49:# define SA_NOCLDSTOP 0
        -:   50:# define sigprocmask(How, Set, Oset) /* empty */
        -:   51:# define sigset_t int
        -:   52:# if ! HAVE_SIGINTERRUPT
        -:   53:#  define siginterrupt(sig, flag) /* empty */
        -:   54:# endif
        -:   55:#endif
        -:   56:
        -:   57:/* NonStop circa 2011 lacks SA_RESETHAND; see Bug#9076.  */
        -:   58:#ifndef SA_RESETHAND
        -:   59:# define SA_RESETHAND 0
        -:   60:#endif
        -:   61:
        -:   62:#ifndef SIGINFO
        -:   63:# define SIGINFO SIGUSR1
        -:   64:#endif
        -:   65:
        -:   66:/* This may belong in GNULIB's fcntl module instead.
        -:   67:   Define O_CIO to 0 if it is not supported by this OS. */
        -:   68:#ifndef O_CIO
        -:   69:# define O_CIO 0
        -:   70:#endif
        -:   71:
        -:   72:/* On AIX 5.1 and AIX 5.2, O_NOCACHE is defined via <fcntl.h>
        -:   73:   and would interfere with our use of that name, below.  */
        -:   74:#undef O_NOCACHE
        -:   75:
        -:   76:#if ! HAVE_FDATASYNC
        -:   77:# define fdatasync(fd) (errno = ENOSYS, -1)
        -:   78:#endif
        -:   79:
        -:   80:#define output_char(c)				\
        -:   81:  do						\
        -:   82:    {						\
        -:   83:      obuf[oc++] = (c);				\
        -:   84:      if (oc >= output_blocksize)		\
        -:   85:        write_output ();			\
        -:   86:    }						\
        -:   87:  while (0)
        -:   88:
        -:   89:/* Default input and output blocksize. */
        -:   90:#define DEFAULT_BLOCKSIZE 512
        -:   91:
        -:   92:/* Conversions bit masks. */
        -:   93:enum
        -:   94:  {
        -:   95:    C_ASCII = 01,
        -:   96:
        -:   97:    C_EBCDIC = 02,
        -:   98:    C_IBM = 04,
        -:   99:    C_BLOCK = 010,
        -:  100:    C_UNBLOCK = 020,
        -:  101:    C_LCASE = 040,
        -:  102:    C_UCASE = 0100,
        -:  103:    C_SWAB = 0200,
        -:  104:    C_NOERROR = 0400,
        -:  105:    C_NOTRUNC = 01000,
        -:  106:    C_SYNC = 02000,
        -:  107:
        -:  108:    /* Use separate input and output buffers, and combine partial
        -:  109:       input blocks. */
        -:  110:    C_TWOBUFS = 04000,
        -:  111:
        -:  112:    C_NOCREAT = 010000,
        -:  113:    C_EXCL = 020000,
        -:  114:    C_FDATASYNC = 040000,
        -:  115:    C_FSYNC = 0100000,
        -:  116:
        -:  117:    C_SPARSE = 0200000
        -:  118:  };
        -:  119:
        -:  120:/* Status levels.  */
        -:  121:enum
        -:  122:  {
        -:  123:    STATUS_NONE = 1,
        -:  124:    STATUS_NOXFER = 2,
        -:  125:    STATUS_DEFAULT = 3,
        -:  126:    STATUS_PROGRESS = 4
        -:  127:  };
        -:  128:
        -:  129:/* The name of the input file, or nullptr for the standard input. */
        -:  130:static char const *input_file = nullptr;
        -:  131:
        -:  132:/* The name of the output file, or nullptr for the standard output. */
        -:  133:static char const *output_file = nullptr;
        -:  134:
        -:  135:/* The page size on this host.  */
        -:  136:static idx_t page_size;
        -:  137:
        -:  138:/* The number of bytes in which atomic reads are done. */
        -:  139:static idx_t input_blocksize = 0;
        -:  140:
        -:  141:/* The number of bytes in which atomic writes are done. */
        -:  142:static idx_t output_blocksize = 0;
        -:  143:
        -:  144:/* Conversion buffer size, in bytes.  0 prevents conversions. */
        -:  145:static idx_t conversion_blocksize = 0;
        -:  146:
        -:  147:/* Skip this many records of 'input_blocksize' bytes before input. */
        -:  148:static intmax_t skip_records = 0;
        -:  149:
        -:  150:/* Skip this many bytes before input in addition of 'skip_records'
        -:  151:   records.  */
        -:  152:static idx_t skip_bytes = 0;
        -:  153:
        -:  154:/* Skip this many records of 'output_blocksize' bytes before output. */
        -:  155:static intmax_t seek_records = 0;
        -:  156:
        -:  157:/* Skip this many bytes in addition to 'seek_records' records before
        -:  158:   output.  */
        -:  159:static intmax_t seek_bytes = 0;
        -:  160:
        -:  161:/* Whether the final output was done with a seek (rather than a write).  */
        -:  162:static bool final_op_was_seek;
        -:  163:
        -:  164:/* Copy only this many records.  The default is effectively infinity.  */
        -:  165:static intmax_t max_records = INTMAX_MAX;
        -:  166:
        -:  167:/* Copy this many bytes in addition to 'max_records' records.  */
        -:  168:static idx_t max_bytes = 0;
        -:  169:
        -:  170:/* Bit vector of conversions to apply. */
        -:  171:static int conversions_mask = 0;
        -:  172:
        -:  173:/* Open flags for the input and output files.  */
        -:  174:static int input_flags = 0;
        -:  175:static int output_flags = 0;
        -:  176:
        -:  177:/* Status flags for what is printed to stderr.  */
        -:  178:static int status_level = STATUS_DEFAULT;
        -:  179:
        -:  180:/* If nonzero, filter characters through the translation table.  */
        -:  181:static bool translation_needed = false;
        -:  182:
        -:  183:/* Number of partial blocks written. */
        -:  184:static intmax_t w_partial = 0;
        -:  185:
        -:  186:/* Number of full blocks written. */
        -:  187:static intmax_t w_full = 0;
        -:  188:
        -:  189:/* Number of partial blocks read. */
        -:  190:static intmax_t r_partial = 0;
        -:  191:
        -:  192:/* Number of full blocks read. */
        -:  193:static intmax_t r_full = 0;
        -:  194:
        -:  195:/* Number of bytes written.  */
        -:  196:static intmax_t w_bytes = 0;
        -:  197:
        -:  198:/* Last-reported number of bytes written, or negative if never reported.  */
        -:  199:static intmax_t reported_w_bytes = -1;
        -:  200:
        -:  201:/* Time that dd started.  */
        -:  202:static xtime_t start_time;
        -:  203:
        -:  204:/* Next time to report periodic progress.  */
        -:  205:static xtime_t next_time;
        -:  206:
        -:  207:/* If positive, the number of bytes output in the current progress line.  */
        -:  208:static int progress_len;
        -:  209:
        -:  210:/* True if input is seekable.  */
        -:  211:static bool input_seekable;
        -:  212:
        -:  213:/* Error number corresponding to initial attempt to lseek input.
        -:  214:   If ESPIPE, do not issue any more diagnostics about it.  */
        -:  215:static int input_seek_errno;
        -:  216:
        -:  217:/* File offset of the input, in bytes, or -1 if it overflowed.  */
        -:  218:static off_t input_offset;
        -:  219:
        -:  220:/* True if a partial read should be diagnosed.  */
        -:  221:static bool warn_partial_read;
        -:  222:
        -:  223:/* Records truncated by conv=block. */
        -:  224:static intmax_t r_truncate = 0;
        -:  225:
        -:  226:/* Output representation of newline and space characters.
        -:  227:   They change if we're converting to EBCDIC.  */
        -:  228:static char newline_character = '\n';
        -:  229:static char space_character = ' ';
        -:  230:
        -:  231:/* I/O buffers.  */
        -:  232:static char *ibuf;
        -:  233:static char *obuf;
        -:  234:
        -:  235:/* Current index into 'obuf'. */
        -:  236:static idx_t oc = 0;
        -:  237:
        -:  238:/* Index into current line, for 'conv=block' and 'conv=unblock'.  */
        -:  239:static idx_t col = 0;
        -:  240:
        -:  241:/* The set of signals that are caught.  */
        -:  242:static sigset_t caught_signals;
        -:  243:
        -:  244:/* If nonzero, the value of the pending fatal signal.  */
        -:  245:static sig_atomic_t volatile interrupt_signal;
        -:  246:
        -:  247:/* A count of the number of pending info signals that have been received.  */
        -:  248:static sig_atomic_t volatile info_signal_count;
        -:  249:
        -:  250:/* Whether to discard cache for input or output.  */
        -:  251:static bool i_nocache, o_nocache;
        -:  252:
        -:  253:/* Whether to instruct the kernel to discard the complete file.  */
        -:  254:static bool i_nocache_eof, o_nocache_eof;
        -:  255:
        -:  256:/* Function used for read (to handle iflag=fullblock parameter).  */
        -:  257:static ssize_t (*iread_fnc) (int fd, char *buf, idx_t size);
        -:  258:
        -:  259:/* A longest symbol in the struct symbol_values tables below.  */
        -:  260:#define LONGEST_SYMBOL "count_bytes"
        -:  261:
        -:  262:/* A symbol and the corresponding integer value.  */
        -:  263:struct symbol_value
        -:  264:{
        -:  265:  char symbol[sizeof LONGEST_SYMBOL];
        -:  266:  int value;
        -:  267:};
        -:  268:
        -:  269:/* Conversion symbols, for conv="...".  */
        -:  270:static struct symbol_value const conversions[] =
        -:  271:{
        -:  272:  {"ascii", C_ASCII | C_UNBLOCK | C_TWOBUFS},	/* EBCDIC to ASCII. */
        -:  273:  {"ebcdic", C_EBCDIC | C_BLOCK | C_TWOBUFS},	/* ASCII to EBCDIC. */
        -:  274:  {"ibm", C_IBM | C_BLOCK | C_TWOBUFS},	/* Different ASCII to EBCDIC. */
        -:  275:  {"block", C_BLOCK | C_TWOBUFS},	/* Variable to fixed length records. */
        -:  276:  {"unblock", C_UNBLOCK | C_TWOBUFS},	/* Fixed to variable length records. */
        -:  277:  {"lcase", C_LCASE | C_TWOBUFS},	/* Translate upper to lower case. */
        -:  278:  {"ucase", C_UCASE | C_TWOBUFS},	/* Translate lower to upper case. */
        -:  279:  {"sparse", C_SPARSE},		/* Try to sparsely write output. */
        -:  280:  {"swab", C_SWAB | C_TWOBUFS},	/* Swap bytes of input. */
        -:  281:  {"noerror", C_NOERROR},	/* Ignore i/o errors. */
        -:  282:  {"nocreat", C_NOCREAT},	/* Do not create output file.  */
        -:  283:  {"excl", C_EXCL},		/* Fail if the output file already exists.  */
        -:  284:  {"notrunc", C_NOTRUNC},	/* Do not truncate output file. */
        -:  285:  {"sync", C_SYNC},		/* Pad input records to ibs with NULs. */
        -:  286:  {"fdatasync", C_FDATASYNC},	/* Synchronize output data before finishing.  */
        -:  287:  {"fsync", C_FSYNC},		/* Also synchronize output metadata.  */
        -:  288:  {"", 0}
        -:  289:};
        -:  290:
        -:  291:#define FFS_MASK(x) ((x) ^ ((x) & ((x) - 1)))
        -:  292:enum
        -:  293:  {
        -:  294:    /* Compute a value that's bitwise disjoint from the union
        -:  295:       of all O_ values.  */
        -:  296:    v = ~(0
        -:  297:          | O_APPEND
        -:  298:          | O_BINARY
        -:  299:          | O_CIO
        -:  300:          | O_DIRECT
        -:  301:          | O_DIRECTORY
        -:  302:          | O_DSYNC
        -:  303:          | O_NOATIME
        -:  304:          | O_NOCTTY
        -:  305:          | O_NOFOLLOW
        -:  306:          | O_NOLINKS
        -:  307:          | O_NONBLOCK
        -:  308:          | O_SYNC
        -:  309:          | O_TEXT
        -:  310:          ),
        -:  311:
        -:  312:    /* Use its lowest bits for private flags.  */
        -:  313:    O_FULLBLOCK = FFS_MASK (v),
        -:  314:    v2 = v ^ O_FULLBLOCK,
        -:  315:
        -:  316:    O_NOCACHE = FFS_MASK (v2),
        -:  317:    v3 = v2 ^ O_NOCACHE,
        -:  318:
        -:  319:    O_COUNT_BYTES = FFS_MASK (v3),
        -:  320:    v4 = v3 ^ O_COUNT_BYTES,
        -:  321:
        -:  322:    O_SKIP_BYTES = FFS_MASK (v4),
        -:  323:    v5 = v4 ^ O_SKIP_BYTES,
        -:  324:
        -:  325:    O_SEEK_BYTES = FFS_MASK (v5)
        -:  326:  };
        -:  327:
        -:  328:/* Ensure that we got something.  */
        -:  329:static_assert (O_FULLBLOCK != 0);
        -:  330:static_assert (O_NOCACHE != 0);
        -:  331:static_assert (O_COUNT_BYTES != 0);
        -:  332:static_assert (O_SKIP_BYTES != 0);
        -:  333:static_assert (O_SEEK_BYTES != 0);
        -:  334:
        -:  335:#define MULTIPLE_BITS_SET(i) (((i) & ((i) - 1)) != 0)
        -:  336:
        -:  337:/* Ensure that this is a single-bit value.  */
        -:  338:static_assert ( ! MULTIPLE_BITS_SET (O_FULLBLOCK));
        -:  339:static_assert ( ! MULTIPLE_BITS_SET (O_NOCACHE));
        -:  340:static_assert ( ! MULTIPLE_BITS_SET (O_COUNT_BYTES));
        -:  341:static_assert ( ! MULTIPLE_BITS_SET (O_SKIP_BYTES));
        -:  342:static_assert ( ! MULTIPLE_BITS_SET (O_SEEK_BYTES));
        -:  343:
        -:  344:/* Flags, for iflag="..." and oflag="...".  */
        -:  345:static struct symbol_value const flags[] =
        -:  346:{
        -:  347:  {"append",	  O_APPEND},
        -:  348:  {"binary",	  O_BINARY},
        -:  349:  {"cio",	  O_CIO},
        -:  350:  {"direct",	  O_DIRECT},
        -:  351:  {"directory",   O_DIRECTORY},
        -:  352:  {"dsync",	  O_DSYNC},
        -:  353:  {"noatime",	  O_NOATIME},
        -:  354:  {"nocache",	  O_NOCACHE},   /* Discard cache.  */
        -:  355:  {"noctty",	  O_NOCTTY},
        -:  356:  {"nofollow",	  HAVE_WORKING_O_NOFOLLOW ? O_NOFOLLOW : 0},
        -:  357:  {"nolinks",	  O_NOLINKS},
        -:  358:  {"nonblock",	  O_NONBLOCK},
        -:  359:  {"sync",	  O_SYNC},
        -:  360:  {"text",	  O_TEXT},
        -:  361:  {"fullblock",   O_FULLBLOCK}, /* Accumulate full blocks from input.  */
        -:  362:  {"count_bytes", O_COUNT_BYTES},
        -:  363:  {"skip_bytes",  O_SKIP_BYTES},
        -:  364:  {"seek_bytes",  O_SEEK_BYTES},
        -:  365:  {"",		0}
        -:  366:};
        -:  367:
        -:  368:/* Status, for status="...".  */
        -:  369:static struct symbol_value const statuses[] =
        -:  370:{
        -:  371:  {"none",	STATUS_NONE},
        -:  372:  {"noxfer",	STATUS_NOXFER},
        -:  373:  {"progress",	STATUS_PROGRESS},
        -:  374:  {"",		0}
        -:  375:};
        -:  376:
        -:  377:/* Translation table formed by applying successive transformations. */
        -:  378:static unsigned char trans_table[256];
        -:  379:
        -:  380:/* Standard translation tables, taken from POSIX 1003.1-2013.
        -:  381:   Beware of imitations; there are lots of ASCII<->EBCDIC tables
        -:  382:   floating around the net, perhaps valid for some applications but
        -:  383:   not correct here.  */
        -:  384:
        -:  385:static char const ascii_to_ebcdic[] =
        -:  386:{
        -:  387:  '\000', '\001', '\002', '\003', '\067', '\055', '\056', '\057',
        -:  388:  '\026', '\005', '\045', '\013', '\014', '\015', '\016', '\017',
        -:  389:  '\020', '\021', '\022', '\023', '\074', '\075', '\062', '\046',
        -:  390:  '\030', '\031', '\077', '\047', '\034', '\035', '\036', '\037',
        -:  391:  '\100', '\132', '\177', '\173', '\133', '\154', '\120', '\175',
        -:  392:  '\115', '\135', '\134', '\116', '\153', '\140', '\113', '\141',
        -:  393:  '\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367',
        -:  394:  '\370', '\371', '\172', '\136', '\114', '\176', '\156', '\157',
        -:  395:  '\174', '\301', '\302', '\303', '\304', '\305', '\306', '\307',
        -:  396:  '\310', '\311', '\321', '\322', '\323', '\324', '\325', '\326',
        -:  397:  '\327', '\330', '\331', '\342', '\343', '\344', '\345', '\346',
        -:  398:  '\347', '\350', '\351', '\255', '\340', '\275', '\232', '\155',
        -:  399:  '\171', '\201', '\202', '\203', '\204', '\205', '\206', '\207',
        -:  400:  '\210', '\211', '\221', '\222', '\223', '\224', '\225', '\226',
        -:  401:  '\227', '\230', '\231', '\242', '\243', '\244', '\245', '\246',
        -:  402:  '\247', '\250', '\251', '\300', '\117', '\320', '\137', '\007',
        -:  403:  '\040', '\041', '\042', '\043', '\044', '\025', '\006', '\027',
        -:  404:  '\050', '\051', '\052', '\053', '\054', '\011', '\012', '\033',
        -:  405:  '\060', '\061', '\032', '\063', '\064', '\065', '\066', '\010',
        -:  406:  '\070', '\071', '\072', '\073', '\004', '\024', '\076', '\341',
        -:  407:  '\101', '\102', '\103', '\104', '\105', '\106', '\107', '\110',
        -:  408:  '\111', '\121', '\122', '\123', '\124', '\125', '\126', '\127',
        -:  409:  '\130', '\131', '\142', '\143', '\144', '\145', '\146', '\147',
        -:  410:  '\150', '\151', '\160', '\161', '\162', '\163', '\164', '\165',
        -:  411:  '\166', '\167', '\170', '\200', '\212', '\213', '\214', '\215',
        -:  412:  '\216', '\217', '\220', '\152', '\233', '\234', '\235', '\236',
        -:  413:  '\237', '\240', '\252', '\253', '\254', '\112', '\256', '\257',
        -:  414:  '\260', '\261', '\262', '\263', '\264', '\265', '\266', '\267',
        -:  415:  '\270', '\271', '\272', '\273', '\274', '\241', '\276', '\277',
        -:  416:  '\312', '\313', '\314', '\315', '\316', '\317', '\332', '\333',
        -:  417:  '\334', '\335', '\336', '\337', '\352', '\353', '\354', '\355',
        -:  418:  '\356', '\357', '\372', '\373', '\374', '\375', '\376', '\377'
        -:  419:};
        -:  420:
        -:  421:static char const ascii_to_ibm[] =
        -:  422:{
        -:  423:  '\000', '\001', '\002', '\003', '\067', '\055', '\056', '\057',
        -:  424:  '\026', '\005', '\045', '\013', '\014', '\015', '\016', '\017',
        -:  425:  '\020', '\021', '\022', '\023', '\074', '\075', '\062', '\046',
        -:  426:  '\030', '\031', '\077', '\047', '\034', '\035', '\036', '\037',
        -:  427:  '\100', '\132', '\177', '\173', '\133', '\154', '\120', '\175',
        -:  428:  '\115', '\135', '\134', '\116', '\153', '\140', '\113', '\141',
        -:  429:  '\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367',
        -:  430:  '\370', '\371', '\172', '\136', '\114', '\176', '\156', '\157',
        -:  431:  '\174', '\301', '\302', '\303', '\304', '\305', '\306', '\307',
        -:  432:  '\310', '\311', '\321', '\322', '\323', '\324', '\325', '\326',
        -:  433:  '\327', '\330', '\331', '\342', '\343', '\344', '\345', '\346',
        -:  434:  '\347', '\350', '\351', '\255', '\340', '\275', '\137', '\155',
        -:  435:  '\171', '\201', '\202', '\203', '\204', '\205', '\206', '\207',
        -:  436:  '\210', '\211', '\221', '\222', '\223', '\224', '\225', '\226',
        -:  437:  '\227', '\230', '\231', '\242', '\243', '\244', '\245', '\246',
        -:  438:  '\247', '\250', '\251', '\300', '\117', '\320', '\241', '\007',
        -:  439:  '\040', '\041', '\042', '\043', '\044', '\025', '\006', '\027',
        -:  440:  '\050', '\051', '\052', '\053', '\054', '\011', '\012', '\033',
        -:  441:  '\060', '\061', '\032', '\063', '\064', '\065', '\066', '\010',
        -:  442:  '\070', '\071', '\072', '\073', '\004', '\024', '\076', '\341',
        -:  443:  '\101', '\102', '\103', '\104', '\105', '\106', '\107', '\110',
        -:  444:  '\111', '\121', '\122', '\123', '\124', '\125', '\126', '\127',
        -:  445:  '\130', '\131', '\142', '\143', '\144', '\145', '\146', '\147',
        -:  446:  '\150', '\151', '\160', '\161', '\162', '\163', '\164', '\165',
        -:  447:  '\166', '\167', '\170', '\200', '\212', '\213', '\214', '\215',
        -:  448:  '\216', '\217', '\220', '\232', '\233', '\234', '\235', '\236',
        -:  449:  '\237', '\240', '\252', '\253', '\254', '\255', '\256', '\257',
        -:  450:  '\260', '\261', '\262', '\263', '\264', '\265', '\266', '\267',
        -:  451:  '\270', '\271', '\272', '\273', '\274', '\275', '\276', '\277',
        -:  452:  '\312', '\313', '\314', '\315', '\316', '\317', '\332', '\333',
        -:  453:  '\334', '\335', '\336', '\337', '\352', '\353', '\354', '\355',
        -:  454:  '\356', '\357', '\372', '\373', '\374', '\375', '\376', '\377'
        -:  455:};
        -:  456:
        -:  457:static char const ebcdic_to_ascii[] =
        -:  458:{
        -:  459:  '\000', '\001', '\002', '\003', '\234', '\011', '\206', '\177',
        -:  460:  '\227', '\215', '\216', '\013', '\014', '\015', '\016', '\017',
        -:  461:  '\020', '\021', '\022', '\023', '\235', '\205', '\010', '\207',
        -:  462:  '\030', '\031', '\222', '\217', '\034', '\035', '\036', '\037',
        -:  463:  '\200', '\201', '\202', '\203', '\204', '\012', '\027', '\033',
        -:  464:  '\210', '\211', '\212', '\213', '\214', '\005', '\006', '\007',
        -:  465:  '\220', '\221', '\026', '\223', '\224', '\225', '\226', '\004',
        -:  466:  '\230', '\231', '\232', '\233', '\024', '\025', '\236', '\032',
        -:  467:  '\040', '\240', '\241', '\242', '\243', '\244', '\245', '\246',
        -:  468:  '\247', '\250', '\325', '\056', '\074', '\050', '\053', '\174',
        -:  469:  '\046', '\251', '\252', '\253', '\254', '\255', '\256', '\257',
        -:  470:  '\260', '\261', '\041', '\044', '\052', '\051', '\073', '\176',
        -:  471:  '\055', '\057', '\262', '\263', '\264', '\265', '\266', '\267',
        -:  472:  '\270', '\271', '\313', '\054', '\045', '\137', '\076', '\077',
        -:  473:  '\272', '\273', '\274', '\275', '\276', '\277', '\300', '\301',
        -:  474:  '\302', '\140', '\072', '\043', '\100', '\047', '\075', '\042',
        -:  475:  '\303', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
        -:  476:  '\150', '\151', '\304', '\305', '\306', '\307', '\310', '\311',
        -:  477:  '\312', '\152', '\153', '\154', '\155', '\156', '\157', '\160',
        -:  478:  '\161', '\162', '\136', '\314', '\315', '\316', '\317', '\320',
        -:  479:  '\321', '\345', '\163', '\164', '\165', '\166', '\167', '\170',
        -:  480:  '\171', '\172', '\322', '\323', '\324', '\133', '\326', '\327',
        -:  481:  '\330', '\331', '\332', '\333', '\334', '\335', '\336', '\337',
        -:  482:  '\340', '\341', '\342', '\343', '\344', '\135', '\346', '\347',
        -:  483:  '\173', '\101', '\102', '\103', '\104', '\105', '\106', '\107',
        -:  484:  '\110', '\111', '\350', '\351', '\352', '\353', '\354', '\355',
        -:  485:  '\175', '\112', '\113', '\114', '\115', '\116', '\117', '\120',
        -:  486:  '\121', '\122', '\356', '\357', '\360', '\361', '\362', '\363',
        -:  487:  '\134', '\237', '\123', '\124', '\125', '\126', '\127', '\130',
        -:  488:  '\131', '\132', '\364', '\365', '\366', '\367', '\370', '\371',
        -:  489:  '\060', '\061', '\062', '\063', '\064', '\065', '\066', '\067',
        -:  490:  '\070', '\071', '\372', '\373', '\374', '\375', '\376', '\377'
        -:  491:};
        -:  492:
        -:  493:/* True if we need to close the standard output *stream*.  */
        -:  494:static bool close_stdout_required = true;
        -:  495:
        -:  496:/* The only reason to close the standard output *stream* is if
        -:  497:   parse_long_options fails (as it does for --help or --version).
        -:  498:   In any other case, dd uses only the STDOUT_FILENO file descriptor,
        -:  499:   and the "cleanup" function calls "close (STDOUT_FILENO)".
        -:  500:   Closing the file descriptor and then letting the usual atexit-run
        -:  501:   close_stdout function call "fclose (stdout)" would result in a
        -:  502:   harmless failure of the close syscall (with errno EBADF).
        -:  503:   This function serves solely to avoid the unnecessary close_stdout
        -:  504:   call, once parse_long_options has succeeded.
        -:  505:   Meanwhile, we guarantee that the standard error stream is flushed,
        -:  506:   by inlining the last half of close_stdout as needed.  */
        -:  507:static void
function maybe_close_stdout called 5 returned 100% blocks executed 83%
        5:  508:maybe_close_stdout (void)
        -:  509:{
        5:  510:  if (close_stdout_required)
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
        1:  511:    close_stdout ();
call    0 returned 100%
        4:  512:  else if (close_stream (stderr) != 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  513:    _exit (EXIT_FAILURE);
call    0 never executed
        5:  514:}
        -:  515:
        -:  516:/* Like the 'error' function but handle any pending newline,
        -:  517:   and do not exit.  */
        -:  518:
        -:  519:ATTRIBUTE_FORMAT ((__printf__, 2, 3))
        -:  520:static void
function diagnose called 3 returned 100% blocks executed 60%
        3:  521:diagnose (int errnum, char const *fmt, ...)
        -:  522:{
        3:  523:  if (0 < progress_len)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  524:    {
    #####:  525:      fputc ('\n', stderr);
call    0 never executed
    #####:  526:      progress_len = 0;
        -:  527:    }
        -:  528:
        -:  529:  va_list ap;
        3:  530:  va_start (ap, fmt);
        3:  531:  verror (0, errnum, fmt, ap);
call    0 returned 100%
        3:  532:  va_end (ap);
        3:  533:}
        -:  534:
        -:  535:void
function usage called 4 returned 0% blocks executed 12%
        4:  536:usage (int status)
        -:  537:{
        4:  538:  if (status != EXIT_SUCCESS)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        4:  539:    emit_try_help ();
call    0 returned 100%
        -:  540:  else
        -:  541:    {
    #####:  542:      printf (_("\
call    0 never executed
        -:  543:Usage: %s [OPERAND]...\n\
        -:  544:  or:  %s OPTION\n\
        -:  545:"),
        -:  546:              program_name, program_name);
    #####:  547:      fputs (_("\
call    0 never executed
        -:  548:Copy a file, converting and formatting according to the operands.\n\
        -:  549:\n\
        -:  550:  bs=BYTES        read and write up to BYTES bytes at a time (default: 512);\n\
        -:  551:                  overrides ibs and obs\n\
        -:  552:  cbs=BYTES       convert BYTES bytes at a time\n\
        -:  553:  conv=CONVS      convert the file as per the comma separated symbol list\n\
        -:  554:  count=N         copy only N input blocks\n\
        -:  555:  ibs=BYTES       read up to BYTES bytes at a time (default: 512)\n\
        -:  556:"), stdout);
    #####:  557:      fputs (_("\
call    0 never executed
        -:  558:  if=FILE         read from FILE instead of stdin\n\
        -:  559:  iflag=FLAGS     read as per the comma separated symbol list\n\
        -:  560:  obs=BYTES       write BYTES bytes at a time (default: 512)\n\
        -:  561:  of=FILE         write to FILE instead of stdout\n\
        -:  562:  oflag=FLAGS     write as per the comma separated symbol list\n\
        -:  563:  seek=N          (or oseek=N) skip N obs-sized output blocks\n\
        -:  564:  skip=N          (or iseek=N) skip N ibs-sized input blocks\n\
        -:  565:  status=LEVEL    The LEVEL of information to print to stderr;\n\
        -:  566:                  'none' suppresses everything but error messages,\n\
        -:  567:                  'noxfer' suppresses the final transfer statistics,\n\
        -:  568:                  'progress' shows periodic transfer statistics\n\
        -:  569:"), stdout);
    #####:  570:      fputs (_("\
call    0 never executed
        -:  571:\n\
        -:  572:N and BYTES may be followed by the following multiplicative suffixes:\n\
        -:  573:c=1, w=2, b=512, kB=1000, K=1024, MB=1000*1000, M=1024*1024, xM=M,\n\
        -:  574:GB=1000*1000*1000, G=1024*1024*1024, and so on for T, P, E, Z, Y, R, Q.\n\
        -:  575:Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n\
        -:  576:If N ends in 'B', it counts bytes not blocks.\n\
        -:  577:\n\
        -:  578:Each CONV symbol may be:\n\
        -:  579:\n\
        -:  580:"), stdout);
    #####:  581:      fputs (_("\
call    0 never executed
        -:  582:  ascii     from EBCDIC to ASCII\n\
        -:  583:  ebcdic    from ASCII to EBCDIC\n\
        -:  584:  ibm       from ASCII to alternate EBCDIC\n\
        -:  585:  block     pad newline-terminated records with spaces to cbs-size\n\
        -:  586:  unblock   replace trailing spaces in cbs-size records with newline\n\
        -:  587:  lcase     change upper case to lower case\n\
        -:  588:  ucase     change lower case to upper case\n\
        -:  589:  sparse    try to seek rather than write all-NUL output blocks\n\
        -:  590:  swab      swap every pair of input bytes\n\
        -:  591:  sync      pad every input block with NULs to ibs-size; when used\n\
        -:  592:            with block or unblock, pad with spaces rather than NULs\n\
        -:  593:"), stdout);
    #####:  594:      fputs (_("\
call    0 never executed
        -:  595:  excl      fail if the output file already exists\n\
        -:  596:  nocreat   do not create the output file\n\
        -:  597:  notrunc   do not truncate the output file\n\
        -:  598:  noerror   continue after read errors\n\
        -:  599:  fdatasync  physically write output file data before finishing\n\
        -:  600:  fsync     likewise, but also write metadata\n\
        -:  601:"), stdout);
    #####:  602:      fputs (_("\
call    0 never executed
        -:  603:\n\
        -:  604:Each FLAG symbol may be:\n\
        -:  605:\n\
        -:  606:  append    append mode (makes sense only for output; conv=notrunc suggested)\n\
        -:  607:"), stdout);
        -:  608:      if (O_CIO)
        -:  609:        fputs (_("  cio       use concurrent I/O for data\n"), stdout);
        -:  610:      if (O_DIRECT)
    #####:  611:        fputs (_("  direct    use direct I/O for data\n"), stdout);
call    0 never executed
        -:  612:      if (O_DIRECTORY)
    #####:  613:        fputs (_("  directory  fail unless a directory\n"), stdout);
call    0 never executed
        -:  614:      if (O_DSYNC)
    #####:  615:        fputs (_("  dsync     use synchronized I/O for data\n"), stdout);
call    0 never executed
        -:  616:      if (O_SYNC)
    #####:  617:        fputs (_("  sync      likewise, but also for metadata\n"), stdout);
call    0 never executed
    #####:  618:      fputs (_("  fullblock  accumulate full blocks of input (iflag only)\n"),
call    0 never executed
        -:  619:             stdout);
        -:  620:      if (O_NONBLOCK)
    #####:  621:        fputs (_("  nonblock  use non-blocking I/O\n"), stdout);
call    0 never executed
        -:  622:      if (O_NOATIME)
    #####:  623:        fputs (_("  noatime   do not update access time\n"), stdout);
call    0 never executed
        -:  624:#if HAVE_POSIX_FADVISE
        -:  625:      if (O_NOCACHE)
    #####:  626:        fputs (_("  nocache   Request to drop cache.  See also oflag=sync\n"),
call    0 never executed
        -:  627:               stdout);
        -:  628:#endif
        -:  629:      if (O_NOCTTY)
    #####:  630:        fputs (_("  noctty    do not assign controlling terminal from file\n"),
call    0 never executed
        -:  631:               stdout);
        -:  632:      if (HAVE_WORKING_O_NOFOLLOW)
    #####:  633:        fputs (_("  nofollow  do not follow symlinks\n"), stdout);
call    0 never executed
        -:  634:      if (O_NOLINKS)
        -:  635:        fputs (_("  nolinks   fail if multiply-linked\n"), stdout);
        -:  636:      if (O_BINARY)
        -:  637:        fputs (_("  binary    use binary I/O for data\n"), stdout);
        -:  638:      if (O_TEXT)
        -:  639:        fputs (_("  text      use text I/O for data\n"), stdout);
        -:  640:
        -:  641:      {
    #####:  642:        printf (_("\
call    0 never executed
        -:  643:\n\
        -:  644:Sending a %s signal to a running 'dd' process makes it\n\
        -:  645:print I/O statistics to standard error and then resume copying.\n\
        -:  646:\n\
        -:  647:Options are:\n\
        -:  648:\n\
        -:  649:"), SIGINFO == SIGUSR1 ? "USR1" : "INFO");
        -:  650:      }
        -:  651:
    #####:  652:      fputs (HELP_OPTION_DESCRIPTION, stdout);
call    0 never executed
    #####:  653:      fputs (VERSION_OPTION_DESCRIPTION, stdout);
call    0 never executed
    #####:  654:      emit_ancillary_info (PROGRAM_NAME);
call    0 never executed
        -:  655:    }
        4:  656:  exit (status);
        -:  657:}
        -:  658:
        -:  659:/* Common options to use when displaying sizes and rates.  */
        -:  660:
        -:  661:enum { human_opts = (human_autoscale | human_round_to_nearest
        -:  662:                     | human_space_before_unit | human_SI | human_B) };
        -:  663:
        -:  664:/* Ensure input buffer IBUF is allocated.  */
        -:  665:
        -:  666:static void
function alloc_ibuf called 1 returned 100% blocks executed 40%
        1:  667:alloc_ibuf (void)
        -:  668:{
        1:  669:  if (ibuf)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  670:    return;
        -:  671:
        1:  672:  bool extra_byte_for_swab = !!(conversions_mask & C_SWAB);
        1:  673:  ibuf = alignalloc (page_size, input_blocksize + extra_byte_for_swab);
call    0 returned 100%
        1:  674:  if (!ibuf)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  675:    {
        -:  676:      char hbuf[LONGEST_HUMAN_READABLE + 1];
    #####:  677:      error (EXIT_FAILURE, 0,
call    0 never executed
call    1 never executed
        -:  678:             _("memory exhausted by input buffer of size %td bytes (%s)"),
        -:  679:             input_blocksize,
        -:  680:             human_readable (input_blocksize, hbuf,
        -:  681:                             human_opts | human_base_1024, 1, 1));
        -:  682:    }
        -:  683:}
        -:  684:
        -:  685:/* Ensure output buffer OBUF is allocated/initialized.  */
        -:  686:
        -:  687:static void
function alloc_obuf called 1 returned 100% blocks executed 38%
        1:  688:alloc_obuf (void)
        -:  689:{
        1:  690:  if (obuf)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  691:    return;
        -:  692:
        1:  693:  if (conversions_mask & C_TWOBUFS)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  694:    {
        1:  695:      obuf = alignalloc (page_size, output_blocksize);
call    0 returned 100%
        1:  696:      if (!obuf)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  697:        {
        -:  698:          char hbuf[LONGEST_HUMAN_READABLE + 1];
    #####:  699:          error (EXIT_FAILURE, 0,
call    0 never executed
call    1 never executed
        -:  700:                 _("memory exhausted by output buffer of size %td"
        -:  701:                   " bytes (%s)"),
        -:  702:                 output_blocksize,
        -:  703:                 human_readable (output_blocksize, hbuf,
        -:  704:                                 human_opts | human_base_1024, 1, 1));
        -:  705:        }
        -:  706:    }
        -:  707:  else
        -:  708:    {
    #####:  709:      alloc_ibuf ();
call    0 never executed
    #####:  710:      obuf = ibuf;
        -:  711:    }
        -:  712:}
        -:  713:
        -:  714:static void
function translate_charset called 0 returned 0% blocks executed 0%
    #####:  715:translate_charset (char const *new_trans)
        -:  716:{
    #####:  717:  for (int i = 0; i < 256; i++)
branch  0 never executed
branch  1 never executed
    #####:  718:    trans_table[i] = new_trans[trans_table[i]];
    #####:  719:  translation_needed = true;
    #####:  720:}
        -:  721:
        -:  722:/* Return true if I has more than one bit set.  I must be nonnegative.  */
        -:  723:
        -:  724:static inline bool
function multiple_bits_set called 6 returned 100% blocks executed 100%
        6:  725:multiple_bits_set (int i)
        -:  726:{
        6:  727:  return MULTIPLE_BITS_SET (i);
        -:  728:}
        -:  729:
        -:  730:static bool
function abbreviation_lacks_prefix called 1 returned 100% blocks executed 100%
        1:  731:abbreviation_lacks_prefix (char const *message)
        -:  732:{
        1:  733:  return message[strlen (message) - 2] == ' ';
        -:  734:}
        -:  735:
        -:  736:/* Print transfer statistics.  */
        -:  737:
        -:  738:static void
function print_xfer_stats called 1 returned 100% blocks executed 58%
        1:  739:print_xfer_stats (xtime_t progress_time)
        -:  740:{
       1*:  741:  xtime_t now = progress_time ? progress_time : gethrxtime ();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:  742:  static char const slash_s[] = "/s";
        -:  743:  char hbuf[3][LONGEST_HUMAN_READABLE + sizeof slash_s];
        -:  744:  double delta_s;
        -:  745:  char const *bytes_per_second;
        1:  746:  char const *si = human_readable (w_bytes, hbuf[0], human_opts, 1, 1);
call    0 returned 100%
        1:  747:  char const *iec = human_readable (w_bytes, hbuf[1],
call    0 returned 100%
        -:  748:                                    human_opts | human_base_1024, 1, 1);
        -:  749:
        -:  750:  /* Use integer arithmetic to compute the transfer rate,
        -:  751:     since that makes it easy to use SI abbreviations.  */
        1:  752:  char *bpsbuf = hbuf[2];
        1:  753:  int bpsbufsize = sizeof hbuf[2];
        1:  754:  if (start_time < now)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  755:    {
        1:  756:      double XTIME_PRECISIONe0 = XTIME_PRECISION;
        1:  757:      xtime_t delta_xtime = now - start_time;
        1:  758:      delta_s = delta_xtime / XTIME_PRECISIONe0;
        1:  759:      bytes_per_second = human_readable (w_bytes, bpsbuf, human_opts,
call    0 returned 100%
        -:  760:                                         XTIME_PRECISION, delta_xtime);
        1:  761:      strcat (bytes_per_second - bpsbuf + bpsbuf, slash_s);
        -:  762:    }
        -:  763:  else
        -:  764:    {
    #####:  765:      delta_s = 0;
    #####:  766:      snprintf (bpsbuf, bpsbufsize, "%s B/s", _("Infinity"));
    #####:  767:      bytes_per_second = bpsbuf;
        -:  768:    }
        -:  769:
        1:  770:  if (progress_time)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  771:    fputc ('\r', stderr);
call    0 never executed
        -:  772:
        -:  773:  /* Use full seconds when printing progress, since the progress
        -:  774:     report is output once per second and there is little point
        -:  775:     displaying any subsecond jitter.  Use default precision with %g
        -:  776:     otherwise, as this provides more-useful output then.  With long
        -:  777:     transfers %g can generate a number with an exponent; that is OK.  */
        -:  778:  char delta_s_buf[24];
       1*:  779:  snprintf (delta_s_buf, sizeof delta_s_buf,
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  780:            progress_time ? "%.0f s" : "%g s", delta_s);
        -:  781:
        1:  782:  int stats_len
        1:  783:    = (abbreviation_lacks_prefix (si)
call    0 returned 100%
       1*:  784:       ? fprintf (stderr,
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        1:  785:                  ngettext ("%"PRIdMAX" byte copied, %s, %s",
call    0 returned 100%
        -:  786:                            "%"PRIdMAX" bytes copied, %s, %s",
        -:  787:                            select_plural (w_bytes)),
        -:  788:                  w_bytes, delta_s_buf, bytes_per_second)
       1*:  789:       : abbreviation_lacks_prefix (iec)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
    #####:  790:       ? fprintf (stderr,
call    0 never executed
        -:  791:                  _("%"PRIdMAX" bytes (%s) copied, %s, %s"),
        -:  792:                  w_bytes, si, delta_s_buf, bytes_per_second)
    #####:  793:       : fprintf (stderr,
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  794:                  _("%"PRIdMAX" bytes (%s, %s) copied, %s, %s"),
        -:  795:                  w_bytes, si, iec, delta_s_buf, bytes_per_second));
        -:  796:
        1:  797:  if (progress_time)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  798:    {
        -:  799:      /* Erase any trailing junk on the output line by outputting
        -:  800:         spaces.  In theory this could glitch the display because the
        -:  801:         formatted translation of a line describing a larger file
        -:  802:         could consume fewer screen columns than the strlen difference
        -:  803:         from the previously formatted translation.  In practice this
        -:  804:         does not seem to be a problem.  */
    #####:  805:      if (0 <= stats_len && stats_len < progress_len)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  806:        fprintf (stderr, "%*s", progress_len - stats_len, "");
call    0 never executed
    #####:  807:      progress_len = stats_len;
        -:  808:    }
        -:  809:  else
        1:  810:    fputc ('\n', stderr);
call    0 returned 100%
        -:  811:
        1:  812:  reported_w_bytes = w_bytes;
        1:  813:}
        -:  814:
        -:  815:static void
function print_stats called 1 returned 100% blocks executed 44%
        1:  816:print_stats (void)
        -:  817:{
        1:  818:  if (status_level == STATUS_NONE)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  819:    return;
        -:  820:
        1:  821:  if (0 < progress_len)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  822:    {
    #####:  823:      fputc ('\n', stderr);
call    0 never executed
    #####:  824:      progress_len = 0;
        -:  825:    }
        -:  826:
        1:  827:  fprintf (stderr,
call    0 returned 100%
        -:  828:           _("%"PRIdMAX"+%"PRIdMAX" records in\n"
        -:  829:             "%"PRIdMAX"+%"PRIdMAX" records out\n"),
        -:  830:           r_full, r_partial, w_full, w_partial);
        -:  831:
        1:  832:  if (r_truncate != 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  833:    fprintf (stderr,
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  834:             ngettext ("%"PRIdMAX" truncated record\n",
call    0 never executed
        -:  835:                       "%"PRIdMAX" truncated records\n",
        -:  836:                       select_plural (r_truncate)),
        -:  837:             r_truncate);
        -:  838:
        1:  839:  if (status_level == STATUS_NOXFER)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  840:    return;
        -:  841:
        1:  842:  print_xfer_stats (0);
call    0 returned 100%
        -:  843:}
        -:  844:
        -:  845:/* An ordinary signal was received; arrange for the program to exit.  */
        -:  846:
        -:  847:static void
function interrupt_handler called 0 returned 0% blocks executed 0%
    #####:  848:interrupt_handler (int sig)
        -:  849:{
        -:  850:  if (! SA_RESETHAND)
        -:  851:    signal (sig, SIG_DFL);
    #####:  852:  interrupt_signal = sig;
    #####:  853:}
        -:  854:
        -:  855:/* An info signal was received; arrange for the program to print status.  */
        -:  856:
        -:  857:static void
function siginfo_handler called 0 returned 0% blocks executed 0%
    #####:  858:siginfo_handler (int sig)
        -:  859:{
        -:  860:  if (! SA_NOCLDSTOP)
        -:  861:    signal (sig, siginfo_handler);
    #####:  862:  info_signal_count++;
    #####:  863:}
        -:  864:
        -:  865:/* Install the signal handlers.  */
        -:  866:
        -:  867:static void
function install_signal_handlers called 5 returned 100% blocks executed 100%
        5:  868:install_signal_handlers (void)
        -:  869:{
        5:  870:  bool catch_siginfo = ! (SIGINFO == SIGUSR1 && getenv ("POSIXLY_CORRECT"));
call    0 returned 100%
        -:  871:
        -:  872:#if SA_NOCLDSTOP
        -:  873:
        -:  874:  struct sigaction act;
        5:  875:  sigemptyset (&caught_signals);
call    0 returned 100%
        5:  876:  if (catch_siginfo)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        5:  877:    sigaddset (&caught_signals, SIGINFO);
call    0 returned 100%
        5:  878:  sigaction (SIGINT, nullptr, &act);
call    0 returned 100%
        5:  879:  if (act.sa_handler != SIG_IGN)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        5:  880:    sigaddset (&caught_signals, SIGINT);
call    0 returned 100%
        5:  881:  act.sa_mask = caught_signals;
        -:  882:
        5:  883:  if (sigismember (&caught_signals, SIGINFO))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  884:    {
        5:  885:      act.sa_handler = siginfo_handler;
        -:  886:      /* Note we don't use SA_RESTART here and instead
        -:  887:         handle EINTR explicitly in iftruncate etc.
        -:  888:         to avoid blocking on uncommitted read/write calls.  */
        5:  889:      act.sa_flags = 0;
        5:  890:      sigaction (SIGINFO, &act, nullptr);
call    0 returned 100%
        -:  891:    }
        -:  892:
        5:  893:  if (sigismember (&caught_signals, SIGINT))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  894:    {
        5:  895:      act.sa_handler = interrupt_handler;
        5:  896:      act.sa_flags = SA_NODEFER | SA_RESETHAND;
        5:  897:      sigaction (SIGINT, &act, nullptr);
call    0 returned 100%
        -:  898:    }
        -:  899:
        -:  900:#else
        -:  901:
        -:  902:  if (catch_siginfo)
        -:  903:    {
        -:  904:      signal (SIGINFO, siginfo_handler);
        -:  905:      siginterrupt (SIGINFO, 1);
        -:  906:    }
        -:  907:  if (signal (SIGINT, SIG_IGN) != SIG_IGN)
        -:  908:    {
        -:  909:      signal (SIGINT, interrupt_handler);
        -:  910:      siginterrupt (SIGINT, 1);
        -:  911:    }
        -:  912:#endif
        5:  913:}
        -:  914:
        -:  915:/* Close FD.  Return 0 if successful, -1 (setting errno) otherwise.
        -:  916:   If close fails with errno == EINTR, POSIX says the file descriptor
        -:  917:   is in an unspecified state, so keep trying to close FD but do not
        -:  918:   consider EBADF to be an error.  Do not process signals.  This all
        -:  919:   differs somewhat from functions like ifdatasync and ifsync.  */
        -:  920:static int
function iclose called 2 returned 100% blocks executed 44%
        2:  921:iclose (int fd)
        -:  922:{
        2:  923:  if (close (fd) != 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  924:    do
    #####:  925:      if (errno != EINTR)
branch  0 never executed
branch  1 never executed
    #####:  926:        return -1;
    #####:  927:    while (close (fd) != 0 && errno != EBADF);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  928:
        2:  929:  return 0;
        -:  930:}
        -:  931:
        -:  932:static int synchronize_output (void);
        -:  933:
        -:  934:static void
function cleanup called 1 returned 100% blocks executed 42%
        1:  935:cleanup (void)
        -:  936:{
        1:  937:  if (!interrupt_signal)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  938:    {
        1:  939:      int sync_status = synchronize_output ();
call    0 returned 100%
        1:  940:      if (sync_status)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  941:        exit (sync_status);
call    0 never executed
        -:  942:    }
        -:  943:
        1:  944:  if (iclose (STDIN_FILENO) != 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  945:    error (EXIT_FAILURE, errno, _("closing input file %s"),
call    0 never executed
call    1 never executed
        -:  946:           quoteaf (input_file));
        -:  947:
        -:  948:  /* Don't remove this call to close, even though close_stdout
        -:  949:     closes standard output.  This close is necessary when cleanup
        -:  950:     is called as a consequence of signal handling.  */
        1:  951:  if (iclose (STDOUT_FILENO) != 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  952:    error (EXIT_FAILURE, errno,
call    0 never executed
call    1 never executed
        -:  953:           _("closing output file %s"), quoteaf (output_file));
        1:  954:}
        -:  955:
        -:  956:/* Process any pending signals.  If signals are caught, this function
        -:  957:   should be called periodically.  Ideally there should never be an
        -:  958:   unbounded amount of time when signals are not being processed.  */
        -:  959:
        -:  960:static void
function process_signals called 5 returned 100% blocks executed 29%
        5:  961:process_signals (void)
        -:  962:{
        5:  963:  while (interrupt_signal || info_signal_count)
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
        -:  964:    {
        -:  965:      int interrupt;
        -:  966:      int infos;
        -:  967:      sigset_t oldset;
        -:  968:
    #####:  969:      sigprocmask (SIG_BLOCK, &caught_signals, &oldset);
call    0 never executed
        -:  970:
        -:  971:      /* Reload interrupt_signal and info_signal_count, in case a new
        -:  972:         signal was handled before sigprocmask took effect.  */
    #####:  973:      interrupt = interrupt_signal;
    #####:  974:      infos = info_signal_count;
        -:  975:
    #####:  976:      if (infos)
branch  0 never executed
branch  1 never executed
    #####:  977:        info_signal_count = infos - 1;
        -:  978:
    #####:  979:      sigprocmask (SIG_SETMASK, &oldset, nullptr);
call    0 never executed
        -:  980:
    #####:  981:      if (interrupt)
branch  0 never executed
branch  1 never executed
    #####:  982:        cleanup ();
call    0 never executed
    #####:  983:      print_stats ();
call    0 never executed
    #####:  984:      if (interrupt)
branch  0 never executed
branch  1 never executed
    #####:  985:        raise (interrupt);
call    0 never executed
        -:  986:    }
        5:  987:}
        -:  988:
        -:  989:static void
function finish_up called 1 returned 100% blocks executed 100%
        1:  990:finish_up (void)
        -:  991:{
        -:  992:  /* Process signals first, so that cleanup is called at most once.  */
        1:  993:  process_signals ();
call    0 returned 100%
        1:  994:  cleanup ();
call    0 returned 100%
        1:  995:  print_stats ();
call    0 returned 100%
        1:  996:}
        -:  997:
        -:  998:static void
function quit called 0 returned 0% blocks executed 0%
    #####:  999:quit (int code)
        -: 1000:{
    #####: 1001:  finish_up ();
call    0 never executed
    #####: 1002:  exit (code);
        -: 1003:}
        -: 1004:
        -: 1005:/* Return LEN rounded down to a multiple of IO_BUFSIZE
        -: 1006:   (to minimize calls to the expensive posix_fadvise (,POSIX_FADV_DONTNEED),
        -: 1007:   while storing the remainder internally per FD.
        -: 1008:   Pass LEN == 0 to get the current remainder.  */
        -: 1009:
        -: 1010:static off_t
function cache_round called 0 returned 0% blocks executed 0%
    #####: 1011:cache_round (int fd, off_t len)
        -: 1012:{
        -: 1013:  static off_t i_pending, o_pending;
    #####: 1014:  off_t *pending = (fd == STDIN_FILENO ? &i_pending : &o_pending);
branch  0 never executed
branch  1 never executed
        -: 1015:
    #####: 1016:  if (len)
branch  0 never executed
branch  1 never executed
        -: 1017:    {
        -: 1018:      intmax_t c_pending;
    #####: 1019:      if (ckd_add (&c_pending, *pending, len))
branch  0 never executed
branch  1 never executed
    #####: 1020:        c_pending = INTMAX_MAX;
    #####: 1021:      *pending = c_pending % IO_BUFSIZE;
    #####: 1022:      if (c_pending > *pending)
branch  0 never executed
branch  1 never executed
    #####: 1023:        len = c_pending - *pending;
        -: 1024:      else
    #####: 1025:        len = 0;
        -: 1026:    }
        -: 1027:  else
    #####: 1028:    len = *pending;
        -: 1029:
    #####: 1030:  return len;
        -: 1031:}
        -: 1032:
        -: 1033:/* Discard the cache from the current offset of either
        -: 1034:   STDIN_FILENO or STDOUT_FILENO.
        -: 1035:   Return true on success.  */
        -: 1036:
        -: 1037:static bool
function invalidate_cache called 0 returned 0% blocks executed 0%
    #####: 1038:invalidate_cache (int fd, off_t len)
        -: 1039:{
    #####: 1040:  int adv_ret = -1;
        -: 1041:  off_t offset;
    #####: 1042:  bool nocache_eof = (fd == STDIN_FILENO ? i_nocache_eof : o_nocache_eof);
branch  0 never executed
branch  1 never executed
        -: 1043:
        -: 1044:  /* Minimize syscalls.  */
    #####: 1045:  off_t clen = cache_round (fd, len);
call    0 never executed
    #####: 1046:  if (len && !clen)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1047:    return true; /* Don't advise this time.  */
    #####: 1048:  else if (! len && ! clen && ! nocache_eof)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1049:    return true;
    #####: 1050:  off_t pending = len ? cache_round (fd, 0) : 0;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1051:
    #####: 1052:  if (fd == STDIN_FILENO)
branch  0 never executed
branch  1 never executed
        -: 1053:    {
    #####: 1054:      if (input_seekable)
branch  0 never executed
branch  1 never executed
    #####: 1055:        offset = input_offset;
        -: 1056:      else
        -: 1057:        {
    #####: 1058:          offset = -1;
    #####: 1059:          errno = ESPIPE;
        -: 1060:        }
        -: 1061:    }
        -: 1062:  else
        -: 1063:    {
        -: 1064:      static off_t output_offset = -2;
        -: 1065:
    #####: 1066:      if (output_offset != -1)
branch  0 never executed
branch  1 never executed
        -: 1067:        {
    #####: 1068:          if (output_offset < 0)
branch  0 never executed
branch  1 never executed
    #####: 1069:            output_offset = lseek (fd, 0, SEEK_CUR);
call    0 never executed
    #####: 1070:          else if (len)
branch  0 never executed
branch  1 never executed
    #####: 1071:            output_offset += clen + pending;
        -: 1072:        }
        -: 1073:
    #####: 1074:      offset = output_offset;
        -: 1075:    }
        -: 1076:
    #####: 1077:  if (0 <= offset)
branch  0 never executed
branch  1 never executed
        -: 1078:   {
    #####: 1079:     if (! len && clen && nocache_eof)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1080:       {
    #####: 1081:         pending = clen;
    #####: 1082:         clen = 0;
        -: 1083:       }
        -: 1084:
        -: 1085:     /* Note we're being careful here to only invalidate what
        -: 1086:        we've read, so as not to dump any read ahead cache.
        -: 1087:        Note also the kernel is conservative and only invalidates
        -: 1088:        full pages in the specified range.  */
        -: 1089:#if HAVE_POSIX_FADVISE
    #####: 1090:     offset = offset - clen - pending;
        -: 1091:     /* ensure full page specified when invalidating to eof.  */
    #####: 1092:     if (clen == 0)
branch  0 never executed
branch  1 never executed
    #####: 1093:       offset -= offset % page_size;
    #####: 1094:     adv_ret = posix_fadvise (fd, offset, clen, POSIX_FADV_DONTNEED);
call    0 never executed
        -: 1095:#else
        -: 1096:     errno = ENOTSUP;
        -: 1097:#endif
        -: 1098:   }
        -: 1099:
    #####: 1100:  return adv_ret != -1 ? true : false;
        -: 1101:}
        -: 1102:
        -: 1103:/* Read from FD into the buffer BUF of size SIZE, processing any
        -: 1104:   signals that arrive before bytes are read.  Return the number of
        -: 1105:   bytes read if successful, -1 (setting errno) on failure.  */
        -: 1106:
        -: 1107:static ssize_t
function iread called 2 returned 100% blocks executed 42%
        2: 1108:iread (int fd, char *buf, idx_t size)
        -: 1109:{
        -: 1110:  ssize_t nread;
        -: 1111:  static ssize_t prev_nread;
        -: 1112:
        -: 1113:  do
        -: 1114:    {
        2: 1115:      process_signals ();
call    0 returned 100%
        2: 1116:      nread = read (fd, buf, size);
call    0 returned 100%
        -: 1117:      /* Ignore final read error with iflag=direct as that
        -: 1118:         returns EINVAL due to the non aligned file offset.  */
       2*: 1119:      if (nread == -1 && errno == EINVAL
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####: 1120:          && 0 < prev_nread && prev_nread < size
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1121:          && (input_flags & O_DIRECT))
branch  0 never executed
branch  1 never executed
        -: 1122:        {
    #####: 1123:          errno = 0;
    #####: 1124:          nread = 0;
        -: 1125:        }
        -: 1126:    }
       2*: 1127:  while (nread < 0 && errno == EINTR);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        -: 1128:
        -: 1129:  /* Short read may be due to received signal.  */
        2: 1130:  if (0 < nread && nread < size)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1: 1131:    process_signals ();
call    0 returned 100%
        -: 1132:
        2: 1133:  if (0 < nread && warn_partial_read)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 1134:    {
    #####: 1135:      if (0 < prev_nread && prev_nread < size)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1136:        {
    #####: 1137:          idx_t prev = prev_nread;
    #####: 1138:          if (status_level != STATUS_NONE)
branch  0 never executed
branch  1 never executed
    #####: 1139:            diagnose (0, ngettext (("warning: partial read (%td byte); "
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1140:                                    "suggest iflag=fullblock"),
        -: 1141:                                   ("warning: partial read (%td bytes); "
        -: 1142:                                    "suggest iflag=fullblock"),
        -: 1143:                                   select_plural (prev)),
        -: 1144:                      prev);
    #####: 1145:          warn_partial_read = false;
        -: 1146:        }
        -: 1147:    }
        -: 1148:
        2: 1149:  prev_nread = nread;
        2: 1150:  return nread;
        -: 1151:}
        -: 1152:
        -: 1153:/* Wrapper around iread function to accumulate full blocks.  */
        -: 1154:static ssize_t
function iread_fullblock called 0 returned 0% blocks executed 0%
    #####: 1155:iread_fullblock (int fd, char *buf, idx_t size)
        -: 1156:{
    #####: 1157:  ssize_t nread = 0;
        -: 1158:
    #####: 1159:  while (0 < size)
branch  0 never executed
branch  1 never executed
        -: 1160:    {
    #####: 1161:      ssize_t ncurr = iread (fd, buf, size);
call    0 never executed
    #####: 1162:      if (ncurr < 0)
branch  0 never executed
branch  1 never executed
    #####: 1163:        return ncurr;
    #####: 1164:      if (ncurr == 0)
branch  0 never executed
branch  1 never executed
    #####: 1165:        break;
    #####: 1166:      nread += ncurr;
    #####: 1167:      buf   += ncurr;
    #####: 1168:      size  -= ncurr;
        -: 1169:    }
        -: 1170:
    #####: 1171:  return nread;
        -: 1172:}
        -: 1173:
        -: 1174:/* Write to FD the buffer BUF of size SIZE, processing any signals
        -: 1175:   that arrive.  Return the number of bytes written, setting errno if
        -: 1176:   this is less than SIZE.  Keep trying if there are partial
        -: 1177:   writes.  */
        -: 1178:
        -: 1179:static idx_t
function iwrite called 1 returned 100% blocks executed 41%
        1: 1180:iwrite (int fd, char const *buf, idx_t size)
        -: 1181:{
        1: 1182:  idx_t total_written = 0;
        -: 1183:
       1*: 1184:  if ((output_flags & O_DIRECT) && size < output_blocksize)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        -: 1185:    {
    #####: 1186:      int old_flags = fcntl (STDOUT_FILENO, F_GETFL);
call    0 never executed
    #####: 1187:      if (fcntl (STDOUT_FILENO, F_SETFL, old_flags & ~O_DIRECT) != 0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1188:          && status_level != STATUS_NONE)
branch  0 never executed
branch  1 never executed
    #####: 1189:        diagnose (errno, _("failed to turn off O_DIRECT: %s"),
call    0 never executed
call    1 never executed
        -: 1190:                  quotef (output_file));
        -: 1191:
        -: 1192:      /* Since we have just turned off O_DIRECT for the final write,
        -: 1193:         we try to preserve some of its semantics.  */
        -: 1194:
        -: 1195:      /* Call invalidate_cache to setup the appropriate offsets
        -: 1196:         for subsequent calls.  */
    #####: 1197:      o_nocache_eof = true;
    #####: 1198:      invalidate_cache (STDOUT_FILENO, 0);
call    0 never executed
        -: 1199:
        -: 1200:      /* Attempt to ensure that that final block is committed
        -: 1201:         to stable storage as quickly as possible.  */
    #####: 1202:      conversions_mask |= C_FSYNC;
        -: 1203:
        -: 1204:      /* After the subsequent fsync we'll call invalidate_cache
        -: 1205:         to attempt to clear all data from the page cache.  */
        -: 1206:    }
        -: 1207:
        2: 1208:  while (total_written < size)
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        -: 1209:    {
        1: 1210:      ssize_t nwritten = 0;
        1: 1211:      process_signals ();
call    0 returned 100%
        -: 1212:
        -: 1213:      /* Perform a seek for a NUL block if sparse output is enabled.  */
        1: 1214:      final_op_was_seek = false;
       1*: 1215:      if ((conversions_mask & C_SPARSE) && is_nul (buf, size))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        -: 1216:        {
    #####: 1217:          if (lseek (fd, size, SEEK_CUR) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1218:            {
    #####: 1219:              conversions_mask &= ~C_SPARSE;
        -: 1220:              /* Don't warn about the advisory sparse request.  */
        -: 1221:            }
        -: 1222:          else
        -: 1223:            {
    #####: 1224:              final_op_was_seek = true;
    #####: 1225:              nwritten = size;
        -: 1226:            }
        -: 1227:        }
        -: 1228:
        1: 1229:      if (!nwritten)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 1230:        nwritten = write (fd, buf + total_written, size - total_written);
call    0 returned 100%
        -: 1231:
        1: 1232:      if (nwritten < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1233:        {
    #####: 1234:          if (errno != EINTR)
branch  0 never executed
branch  1 never executed
    #####: 1235:            break;
        -: 1236:        }
        1: 1237:      else if (nwritten == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1238:        {
        -: 1239:          /* Some buggy drivers return 0 when one tries to write beyond
        -: 1240:             a device's end.  (Example: Linux kernel 1.2.13 on /dev/fd0.)
        -: 1241:             Set errno to ENOSPC so they get a sensible diagnostic.  */
    #####: 1242:          errno = ENOSPC;
    #####: 1243:          break;
        -: 1244:        }
        -: 1245:      else
        1: 1246:        total_written += nwritten;
        -: 1247:    }
        -: 1248:
       1*: 1249:  if (o_nocache && total_written)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####: 1250:    invalidate_cache (fd, total_written);
call    0 never executed
        -: 1251:
        1: 1252:  return total_written;
        -: 1253:}
        -: 1254:
        -: 1255:/* Write, then empty, the output buffer 'obuf'. */
        -: 1256:
        -: 1257:static void
function write_output called 0 returned 0% blocks executed 0%
    #####: 1258:write_output (void)
        -: 1259:{
    #####: 1260:  idx_t nwritten = iwrite (STDOUT_FILENO, obuf, output_blocksize);
call    0 never executed
    #####: 1261:  w_bytes += nwritten;
    #####: 1262:  if (nwritten != output_blocksize)
branch  0 never executed
branch  1 never executed
        -: 1263:    {
    #####: 1264:      diagnose (errno, _("writing to %s"), quoteaf (output_file));
call    0 never executed
call    1 never executed
    #####: 1265:      if (nwritten != 0)
branch  0 never executed
branch  1 never executed
    #####: 1266:        w_partial++;
    #####: 1267:      quit (EXIT_FAILURE);
call    0 never executed
        -: 1268:    }
        -: 1269:  else
    #####: 1270:    w_full++;
    #####: 1271:  oc = 0;
    #####: 1272:}
        -: 1273:
        -: 1274:/* Restart on EINTR from fdatasync.  */
        -: 1275:
        -: 1276:static int
function ifdatasync called 0 returned 0% blocks executed 0%
    #####: 1277:ifdatasync (int fd)
        -: 1278:{
        -: 1279:  int ret;
        -: 1280:
        -: 1281:  do
        -: 1282:    {
    #####: 1283:      process_signals ();
call    0 never executed
    #####: 1284:      ret = fdatasync (fd);
call    0 never executed
        -: 1285:    }
    #####: 1286:  while (ret < 0 && errno == EINTR);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1287:
    #####: 1288:  return ret;
        -: 1289:}
        -: 1290:
        -: 1291:/* Restart on EINTR from fd_reopen.  */
        -: 1292:
        -: 1293:static int
function ifd_reopen called 0 returned 0% blocks executed 0%
    #####: 1294:ifd_reopen (int desired_fd, char const *file, int flag, mode_t mode)
        -: 1295:{
        -: 1296:  int ret;
        -: 1297:
        -: 1298:  do
        -: 1299:    {
    #####: 1300:      process_signals ();
call    0 never executed
    #####: 1301:      ret = fd_reopen (desired_fd, file, flag, mode);
call    0 never executed
        -: 1302:    }
    #####: 1303:  while (ret < 0 && errno == EINTR);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1304:
    #####: 1305:  return ret;
        -: 1306:}
        -: 1307:
        -: 1308:/* Restart on EINTR from fstat.  */
        -: 1309:
        -: 1310:static int
function ifstat called 0 returned 0% blocks executed 0%
    #####: 1311:ifstat (int fd, struct stat *st)
        -: 1312:{
        -: 1313:  int ret;
        -: 1314:
        -: 1315:  do
        -: 1316:    {
    #####: 1317:      process_signals ();
call    0 never executed
    #####: 1318:      ret = fstat (fd, st);
call    0 never executed
        -: 1319:    }
    #####: 1320:  while (ret < 0 && errno == EINTR);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1321:
    #####: 1322:  return ret;
        -: 1323:}
        -: 1324:
        -: 1325:/* Restart on EINTR from fsync.  */
        -: 1326:
        -: 1327:static int
function ifsync called 0 returned 0% blocks executed 0%
    #####: 1328:ifsync (int fd)
        -: 1329:{
        -: 1330:  int ret;
        -: 1331:
        -: 1332:  do
        -: 1333:    {
    #####: 1334:      process_signals ();
call    0 never executed
    #####: 1335:      ret = fsync (fd);
call    0 never executed
        -: 1336:    }
    #####: 1337:  while (ret < 0 && errno == EINTR);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1338:
    #####: 1339:  return ret;
        -: 1340:}
        -: 1341:
        -: 1342:/* Restart on EINTR from ftruncate.  */
        -: 1343:
        -: 1344:static int
function iftruncate called 0 returned 0% blocks executed 0%
    #####: 1345:iftruncate (int fd, off_t length)
        -: 1346:{
        -: 1347:  int ret;
        -: 1348:
        -: 1349:  do
        -: 1350:    {
    #####: 1351:      process_signals ();
call    0 never executed
    #####: 1352:      ret = ftruncate (fd, length);
call    0 never executed
        -: 1353:    }
    #####: 1354:  while (ret < 0 && errno == EINTR);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1355:
    #####: 1356:  return ret;
        -: 1357:}
        -: 1358:
        -: 1359:/* Return true if STR is of the form "PATTERN" or "PATTERNDELIM...".  */
        -: 1360:
        -: 1361:ATTRIBUTE_PURE
        -: 1362:static bool
function operand_matches called 0 returned 0% blocks executed 0%
    #####: 1363:operand_matches (char const *str, char const *pattern, char delim)
        -: 1364:{
    #####: 1365:  while (*pattern)
branch  0 never executed
branch  1 never executed
    #####: 1366:    if (*str++ != *pattern++)
branch  0 never executed
branch  1 never executed
    #####: 1367:      return false;
    #####: 1368:  return !*str || *str == delim;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1369:}
        -: 1370:
        -: 1371:/* Interpret one "conv=..." or similar operand STR according to the
        -: 1372:   symbols in TABLE, returning the flags specified.  If the operand
        -: 1373:   cannot be parsed, use ERROR_MSGID to generate a diagnostic.  */
        -: 1374:
        -: 1375:static int
function parse_symbols called 0 returned 0% blocks executed 0%
    #####: 1376:parse_symbols (char const *str, struct symbol_value const *table,
        -: 1377:               bool exclusive, char const *error_msgid)
        -: 1378:{
    #####: 1379:  int value = 0;
        -: 1380:
        -: 1381:  while (true)
    #####: 1382:    {
    #####: 1383:      char const *strcomma = strchr (str, ',');
        -: 1384:      struct symbol_value const *entry;
        -: 1385:
    #####: 1386:      for (entry = table;
    #####: 1387:           ! (operand_matches (str, entry->symbol, ',') && entry->value);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1388:           entry++)
        -: 1389:        {
    #####: 1390:          if (! entry->symbol[0])
branch  0 never executed
branch  1 never executed
        -: 1391:            {
    #####: 1392:              idx_t slen = strcomma ? strcomma - str : strlen (str);
branch  0 never executed
branch  1 never executed
    #####: 1393:              diagnose (0, "%s: %s", _(error_msgid),
call    0 never executed
call    1 never executed
        -: 1394:                        quotearg_n_style_mem (0, locale_quoting_style,
        -: 1395:                                              str, slen));
    #####: 1396:              usage (EXIT_FAILURE);
call    0 never executed
        -: 1397:            }
        -: 1398:        }
        -: 1399:
    #####: 1400:      if (exclusive)
branch  0 never executed
branch  1 never executed
    #####: 1401:        value = entry->value;
        -: 1402:      else
    #####: 1403:        value |= entry->value;
    #####: 1404:      if (!strcomma)
branch  0 never executed
branch  1 never executed
    #####: 1405:        break;
    #####: 1406:      str = strcomma + 1;
        -: 1407:    }
        -: 1408:
    #####: 1409:  return value;
        -: 1410:}
        -: 1411:
        -: 1412:/* Return the value of STR, interpreted as a non-negative decimal integer,
        -: 1413:   optionally multiplied by various values.
        -: 1414:   Set *INVALID to an appropriate error value and return INTMAX_MAX if
        -: 1415:   it is an overflow, an indeterminate value if some other error occurred.  */
        -: 1416:
        -: 1417:static intmax_t
function parse_integer called 0 returned 0% blocks executed 0%
    #####: 1418:parse_integer (char const *str, strtol_error *invalid)
        -: 1419:{
        -: 1420:  /* Call xstrtoumax, not xstrtoimax, since we don't want to
        -: 1421:     allow strings like " -0".  Initialize N to an indeterminate value;
        -: 1422:     calling code should not rely on this function returning 0
        -: 1423:     when *INVALID represents a non-overflow error.  */
    #####: 1424:  int indeterminate = 0;
    #####: 1425:  uintmax_t n = indeterminate;
        -: 1426:  char *suffix;
        -: 1427:  static char const suffixes[] = "bcEGkKMPQRTwYZ0";
    #####: 1428:  strtol_error e = xstrtoumax (str, &suffix, 10, &n, suffixes);
call    0 never executed
        -: 1429:  intmax_t result;
        -: 1430:
    #####: 1431:  if ((e & ~LONGINT_OVERFLOW) == LONGINT_INVALID_SUFFIX_CHAR
branch  0 never executed
branch  1 never executed
    #####: 1432:      && *suffix == 'B' && str < suffix && suffix[-1] != 'B')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1433:    {
    #####: 1434:      suffix++;
    #####: 1435:      if (!*suffix)
branch  0 never executed
branch  1 never executed
    #####: 1436:        e &= ~LONGINT_INVALID_SUFFIX_CHAR;
        -: 1437:    }
        -: 1438:
    #####: 1439:  if ((e & ~LONGINT_OVERFLOW) == LONGINT_INVALID_SUFFIX_CHAR
branch  0 never executed
branch  1 never executed
    #####: 1440:      && *suffix == 'x')
branch  0 never executed
branch  1 never executed
    #####: 1441:    {
    #####: 1442:      strtol_error f = LONGINT_OK;
    #####: 1443:      intmax_t o = parse_integer (suffix + 1, &f);
call    0 never executed
    #####: 1444:      if ((f & ~LONGINT_OVERFLOW) != LONGINT_OK)
branch  0 never executed
branch  1 never executed
        -: 1445:        {
    #####: 1446:          e = f;
    #####: 1447:          result = indeterminate;
        -: 1448:        }
    #####: 1449:      else if (ckd_mul (&result, n, o)
branch  0 never executed
branch  1 never executed
    #####: 1450:               || (result != 0 && ((e | f) & LONGINT_OVERFLOW)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1451:        {
    #####: 1452:          e = LONGINT_OVERFLOW;
    #####: 1453:          result = INTMAX_MAX;
        -: 1454:        }
        -: 1455:      else
        -: 1456:        {
    #####: 1457:          if (result == 0 && STRPREFIX (str, "0x"))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1458:            diagnose (0, _("warning: %s is a zero multiplier; "
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1459:                           "use %s if that is intended"),
        -: 1460:                      quote_n (0, "0x"), quote_n (1, "00x"));
    #####: 1461:          e = LONGINT_OK;
        -: 1462:        }
        -: 1463:    }
    #####: 1464:  else if (n <= INTMAX_MAX)
branch  0 never executed
branch  1 never executed
    #####: 1465:    result = n;
        -: 1466:  else
        -: 1467:    {
    #####: 1468:      e = LONGINT_OVERFLOW;
    #####: 1469:      result = INTMAX_MAX;
        -: 1470:    }
        -: 1471:
    #####: 1472:  *invalid = e;
    #####: 1473:  return result;
        -: 1474:}
        -: 1475:
        -: 1476:/* OPERAND is of the form "X=...".  Return true if X is NAME.  */
        -: 1477:
        -: 1478:ATTRIBUTE_PURE
        -: 1479:static bool
function operand_is called 0 returned 0% blocks executed 0%
    #####: 1480:operand_is (char const *operand, char const *name)
        -: 1481:{
    #####: 1482:  return operand_matches (operand, name, '=');
        -: 1483:}
        -: 1484:
        -: 1485:static void
function scanargs called 4 returned 25% blocks executed 29%
        4: 1486:scanargs (int argc, char *const *argv)
        -: 1487:{
        4: 1488:  idx_t blocksize = 0;
        4: 1489:  intmax_t count = INTMAX_MAX;
        4: 1490:  intmax_t skip = 0;
        4: 1491:  intmax_t seek = 0;
        4: 1492:  bool count_B = false, skip_B = false, seek_B = false;
        -: 1493:
       4*: 1494:  for (int i = optind; i < argc; i++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -: 1495:    {
        3: 1496:      char const *name = argv[i];
        3: 1497:      char const *val = strchr (name, '=');
        -: 1498:
        3: 1499:      if (val == nullptr)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1500:        {
        3: 1501:          diagnose (0, _("unrecognized operand %s"), quoteaf (name));
call    0 returned 100%
call    1 returned 100%
        3: 1502:          usage (EXIT_FAILURE);
call    0 returned 0%
        -: 1503:        }
    #####: 1504:      val++;
        -: 1505:
    #####: 1506:      if (operand_is (name, "if"))
branch  0 never executed
branch  1 never executed
    #####: 1507:        input_file = val;
    #####: 1508:      else if (operand_is (name, "of"))
branch  0 never executed
branch  1 never executed
    #####: 1509:        output_file = val;
    #####: 1510:      else if (operand_is (name, "conv"))
branch  0 never executed
branch  1 never executed
    #####: 1511:        conversions_mask |= parse_symbols (val, conversions, false,
call    0 never executed
        -: 1512:                                           N_("invalid conversion"));
    #####: 1513:      else if (operand_is (name, "iflag"))
branch  0 never executed
branch  1 never executed
    #####: 1514:        input_flags |= parse_symbols (val, flags, false,
call    0 never executed
        -: 1515:                                      N_("invalid input flag"));
    #####: 1516:      else if (operand_is (name, "oflag"))
branch  0 never executed
branch  1 never executed
    #####: 1517:        output_flags |= parse_symbols (val, flags, false,
call    0 never executed
        -: 1518:                                       N_("invalid output flag"));
    #####: 1519:      else if (operand_is (name, "status"))
branch  0 never executed
branch  1 never executed
    #####: 1520:        status_level = parse_symbols (val, statuses, true,
call    0 never executed
        -: 1521:                                      N_("invalid status level"));
        -: 1522:      else
        -: 1523:        {
    #####: 1524:          strtol_error invalid = LONGINT_OK;
    #####: 1525:          intmax_t n = parse_integer (val, &invalid);
call    0 never executed
    #####: 1526:          bool has_B = !!strchr (val, 'B');
    #####: 1527:          intmax_t n_min = 0;
    #####: 1528:          intmax_t n_max = INTMAX_MAX;
    #####: 1529:          idx_t *converted_idx = nullptr;
        -: 1530:
        -: 1531:          /* Maximum blocksize.  Keep it smaller than IDX_MAX, so that
        -: 1532:             it fits into blocksize vars even if 1 is added for conv=swab.
        -: 1533:             Do not exceed SSIZE_MAX, for the benefit of system calls
        -: 1534:             like "read".  And do not exceed OFF_T_MAX, for the
        -: 1535:             benefit of the large-offset seek code.  */
    #####: 1536:          idx_t max_blocksize = MIN (IDX_MAX - 1, MIN (SSIZE_MAX, OFF_T_MAX));
        -: 1537:
    #####: 1538:          if (operand_is (name, "ibs"))
branch  0 never executed
branch  1 never executed
        -: 1539:            {
    #####: 1540:              n_min = 1;
    #####: 1541:              n_max = max_blocksize;
    #####: 1542:              converted_idx = &input_blocksize;
        -: 1543:            }
    #####: 1544:          else if (operand_is (name, "obs"))
branch  0 never executed
branch  1 never executed
        -: 1545:            {
    #####: 1546:              n_min = 1;
    #####: 1547:              n_max = max_blocksize;
    #####: 1548:              converted_idx = &output_blocksize;
        -: 1549:            }
    #####: 1550:          else if (operand_is (name, "bs"))
branch  0 never executed
branch  1 never executed
        -: 1551:            {
    #####: 1552:              n_min = 1;
    #####: 1553:              n_max = max_blocksize;
    #####: 1554:              converted_idx = &blocksize;
        -: 1555:            }
    #####: 1556:          else if (operand_is (name, "cbs"))
branch  0 never executed
branch  1 never executed
        -: 1557:            {
    #####: 1558:              n_min = 1;
    #####: 1559:              n_max = MIN (SIZE_MAX, IDX_MAX);
    #####: 1560:              converted_idx = &conversion_blocksize;
        -: 1561:            }
    #####: 1562:          else if (operand_is (name, "skip") || operand_is (name, "iseek"))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1563:            {
    #####: 1564:              skip = n;
    #####: 1565:              skip_B = has_B;
        -: 1566:            }
    #####: 1567:          else if (operand_is (name + (*name == 'o'), "seek"))
branch  0 never executed
branch  1 never executed
        -: 1568:            {
    #####: 1569:              seek = n;
    #####: 1570:              seek_B = has_B;
        -: 1571:            }
    #####: 1572:          else if (operand_is (name, "count"))
branch  0 never executed
branch  1 never executed
        -: 1573:            {
    #####: 1574:              count = n;
    #####: 1575:              count_B = has_B;
        -: 1576:            }
        -: 1577:          else
        -: 1578:            {
    #####: 1579:              diagnose (0, _("unrecognized operand %s"), quoteaf (name));
call    0 never executed
call    1 never executed
    #####: 1580:              usage (EXIT_FAILURE);
call    0 never executed
        -: 1581:            }
        -: 1582:
    #####: 1583:          if (n < n_min)
branch  0 never executed
branch  1 never executed
    #####: 1584:            invalid = LONGINT_INVALID;
    #####: 1585:          else if (n_max < n)
branch  0 never executed
branch  1 never executed
    #####: 1586:            invalid = LONGINT_OVERFLOW;
        -: 1587:
    #####: 1588:          if (invalid != LONGINT_OK)
branch  0 never executed
branch  1 never executed
    #####: 1589:            error (EXIT_FAILURE, invalid == LONGINT_OVERFLOW ? EOVERFLOW : 0,
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1590:                   "%s: %s", _("invalid number"), quoteaf (val));
    #####: 1591:          else if (converted_idx)
branch  0 never executed
branch  1 never executed
    #####: 1592:            *converted_idx = n;
        -: 1593:        }
        -: 1594:    }
        -: 1595:
        1: 1596:  if (blocksize)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1597:    input_blocksize = output_blocksize = blocksize;
        -: 1598:  else
        -: 1599:    {
        -: 1600:      /* POSIX says dd aggregates partial reads into
        -: 1601:         output_blocksize if bs= is not specified.  */
        1: 1602:      conversions_mask |= C_TWOBUFS;
        -: 1603:    }
        -: 1604:
        1: 1605:  if (input_blocksize == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 1606:    input_blocksize = DEFAULT_BLOCKSIZE;
        1: 1607:  if (output_blocksize == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 1608:    output_blocksize = DEFAULT_BLOCKSIZE;
        1: 1609:  if (conversion_blocksize == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 1610:    conversions_mask &= ~(C_BLOCK | C_UNBLOCK);
        -: 1611:
        1: 1612:  if (input_flags & (O_DSYNC | O_SYNC))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1613:    input_flags |= O_RSYNC;
        -: 1614:
        1: 1615:  if (output_flags & O_FULLBLOCK)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1616:    {
    #####: 1617:      diagnose (0, "%s: %s", _("invalid output flag"), quote ("fullblock"));
call    0 never executed
call    1 never executed
    #####: 1618:      usage (EXIT_FAILURE);
call    0 never executed
        -: 1619:    }
        -: 1620:
        1: 1621:  if (skip_B)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1622:    input_flags |= O_SKIP_BYTES;
       1*: 1623:  if (input_flags & O_SKIP_BYTES && skip != 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        -: 1624:    {
    #####: 1625:      skip_records = skip / input_blocksize;
    #####: 1626:      skip_bytes = skip % input_blocksize;
        -: 1627:    }
        1: 1628:  else if (skip != 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1629:    skip_records = skip;
        -: 1630:
        1: 1631:  if (count_B)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1632:    input_flags |= O_COUNT_BYTES;
       1*: 1633:  if (input_flags & O_COUNT_BYTES && count != INTMAX_MAX)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        -: 1634:    {
    #####: 1635:      max_records = count / input_blocksize;
    #####: 1636:      max_bytes = count % input_blocksize;
        -: 1637:    }
        1: 1638:  else if (count != INTMAX_MAX)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1639:    max_records = count;
        -: 1640:
        1: 1641:  if (seek_B)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1642:    output_flags |= O_SEEK_BYTES;
       1*: 1643:  if (output_flags & O_SEEK_BYTES && seek != 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        -: 1644:    {
    #####: 1645:      seek_records = seek / output_blocksize;
    #####: 1646:      seek_bytes = seek % output_blocksize;
        -: 1647:    }
        1: 1648:  else if (seek != 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1649:    seek_records = seek;
        -: 1650:
        -: 1651:  /* Warn about partial reads if bs=SIZE is given and iflag=fullblock
        -: 1652:     is not, and if counting or skipping bytes or using direct I/O.
        -: 1653:     This helps to avoid confusion with miscounts, and to avoid issues
        -: 1654:     with direct I/O on GNU/Linux.  */
        1: 1655:  warn_partial_read =
    #####: 1656:    (! (conversions_mask & C_TWOBUFS) && ! (input_flags & O_FULLBLOCK)
branch  0 never executed
branch  1 never executed
       1*: 1657:     && (skip_records
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####: 1658:         || (0 < max_records && max_records < INTMAX_MAX)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1659:         || (input_flags | output_flags) & O_DIRECT));
branch  0 never executed
branch  1 never executed
        -: 1660:
        2: 1661:  iread_fnc = ((input_flags & O_FULLBLOCK)
        -: 1662:               ? iread_fullblock
       1*: 1663:               : iread);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        1: 1664:  input_flags &= ~O_FULLBLOCK;
        -: 1665:
        1: 1666:  if (multiple_bits_set (conversions_mask & (C_ASCII | C_EBCDIC | C_IBM)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1667:    error (EXIT_FAILURE, 0, _("cannot combine any two of {ascii,ebcdic,ibm}"));
call    0 never executed
        1: 1668:  if (multiple_bits_set (conversions_mask & (C_BLOCK | C_UNBLOCK)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1669:    error (EXIT_FAILURE, 0, _("cannot combine block and unblock"));
call    0 never executed
        1: 1670:  if (multiple_bits_set (conversions_mask & (C_LCASE | C_UCASE)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1671:    error (EXIT_FAILURE, 0, _("cannot combine lcase and ucase"));
call    0 never executed
        1: 1672:  if (multiple_bits_set (conversions_mask & (C_EXCL | C_NOCREAT)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1673:    error (EXIT_FAILURE, 0, _("cannot combine excl and nocreat"));
call    0 never executed
        1: 1674:  if (multiple_bits_set (input_flags & (O_DIRECT | O_NOCACHE))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        1: 1675:      || multiple_bits_set (output_flags & (O_DIRECT | O_NOCACHE)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1676:    error (EXIT_FAILURE, 0, _("cannot combine direct and nocache"));
call    0 never executed
        -: 1677:
        1: 1678:  if (input_flags & O_NOCACHE)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1679:    {
    #####: 1680:      i_nocache = true;
    #####: 1681:      i_nocache_eof = (max_records == 0 && max_bytes == 0);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1682:      input_flags &= ~O_NOCACHE;
        -: 1683:    }
        1: 1684:  if (output_flags & O_NOCACHE)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1685:    {
    #####: 1686:      o_nocache = true;
    #####: 1687:      o_nocache_eof = (max_records == 0 && max_bytes == 0);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1688:      output_flags &= ~O_NOCACHE;
        -: 1689:    }
        1: 1690:}
        -: 1691:
        -: 1692:/* Fix up translation table. */
        -: 1693:
        -: 1694:static void
function apply_translations called 1 returned 100% blocks executed 32%
        1: 1695:apply_translations (void)
        -: 1696:{
        -: 1697:  int i;
        -: 1698:
        1: 1699:  if (conversions_mask & C_ASCII)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1700:    translate_charset (ebcdic_to_ascii);
call    0 never executed
        -: 1701:
        1: 1702:  if (conversions_mask & C_UCASE)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1703:    {
    #####: 1704:      for (i = 0; i < 256; i++)
branch  0 never executed
branch  1 never executed
    #####: 1705:        trans_table[i] = toupper (trans_table[i]);
    #####: 1706:      translation_needed = true;
        -: 1707:    }
        1: 1708:  else if (conversions_mask & C_LCASE)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1709:    {
    #####: 1710:      for (i = 0; i < 256; i++)
branch  0 never executed
branch  1 never executed
    #####: 1711:        trans_table[i] = tolower (trans_table[i]);
    #####: 1712:      translation_needed = true;
        -: 1713:    }
        -: 1714:
        1: 1715:  if (conversions_mask & C_EBCDIC)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1716:    {
    #####: 1717:      translate_charset (ascii_to_ebcdic);
call    0 never executed
    #####: 1718:      newline_character = ascii_to_ebcdic['\n'];
    #####: 1719:      space_character = ascii_to_ebcdic[' '];
        -: 1720:    }
        1: 1721:  else if (conversions_mask & C_IBM)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1722:    {
    #####: 1723:      translate_charset (ascii_to_ibm);
call    0 never executed
    #####: 1724:      newline_character = ascii_to_ibm['\n'];
    #####: 1725:      space_character = ascii_to_ibm[' '];
        -: 1726:    }
        1: 1727:}
        -: 1728:
        -: 1729:/* Apply the character-set translations specified by the user
        -: 1730:   to the NREAD bytes in BUF.  */
        -: 1731:
        -: 1732:static void
function translate_buffer called 0 returned 0% blocks executed 0%
    #####: 1733:translate_buffer (char *buf, idx_t nread)
        -: 1734:{
        -: 1735:  idx_t i;
        -: 1736:  char *cp;
    #####: 1737:  for (i = nread, cp = buf; i; i--, cp++)
branch  0 never executed
branch  1 never executed
    #####: 1738:    *cp = trans_table[to_uchar (*cp)];
call    0 never executed
    #####: 1739:}
        -: 1740:
        -: 1741:/* Swap *NREAD bytes in BUF, which should have room for an extra byte
        -: 1742:   after the end because the swapping is not in-place.  If *SAVED_BYTE
        -: 1743:   is nonnegative, also swap that initial byte from the previous call.
        -: 1744:   Save the last byte into into *SAVED_BYTE if needed to make the
        -: 1745:   resulting *NREAD even, and set *SAVED_BYTE to -1 otherwise.
        -: 1746:   Return the buffer's adjusted start, either BUF or BUF + 1.  */
        -: 1747:
        -: 1748:static char *
function swab_buffer called 0 returned 0% blocks executed 0%
    #####: 1749:swab_buffer (char *buf, idx_t *nread, int *saved_byte)
        -: 1750:{
    #####: 1751:  if (*nread == 0)
branch  0 never executed
branch  1 never executed
    #####: 1752:    return buf;
        -: 1753:
        -: 1754:  /* Update *SAVED_BYTE, and set PREV_SAVED to its old value.  */
    #####: 1755:  int prev_saved = *saved_byte;
    #####: 1756:  if ((prev_saved < 0) == (*nread & 1))
branch  0 never executed
branch  1 never executed
        -: 1757:    {
    #####: 1758:      unsigned char c = buf[--*nread];
    #####: 1759:      *saved_byte = c;
        -: 1760:    }
        -: 1761:  else
    #####: 1762:    *saved_byte = -1;
        -: 1763:
        -: 1764:  /* Do the byte-swapping by moving every other byte two
        -: 1765:     positions toward the end, working from the end of the buffer
        -: 1766:     toward the beginning.  This way we move only half the data.  */
    #####: 1767:  for (idx_t i = *nread; 1 < i; i -= 2)
branch  0 never executed
branch  1 never executed
    #####: 1768:    buf[i] = buf[i - 2];
        -: 1769:
    #####: 1770:  if (prev_saved < 0)
branch  0 never executed
branch  1 never executed
    #####: 1771:    return buf + 1;
        -: 1772:
    #####: 1773:  buf[1] = prev_saved;
    #####: 1774:  ++*nread;
    #####: 1775:  return buf;
        -: 1776:}
        -: 1777:
        -: 1778:/* Add OFFSET to the input offset, setting the overflow flag if
        -: 1779:   necessary.  */
        -: 1780:
        -: 1781:static void
function advance_input_offset called 1 returned 100% blocks executed 75%
        1: 1782:advance_input_offset (intmax_t offset)
        -: 1783:{
        1: 1784:  if (0 <= input_offset && ckd_add (&input_offset, input_offset, offset))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1785:    input_offset = -1;
        1: 1786:}
        -: 1787:
        -: 1788:/* Throw away RECORDS blocks of BLOCKSIZE bytes plus BYTES bytes on
        -: 1789:   file descriptor FDESC, which is open with read permission for FILE.
        -: 1790:   Store up to BLOCKSIZE bytes of the data at a time in IBUF or OBUF, if
        -: 1791:   necessary. RECORDS or BYTES must be nonzero. If FDESC is
        -: 1792:   STDIN_FILENO, advance the input offset. Return the number of
        -: 1793:   records remaining, i.e., that were not skipped because EOF was
        -: 1794:   reached.  If FDESC is STDOUT_FILENO, on return, BYTES is the
        -: 1795:   remaining bytes in addition to the remaining records.  */
        -: 1796:
        -: 1797:static intmax_t
function skip called 0 returned 0% blocks executed 0%
    #####: 1798:skip (int fdesc, char const *file, intmax_t records, idx_t blocksize,
        -: 1799:      idx_t *bytes)
        -: 1800:{
        -: 1801:  /* Try lseek and if an error indicates it was an inappropriate operation --
        -: 1802:     or if the file offset is not representable as an off_t --
        -: 1803:     fall back on using read.  */
        -: 1804:
    #####: 1805:  errno = 0;
        -: 1806:  off_t offset;
    #####: 1807:  if (! ckd_mul (&offset, records, blocksize)
branch  0 never executed
branch  1 never executed
    #####: 1808:      && ! ckd_add (&offset, offset, *bytes)
branch  0 never executed
branch  1 never executed
    #####: 1809:      && 0 <= lseek (fdesc, offset, SEEK_CUR))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1810:    {
    #####: 1811:      if (fdesc == STDIN_FILENO)
branch  0 never executed
branch  1 never executed
        -: 1812:        {
        -: 1813:           struct stat st;
    #####: 1814:           if (ifstat (STDIN_FILENO, &st) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1815:             error (EXIT_FAILURE, errno, _("cannot fstat %s"), quoteaf (file));
call    0 never executed
call    1 never executed
    #####: 1816:           if (usable_st_size (&st) && 0 <= input_offset
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1817:               && st.st_size - input_offset < offset)
branch  0 never executed
branch  1 never executed
        -: 1818:             {
        -: 1819:               /* When skipping past EOF, return the number of _full_ blocks
        -: 1820:                * that are not skipped, and set offset to EOF, so the caller
        -: 1821:                * can determine the requested skip was not satisfied.  */
    #####: 1822:               records = ( offset - st.st_size ) / blocksize;
    #####: 1823:               offset = st.st_size - input_offset;
        -: 1824:             }
        -: 1825:           else
    #####: 1826:             records = 0;
    #####: 1827:           advance_input_offset (offset);
call    0 never executed
        -: 1828:        }
        -: 1829:      else
        -: 1830:        {
    #####: 1831:          records = 0;
    #####: 1832:          *bytes = 0;
        -: 1833:        }
    #####: 1834:      return records;
        -: 1835:    }
        -: 1836:  else
        -: 1837:    {
    #####: 1838:      int lseek_errno = errno;
        -: 1839:
        -: 1840:      /* The seek request may have failed above if it was too big
        -: 1841:         (> device size, > max file size, etc.)
        -: 1842:         Or it may not have been done at all (> OFF_T_MAX).
        -: 1843:         Therefore try to seek to the end of the file,
        -: 1844:         to avoid redundant reading.  */
    #####: 1845:      if (lseek (fdesc, 0, SEEK_END) >= 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1846:        {
        -: 1847:          /* File is seekable, and we're at the end of it, and
        -: 1848:             size <= OFF_T_MAX. So there's no point using read to advance.  */
        -: 1849:
    #####: 1850:          if (!lseek_errno)
branch  0 never executed
branch  1 never executed
        -: 1851:            {
        -: 1852:              /* The original seek was not attempted as offset > OFF_T_MAX.
        -: 1853:                 We should error for write as can't get to the desired
        -: 1854:                 location, even if OFF_T_MAX < max file size.
        -: 1855:                 For read we're not going to read any data anyway,
        -: 1856:                 so we should error for consistency.
        -: 1857:                 It would be nice to not error for /dev/{zero,null}
        -: 1858:                 for any offset, but that's not a significant issue.  */
    #####: 1859:              lseek_errno = EOVERFLOW;
        -: 1860:            }
        -: 1861:
    #####: 1862:          diagnose (lseek_errno,
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1863:                    gettext (fdesc == STDIN_FILENO
        -: 1864:                             ? N_("%s: cannot skip")
        -: 1865:                             : N_("%s: cannot seek")),
        -: 1866:                    quotef (file));
        -: 1867:          /* If the file has a specific size and we've asked
        -: 1868:             to skip/seek beyond the max allowable, then quit.  */
    #####: 1869:          quit (EXIT_FAILURE);
call    0 never executed
        -: 1870:        }
        -: 1871:      /* else file_size && offset > OFF_T_MAX or file ! seekable */
        -: 1872:
        -: 1873:      char *buf;
    #####: 1874:      if (fdesc == STDIN_FILENO)
branch  0 never executed
branch  1 never executed
        -: 1875:        {
    #####: 1876:          alloc_ibuf ();
call    0 never executed
    #####: 1877:          buf = ibuf;
        -: 1878:        }
        -: 1879:      else
        -: 1880:        {
    #####: 1881:          alloc_obuf ();
call    0 never executed
    #####: 1882:          buf = obuf;
        -: 1883:        }
        -: 1884:
        -: 1885:      do
        -: 1886:        {
    #####: 1887:          ssize_t nread = iread_fnc (fdesc, buf, records ? blocksize : *bytes);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1888:          if (nread < 0)
branch  0 never executed
branch  1 never executed
        -: 1889:            {
    #####: 1890:              if (fdesc == STDIN_FILENO)
branch  0 never executed
branch  1 never executed
        -: 1891:                {
    #####: 1892:                  diagnose (errno, _("error reading %s"), quoteaf (file));
call    0 never executed
call    1 never executed
    #####: 1893:                  if (conversions_mask & C_NOERROR)
branch  0 never executed
branch  1 never executed
    #####: 1894:                    print_stats ();
call    0 never executed
        -: 1895:                }
        -: 1896:              else
    #####: 1897:                diagnose (lseek_errno, _("%s: cannot seek"), quotef (file));
call    0 never executed
call    1 never executed
    #####: 1898:              quit (EXIT_FAILURE);
call    0 never executed
        -: 1899:            }
    #####: 1900:          else if (nread == 0)
branch  0 never executed
branch  1 never executed
    #####: 1901:            break;
    #####: 1902:          else if (fdesc == STDIN_FILENO)
branch  0 never executed
branch  1 never executed
    #####: 1903:            advance_input_offset (nread);
call    0 never executed
        -: 1904:
    #####: 1905:          if (records != 0)
branch  0 never executed
branch  1 never executed
    #####: 1906:            records--;
        -: 1907:          else
    #####: 1908:            *bytes = 0;
        -: 1909:        }
    #####: 1910:      while (records || *bytes);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1911:
    #####: 1912:      return records;
        -: 1913:    }
        -: 1914:}
        -: 1915:
        -: 1916:/* Advance the input by NBYTES if possible, after a read error.
        -: 1917:   The input file offset may or may not have advanced after the failed
        -: 1918:   read; adjust it to point just after the bad record regardless.
        -: 1919:   Return true if successful, or if the input is already known to not
        -: 1920:   be seekable.  */
        -: 1921:
        -: 1922:static bool
function advance_input_after_read_error called 0 returned 0% blocks executed 0%
    #####: 1923:advance_input_after_read_error (idx_t nbytes)
        -: 1924:{
    #####: 1925:  if (! input_seekable)
branch  0 never executed
branch  1 never executed
        -: 1926:    {
    #####: 1927:      if (input_seek_errno == ESPIPE)
branch  0 never executed
branch  1 never executed
    #####: 1928:        return true;
    #####: 1929:      errno = input_seek_errno;
        -: 1930:    }
        -: 1931:  else
        -: 1932:    {
        -: 1933:      off_t offset;
    #####: 1934:      advance_input_offset (nbytes);
call    0 never executed
    #####: 1935:      if (input_offset < 0)
branch  0 never executed
branch  1 never executed
        -: 1936:        {
    #####: 1937:          diagnose (0, _("offset overflow while reading file %s"),
call    0 never executed
call    1 never executed
        -: 1938:                    quoteaf (input_file));
    #####: 1939:          return false;
        -: 1940:        }
    #####: 1941:      offset = lseek (STDIN_FILENO, 0, SEEK_CUR);
call    0 never executed
    #####: 1942:      if (0 <= offset)
branch  0 never executed
branch  1 never executed
        -: 1943:        {
        -: 1944:          off_t diff;
    #####: 1945:          if (offset == input_offset)
branch  0 never executed
branch  1 never executed
    #####: 1946:            return true;
    #####: 1947:          diff = input_offset - offset;
    #####: 1948:          if (! (0 <= diff && diff <= nbytes) && status_level != STATUS_NONE)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1949:            diagnose (0, _("warning: invalid file offset after failed read"));
call    0 never executed
    #####: 1950:          if (0 <= lseek (STDIN_FILENO, diff, SEEK_CUR))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1951:            return true;
    #####: 1952:          if (errno == 0)
branch  0 never executed
branch  1 never executed
    #####: 1953:            diagnose (0, _("cannot work around kernel bug after all"));
call    0 never executed
        -: 1954:        }
        -: 1955:    }
        -: 1956:
    #####: 1957:  diagnose (errno, _("%s: cannot seek"), quotef (input_file));
call    0 never executed
call    1 never executed
    #####: 1958:  return false;
        -: 1959:}
        -: 1960:
        -: 1961:/* Copy NREAD bytes of BUF, with no conversions.  */
        -: 1962:
        -: 1963:static void
function copy_simple called 1 returned 100% blocks executed 80%
        1: 1964:copy_simple (char const *buf, idx_t nread)
        -: 1965:{
        1: 1966:  char const *start = buf;	/* First uncopied char in BUF.  */
        -: 1967:
        -: 1968:  do
        -: 1969:    {
        1: 1970:      idx_t nfree = MIN (nread, output_blocksize - oc);
        -: 1971:
        1: 1972:      memcpy (obuf + oc, start, nfree);
        -: 1973:
        1: 1974:      nread -= nfree;		/* Update the number of bytes left to copy. */
        1: 1975:      start += nfree;
        1: 1976:      oc += nfree;
        1: 1977:      if (oc >= output_blocksize)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1978:        write_output ();
call    0 never executed
        -: 1979:    }
        1: 1980:  while (nread != 0);
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
        1: 1981:}
        -: 1982:
        -: 1983:/* Copy NREAD bytes of BUF, doing conv=block
        -: 1984:   (pad newline-terminated records to 'conversion_blocksize',
        -: 1985:   replacing the newline with trailing spaces).  */
        -: 1986:
        -: 1987:static void
function copy_with_block called 0 returned 0% blocks executed 0%
    #####: 1988:copy_with_block (char const *buf, idx_t nread)
        -: 1989:{
    #####: 1990:  for (idx_t i = nread; i; i--, buf++)
branch  0 never executed
branch  1 never executed
        -: 1991:    {
    #####: 1992:      if (*buf == newline_character)
branch  0 never executed
branch  1 never executed
        -: 1993:        {
    #####: 1994:          if (col < conversion_blocksize)
branch  0 never executed
branch  1 never executed
        -: 1995:            {
        -: 1996:              idx_t j;
    #####: 1997:              for (j = col; j < conversion_blocksize; j++)
branch  0 never executed
branch  1 never executed
    #####: 1998:                output_char (space_character);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1999:            }
    #####: 2000:          col = 0;
        -: 2001:        }
        -: 2002:      else
        -: 2003:        {
    #####: 2004:          if (col == conversion_blocksize)
branch  0 never executed
branch  1 never executed
    #####: 2005:            r_truncate++;
    #####: 2006:          else if (col < conversion_blocksize)
branch  0 never executed
branch  1 never executed
    #####: 2007:            output_char (*buf);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2008:          col++;
        -: 2009:        }
        -: 2010:    }
    #####: 2011:}
        -: 2012:
        -: 2013:/* Copy NREAD bytes of BUF, doing conv=unblock
        -: 2014:   (replace trailing spaces in 'conversion_blocksize'-sized records
        -: 2015:   with a newline).  */
        -: 2016:
        -: 2017:static void
function copy_with_unblock called 0 returned 0% blocks executed 0%
    #####: 2018:copy_with_unblock (char const *buf, idx_t nread)
        -: 2019:{
        -: 2020:  static idx_t pending_spaces = 0;
        -: 2021:
    #####: 2022:  for (idx_t i = 0; i < nread; i++)
branch  0 never executed
branch  1 never executed
        -: 2023:    {
    #####: 2024:      char c = buf[i];
        -: 2025:
    #####: 2026:      if (col++ >= conversion_blocksize)
branch  0 never executed
branch  1 never executed
        -: 2027:        {
    #####: 2028:          col = pending_spaces = 0; /* Wipe out any pending spaces.  */
    #####: 2029:          i--;			/* Push the char back; get it later. */
    #####: 2030:          output_char (newline_character);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2031:        }
    #####: 2032:      else if (c == space_character)
branch  0 never executed
branch  1 never executed
    #####: 2033:        pending_spaces++;
        -: 2034:      else
        -: 2035:        {
        -: 2036:          /* 'c' is the character after a run of spaces that were not
        -: 2037:             at the end of the conversion buffer.  Output them.  */
    #####: 2038:          while (pending_spaces)
branch  0 never executed
branch  1 never executed
        -: 2039:            {
    #####: 2040:              output_char (space_character);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2041:              --pending_spaces;
        -: 2042:            }
    #####: 2043:          output_char (c);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2044:        }
        -: 2045:    }
    #####: 2046:}
        -: 2047:
        -: 2048:/* Set the file descriptor flags for FD that correspond to the nonzero bits
        -: 2049:   in ADD_FLAGS.  The file's name is NAME.  */
        -: 2050:
        -: 2051:static void
function set_fd_flags called 2 returned 100% blocks executed 8%
        2: 2052:set_fd_flags (int fd, int add_flags, char const *name)
        -: 2053:{
        -: 2054:  /* Ignore file creation flags that are no-ops on file descriptors.  */
        2: 2055:  add_flags &= ~ (O_NOCTTY | O_NOFOLLOW);
        -: 2056:
        2: 2057:  if (add_flags)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2058:    {
    #####: 2059:      int old_flags = fcntl (fd, F_GETFL);
call    0 never executed
    #####: 2060:      int new_flags = old_flags | add_flags;
    #####: 2061:      bool ok = true;
    #####: 2062:      if (old_flags < 0)
branch  0 never executed
branch  1 never executed
    #####: 2063:        ok = false;
    #####: 2064:      else if (old_flags != new_flags)
branch  0 never executed
branch  1 never executed
        -: 2065:        {
    #####: 2066:          if (new_flags & (O_DIRECTORY | O_NOLINKS))
branch  0 never executed
branch  1 never executed
        -: 2067:            {
        -: 2068:              /* NEW_FLAGS contains at least one file creation flag that
        -: 2069:                 requires some checking of the open file descriptor.  */
        -: 2070:              struct stat st;
    #####: 2071:              if (ifstat (fd, &st) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2072:                ok = false;
    #####: 2073:              else if ((new_flags & O_DIRECTORY) && ! S_ISDIR (st.st_mode))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2074:                {
    #####: 2075:                  errno = ENOTDIR;
    #####: 2076:                  ok = false;
        -: 2077:                }
        -: 2078:              else if ((new_flags & O_NOLINKS) && 1 < st.st_nlink)
        -: 2079:                {
        -: 2080:                  errno = EMLINK;
        -: 2081:                  ok = false;
        -: 2082:                }
    #####: 2083:              new_flags &= ~ (O_DIRECTORY | O_NOLINKS);
        -: 2084:            }
        -: 2085:
    #####: 2086:          if (ok && old_flags != new_flags
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2087:              && fcntl (fd, F_SETFL, new_flags) == -1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2088:            ok = false;
        -: 2089:        }
        -: 2090:
    #####: 2091:      if (!ok)
branch  0 never executed
branch  1 never executed
    #####: 2092:        error (EXIT_FAILURE, errno, _("setting flags for %s"), quoteaf (name));
call    0 never executed
call    1 never executed
        -: 2093:    }
        2: 2094:}
        -: 2095:
        -: 2096:/* The main loop.  */
        -: 2097:
        -: 2098:static int
function dd_copy called 1 returned 100% blocks executed 26%
        1: 2099:dd_copy (void)
        -: 2100:{
        -: 2101:  char *bufstart;		/* Input buffer. */
        -: 2102:  ssize_t nread;		/* Bytes read in the current block.  */
        -: 2103:
        -: 2104:  /* If nonzero, then the previously read block was partial and
        -: 2105:     PARTREAD was its size.  */
        1: 2106:  idx_t partread = 0;
        -: 2107:
        1: 2108:  int exit_status = EXIT_SUCCESS;
        -: 2109:  idx_t n_bytes_read;
        -: 2110:
        1: 2111:  if (skip_records != 0 || skip_bytes != 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 2112:    {
        -: 2113:      intmax_t us_bytes;
    #####: 2114:      bool us_bytes_overflow =
    #####: 2115:        (ckd_mul (&us_bytes, skip_records, input_blocksize)
    #####: 2116:         || ckd_add (&us_bytes, skip_bytes, us_bytes));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2117:      off_t input_offset0 = input_offset;
    #####: 2118:      intmax_t us_blocks = skip (STDIN_FILENO, input_file,
call    0 never executed
        -: 2119:                                 skip_records, input_blocksize, &skip_bytes);
        -: 2120:
        -: 2121:      /* POSIX doesn't say what to do when dd detects it has been
        -: 2122:         asked to skip past EOF, so I assume it's non-fatal.
        -: 2123:         There are 3 reasons why there might be unskipped blocks/bytes:
        -: 2124:             1. file is too small
        -: 2125:             2. pipe has not enough data
        -: 2126:             3. partial reads  */
    #####: 2127:      if ((us_blocks
branch  0 never executed
branch  1 never executed
    #####: 2128:           || (0 <= input_offset
branch  0 never executed
branch  1 never executed
    #####: 2129:               && (us_bytes_overflow
branch  0 never executed
branch  1 never executed
    #####: 2130:                   || us_bytes != input_offset - input_offset0)))
branch  0 never executed
branch  1 never executed
    #####: 2131:          && status_level != STATUS_NONE)
branch  0 never executed
branch  1 never executed
        -: 2132:        {
    #####: 2133:          diagnose (0, _("%s: cannot skip to specified offset"),
call    0 never executed
call    1 never executed
        -: 2134:                    quotef (input_file));
        -: 2135:        }
        -: 2136:    }
        -: 2137:
        1: 2138:  if (seek_records != 0 || seek_bytes != 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 2139:    {
    #####: 2140:      idx_t bytes = seek_bytes;
    #####: 2141:      intmax_t write_records = skip (STDOUT_FILENO, output_file,
call    0 never executed
        -: 2142:                                      seek_records, output_blocksize, &bytes);
        -: 2143:
    #####: 2144:      if (write_records != 0 || bytes != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2145:        {
    #####: 2146:          memset (obuf, 0, write_records ? output_blocksize : bytes);
branch  0 never executed
branch  1 never executed
        -: 2147:
        -: 2148:          do
        -: 2149:            {
    #####: 2150:              idx_t size = write_records ? output_blocksize : bytes;
branch  0 never executed
branch  1 never executed
    #####: 2151:              if (iwrite (STDOUT_FILENO, obuf, size) != size)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2152:                {
    #####: 2153:                  diagnose (errno, _("writing to %s"), quoteaf (output_file));
call    0 never executed
call    1 never executed
    #####: 2154:                  quit (EXIT_FAILURE);
call    0 never executed
        -: 2155:                }
        -: 2156:
    #####: 2157:              if (write_records != 0)
branch  0 never executed
branch  1 never executed
    #####: 2158:                write_records--;
        -: 2159:              else
    #####: 2160:                bytes = 0;
        -: 2161:            }
    #####: 2162:          while (write_records || bytes);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2163:        }
        -: 2164:    }
        -: 2165:
       1*: 2166:  if (max_records == 0 && max_bytes == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####: 2167:    return exit_status;
        -: 2168:
        1: 2169:  alloc_ibuf ();
call    0 returned 100%
        1: 2170:  alloc_obuf ();
call    0 returned 100%
        1: 2171:  int saved_byte = -1;
        -: 2172:
        -: 2173:  while (true)
        -: 2174:    {
        2: 2175:      if (status_level == STATUS_PROGRESS)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2176:        {
    #####: 2177:          xtime_t progress_time = gethrxtime ();
call    0 never executed
    #####: 2178:          if (next_time <= progress_time)
branch  0 never executed
branch  1 never executed
        -: 2179:            {
    #####: 2180:              print_xfer_stats (progress_time);
call    0 never executed
    #####: 2181:              next_time += XTIME_PRECISION;
        -: 2182:            }
        -: 2183:        }
        -: 2184:
        2: 2185:      if (r_partial + r_full >= max_records + !!max_bytes)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2186:        break;
        -: 2187:
        -: 2188:      /* Zero the buffer before reading, so that if we get a read error,
        -: 2189:         whatever data we are able to read is followed by zeros.
        -: 2190:         This minimizes data loss. */
       2*: 2191:      if ((conversions_mask & C_SYNC) && (conversions_mask & C_NOERROR))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####: 2192:        memset (ibuf,
    #####: 2193:                (conversions_mask & (C_BLOCK | C_UNBLOCK)) ? ' ' : '\0',
branch  0 never executed
branch  1 never executed
        -: 2194:                input_blocksize);
        -: 2195:
        2: 2196:      if (r_partial + r_full >= max_records)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2197:        nread = iread_fnc (STDIN_FILENO, ibuf, max_bytes);
call    0 never executed
        -: 2198:      else
        2: 2199:        nread = iread_fnc (STDIN_FILENO, ibuf, input_blocksize);
call    0 returned 100%
        -: 2200:
        2: 2201:      if (nread > 0)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -: 2202:        {
        1: 2203:          advance_input_offset (nread);
call    0 returned 100%
        1: 2204:          if (i_nocache)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2205:            invalidate_cache (STDIN_FILENO, nread);
call    0 never executed
        -: 2206:        }
        1: 2207:      else if (nread == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 2208:        {
        1: 2209:          i_nocache_eof |= i_nocache;
       1*: 2210:          o_nocache_eof |= o_nocache && ! (conversions_mask & C_NOTRUNC);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        1: 2211:          break;			/* EOF.  */
        -: 2212:        }
        -: 2213:      else
        -: 2214:        {
    #####: 2215:          if (!(conversions_mask & C_NOERROR) || status_level != STATUS_NONE)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2216:            diagnose (errno, _("error reading %s"), quoteaf (input_file));
call    0 never executed
call    1 never executed
        -: 2217:
    #####: 2218:          if (conversions_mask & C_NOERROR)
branch  0 never executed
branch  1 never executed
        -: 2219:            {
    #####: 2220:              print_stats ();
call    0 never executed
    #####: 2221:              idx_t bad_portion = input_blocksize - partread;
        -: 2222:
        -: 2223:              /* We already know this data is not cached,
        -: 2224:                 but call this so that correct offsets are maintained.  */
    #####: 2225:              invalidate_cache (STDIN_FILENO, bad_portion);
call    0 never executed
        -: 2226:
        -: 2227:              /* Seek past the bad block if possible. */
    #####: 2228:              if (!advance_input_after_read_error (bad_portion))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2229:                {
    #####: 2230:                  exit_status = EXIT_FAILURE;
        -: 2231:
        -: 2232:                  /* Suppress duplicate diagnostics.  */
    #####: 2233:                  input_seekable = false;
    #####: 2234:                  input_seek_errno = ESPIPE;
        -: 2235:                }
    #####: 2236:              if ((conversions_mask & C_SYNC) && !partread)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2237:                /* Replace the missing input with null bytes and
        -: 2238:                   proceed normally.  */
    #####: 2239:                nread = 0;
        -: 2240:              else
    #####: 2241:                continue;
        -: 2242:            }
        -: 2243:          else
        -: 2244:            {
        -: 2245:              /* Write any partial block. */
    #####: 2246:              exit_status = EXIT_FAILURE;
    #####: 2247:              break;
        -: 2248:            }
        -: 2249:        }
        -: 2250:
        1: 2251:      n_bytes_read = nread;
        -: 2252:
        1: 2253:      if (n_bytes_read < input_blocksize)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 2254:        {
        1: 2255:          r_partial++;
        1: 2256:          partread = n_bytes_read;
        1: 2257:          if (conversions_mask & C_SYNC)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2258:            {
    #####: 2259:              if (!(conversions_mask & C_NOERROR))
branch  0 never executed
branch  1 never executed
        -: 2260:                /* If C_NOERROR, we zeroed the block before reading. */
    #####: 2261:                memset (ibuf + n_bytes_read,
    #####: 2262:                        (conversions_mask & (C_BLOCK | C_UNBLOCK)) ? ' ' : '\0',
    #####: 2263:                        input_blocksize - n_bytes_read);
branch  0 never executed
branch  1 never executed
    #####: 2264:              n_bytes_read = input_blocksize;
        -: 2265:            }
        -: 2266:        }
        -: 2267:      else
        -: 2268:        {
    #####: 2269:          r_full++;
    #####: 2270:          partread = 0;
        -: 2271:        }
        -: 2272:
        1: 2273:      if (ibuf == obuf)		/* If not C_TWOBUFS. */
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2274:        {
    #####: 2275:          idx_t nwritten = iwrite (STDOUT_FILENO, obuf, n_bytes_read);
call    0 never executed
    #####: 2276:          w_bytes += nwritten;
    #####: 2277:          if (nwritten != n_bytes_read)
branch  0 never executed
branch  1 never executed
        -: 2278:            {
    #####: 2279:              diagnose (errno, _("error writing %s"), quoteaf (output_file));
call    0 never executed
call    1 never executed
    #####: 2280:              return EXIT_FAILURE;
        -: 2281:            }
    #####: 2282:          else if (n_bytes_read == input_blocksize)
branch  0 never executed
branch  1 never executed
    #####: 2283:            w_full++;
        -: 2284:          else
    #####: 2285:            w_partial++;
    #####: 2286:          continue;
        -: 2287:        }
        -: 2288:
        -: 2289:      /* Do any translations on the whole buffer at once.  */
        -: 2290:
        1: 2291:      if (translation_needed)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2292:        translate_buffer (ibuf, n_bytes_read);
call    0 never executed
        -: 2293:
        1: 2294:      if (conversions_mask & C_SWAB)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2295:        bufstart = swab_buffer (ibuf, &n_bytes_read, &saved_byte);
call    0 never executed
        -: 2296:      else
        1: 2297:        bufstart = ibuf;
        -: 2298:
        1: 2299:      if (conversions_mask & C_BLOCK)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2300:        copy_with_block (bufstart, n_bytes_read);
call    0 never executed
        1: 2301:      else if (conversions_mask & C_UNBLOCK)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2302:        copy_with_unblock (bufstart, n_bytes_read);
call    0 never executed
        -: 2303:      else
        1: 2304:        copy_simple (bufstart, n_bytes_read);
call    0 returned 100%
        -: 2305:    }
        -: 2306:
        -: 2307:  /* If we have a char left as a result of conv=swab, output it.  */
        1: 2308:  if (0 <= saved_byte)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2309:    {
    #####: 2310:      char saved_char = saved_byte;
    #####: 2311:      if (conversions_mask & C_BLOCK)
branch  0 never executed
branch  1 never executed
    #####: 2312:        copy_with_block (&saved_char, 1);
call    0 never executed
    #####: 2313:      else if (conversions_mask & C_UNBLOCK)
branch  0 never executed
branch  1 never executed
    #####: 2314:        copy_with_unblock (&saved_char, 1);
call    0 never executed
        -: 2315:      else
    #####: 2316:        output_char (saved_char);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2317:    }
        -: 2318:
       1*: 2319:  if ((conversions_mask & C_BLOCK) && col > 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        -: 2320:    {
        -: 2321:      /* If the final input line didn't end with a '\n', pad
        -: 2322:         the output block to 'conversion_blocksize' chars.  */
    #####: 2323:      for (idx_t i = col; i < conversion_blocksize; i++)
branch  0 never executed
branch  1 never executed
    #####: 2324:        output_char (space_character);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2325:    }
        -: 2326:
       1*: 2327:  if (col && (conversions_mask & C_UNBLOCK))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        -: 2328:    {
        -: 2329:      /* If there was any output, add a final '\n'.  */
    #####: 2330:      output_char (newline_character);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2331:    }
        -: 2332:
        -: 2333:  /* Write out the last block. */
        1: 2334:  if (oc != 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 2335:    {
        1: 2336:      idx_t nwritten = iwrite (STDOUT_FILENO, obuf, oc);
call    0 returned 100%
        1: 2337:      w_bytes += nwritten;
        1: 2338:      if (nwritten != 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 2339:        w_partial++;
        1: 2340:      if (nwritten != oc)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2341:        {
    #####: 2342:          diagnose (errno, _("error writing %s"), quoteaf (output_file));
call    0 never executed
call    1 never executed
    #####: 2343:          return EXIT_FAILURE;
        -: 2344:        }
        -: 2345:    }
        -: 2346:
        -: 2347:  /* If the last write was converted to a seek, then for a regular file
        -: 2348:     or shared memory object, ftruncate to extend the size.  */
        1: 2349:  if (final_op_was_seek)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2350:    {
        -: 2351:      struct stat stdout_stat;
    #####: 2352:      if (ifstat (STDOUT_FILENO, &stdout_stat) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2353:        {
    #####: 2354:          diagnose (errno, _("cannot fstat %s"), quoteaf (output_file));
call    0 never executed
call    1 never executed
    #####: 2355:          return EXIT_FAILURE;
        -: 2356:        }
    #####: 2357:      if (S_ISREG (stdout_stat.st_mode) || S_TYPEISSHM (&stdout_stat))
branch  0 never executed
branch  1 never executed
        -: 2358:        {
    #####: 2359:          off_t output_offset = lseek (STDOUT_FILENO, 0, SEEK_CUR);
call    0 never executed
    #####: 2360:          if (0 <= output_offset && stdout_stat.st_size < output_offset)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2361:            {
    #####: 2362:              if (iftruncate (STDOUT_FILENO, output_offset) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2363:                {
    #####: 2364:                  diagnose (errno, _("failed to truncate to %" PRIdMAX " bytes"
call    0 never executed
call    1 never executed
        -: 2365:                                     " in output file %s"),
        -: 2366:                            (intmax_t) output_offset, quoteaf (output_file));
    #####: 2367:                  return EXIT_FAILURE;
        -: 2368:                }
        -: 2369:            }
        -: 2370:        }
        -: 2371:    }
        -: 2372:
        -: 2373:  /* fdatasync/fsync can take a long time, so issue a final progress
        -: 2374:     indication now if progress has been made since the previous indication.  */
        1: 2375:  if (conversions_mask & (C_FDATASYNC | C_FSYNC)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2376:      && status_level == STATUS_PROGRESS
branch  0 never executed
branch  1 never executed
    #####: 2377:      && 0 <= reported_w_bytes && reported_w_bytes < w_bytes)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2378:    print_xfer_stats (0);
call    0 never executed
        -: 2379:
        1: 2380:  return exit_status;
        -: 2381:}
        -: 2382:
        -: 2383:/* Synchronize output according to conversions_mask.
        -: 2384:   Do this even if w_bytes is zero, as fsync and fdatasync
        -: 2385:   flush out write requests from other processes too.
        -: 2386:   Clear bits in conversions_mask so that synchronization is done only once.
        -: 2387:   Return zero if successful, an exit status otherwise.  */
        -: 2388:
        -: 2389:static int
function synchronize_output called 2 returned 100% blocks executed 24%
        2: 2390:synchronize_output (void)
        -: 2391:{
        2: 2392:  int exit_status = 0;
        2: 2393:  int mask = conversions_mask;
        2: 2394:  conversions_mask &= ~ (C_FDATASYNC | C_FSYNC);
        -: 2395:
       2*: 2396:  if ((mask & C_FDATASYNC) && ifdatasync (STDOUT_FILENO) != 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 2397:    {
    #####: 2398:      if (errno != ENOSYS && errno != EINVAL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2399:        {
    #####: 2400:          diagnose (errno, _("fdatasync failed for %s"), quoteaf (output_file));
call    0 never executed
call    1 never executed
    #####: 2401:          exit_status = EXIT_FAILURE;
        -: 2402:        }
    #####: 2403:      mask |= C_FSYNC;
        -: 2404:    }
        -: 2405:
       2*: 2406:  if ((mask & C_FSYNC) && ifsync (STDOUT_FILENO) != 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 2407:    {
    #####: 2408:      diagnose (errno, _("fsync failed for %s"), quoteaf (output_file));
call    0 never executed
call    1 never executed
    #####: 2409:      return EXIT_FAILURE;
        -: 2410:    }
        -: 2411:
        2: 2412:  return exit_status;
        -: 2413:}
        -: 2414:
        -: 2415:int
function main called 5 returned 20% blocks executed 32%
        5: 2416:main (int argc, char **argv)
        -: 2417:{
        -: 2418:  int i;
        -: 2419:  int exit_status;
        -: 2420:  off_t offset;
        -: 2421:
        5: 2422:  install_signal_handlers ();
call    0 returned 100%
        -: 2423:
        -: 2424:  initialize_main (&argc, &argv);
        5: 2425:  set_program_name (argv[0]);
call    0 returned 100%
        5: 2426:  setlocale (LC_ALL, "");
call    0 returned 100%
        -: 2427:  bindtextdomain (PACKAGE, LOCALEDIR);
        -: 2428:  textdomain (PACKAGE);
        -: 2429:
        -: 2430:  /* Arrange to close stdout if parse_long_options exits.  */
        5: 2431:  atexit (maybe_close_stdout);
call    0 returned 100%
        -: 2432:
        5: 2433:  page_size = getpagesize ();
        -: 2434:
        5: 2435:  parse_gnu_standard_options_only (argc, argv, PROGRAM_NAME, PACKAGE, Version,
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 80%
        -: 2436:                                   true, usage, AUTHORS,
        -: 2437:                                   (char const *) nullptr);
        4: 2438:  close_stdout_required = false;
        -: 2439:
        -: 2440:  /* Initialize translation table to identity translation. */
     1028: 2441:  for (i = 0; i < 256; i++)
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
     1024: 2442:    trans_table[i] = i;
        -: 2443:
        -: 2444:  /* Decode arguments. */
        4: 2445:  scanargs (argc, argv);
call    0 returned 25%
        -: 2446:
        1: 2447:  apply_translations ();
call    0 returned 100%
        -: 2448:
        1: 2449:  if (input_file == nullptr)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 2450:    {
        1: 2451:      input_file = _("standard input");
        1: 2452:      set_fd_flags (STDIN_FILENO, input_flags, input_file);
call    0 returned 100%
        -: 2453:    }
        -: 2454:  else
        -: 2455:    {
    #####: 2456:      if (ifd_reopen (STDIN_FILENO, input_file, O_RDONLY | input_flags, 0) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2457:        error (EXIT_FAILURE, errno, _("failed to open %s"),
call    0 never executed
call    1 never executed
        -: 2458:               quoteaf (input_file));
        -: 2459:    }
        -: 2460:
        1: 2461:  offset = lseek (STDIN_FILENO, 0, SEEK_CUR);
call    0 returned 100%
        1: 2462:  input_seekable = (0 <= offset);
        1: 2463:  input_offset = MAX (0, offset);
        1: 2464:  input_seek_errno = errno;
        -: 2465:
        1: 2466:  if (output_file == nullptr)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 2467:    {
        1: 2468:      output_file = _("standard output");
        1: 2469:      set_fd_flags (STDOUT_FILENO, output_flags, output_file);
call    0 returned 100%
        -: 2470:    }
        -: 2471:  else
        -: 2472:    {
    #####: 2473:      mode_t perms = MODE_RW_UGO;
    #####: 2474:      int opts
        -: 2475:        = (output_flags
    #####: 2476:           | (conversions_mask & C_NOCREAT ? 0 : O_CREAT)
branch  0 never executed
branch  1 never executed
    #####: 2477:           | (conversions_mask & C_EXCL ? O_EXCL : 0)
    #####: 2478:           | (seek_records || (conversions_mask & C_NOTRUNC) ? 0 : O_TRUNC));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2479:
        -: 2480:      off_t size;
    #####: 2481:      if ((ckd_mul (&size, seek_records, output_blocksize)
branch  0 never executed
branch  1 never executed
    #####: 2482:           || ckd_add (&size, seek_bytes, size))
branch  0 never executed
branch  1 never executed
    #####: 2483:          && !(conversions_mask & C_NOTRUNC))
branch  0 never executed
branch  1 never executed
    #####: 2484:        error (EXIT_FAILURE, 0,
call    0 never executed
        -: 2485:               _("offset too large: "
        -: 2486:                 "cannot truncate to a length of seek=%"PRIdMAX""
        -: 2487:                 " (%td-byte) blocks"),
        -: 2488:               seek_records, output_blocksize);
        -: 2489:
        -: 2490:      /* Open the output file with *read* access only if we might
        -: 2491:         need to read to satisfy a 'seek=' request.  If we can't read
        -: 2492:         the file, go ahead with write-only access; it might work.  */
    #####: 2493:      if ((! seek_records
branch  0 never executed
branch  1 never executed
    #####: 2494:           || ifd_reopen (STDOUT_FILENO, output_file, O_RDWR | opts, perms) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2495:          && (ifd_reopen (STDOUT_FILENO, output_file, O_WRONLY | opts, perms)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2496:              < 0))
    #####: 2497:        error (EXIT_FAILURE, errno, _("failed to open %s"),
call    0 never executed
call    1 never executed
        -: 2498:               quoteaf (output_file));
        -: 2499:
    #####: 2500:      if (seek_records != 0 && !(conversions_mask & C_NOTRUNC))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2501:        {
    #####: 2502:          if (iftruncate (STDOUT_FILENO, size) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2503:            {
        -: 2504:              /* Complain only when ftruncate fails on a regular file, a
        -: 2505:                 directory, or a shared memory object, as POSIX 1003.1-2004
        -: 2506:                 specifies ftruncate's behavior only for these file types.
        -: 2507:                 For example, do not complain when Linux kernel 2.4 ftruncate
        -: 2508:                 fails on /dev/fd0.  */
    #####: 2509:              int ftruncate_errno = errno;
        -: 2510:              struct stat stdout_stat;
    #####: 2511:              if (ifstat (STDOUT_FILENO, &stdout_stat) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2512:                {
    #####: 2513:                  diagnose (errno, _("cannot fstat %s"), quoteaf (output_file));
call    0 never executed
call    1 never executed
    #####: 2514:                  exit_status = EXIT_FAILURE;
        -: 2515:                }
    #####: 2516:              else if (S_ISREG (stdout_stat.st_mode)
branch  0 never executed
branch  1 never executed
    #####: 2517:                       || S_ISDIR (stdout_stat.st_mode)
    #####: 2518:                       || S_TYPEISSHM (&stdout_stat))
branch  0 never executed
branch  1 never executed
        -: 2519:                {
    #####: 2520:                  intmax_t isize = size;
    #####: 2521:                  diagnose (ftruncate_errno,
call    0 never executed
call    1 never executed
        -: 2522:                            _("failed to truncate to %"PRIdMAX" bytes"
        -: 2523:                              " in output file %s"),
        -: 2524:                            isize, quoteaf (output_file));
    #####: 2525:                  exit_status = EXIT_FAILURE;
        -: 2526:                }
        -: 2527:            }
        -: 2528:        }
        -: 2529:    }
        -: 2530:
        1: 2531:  start_time = gethrxtime ();
call    0 returned 100%
        1: 2532:  next_time = start_time + XTIME_PRECISION;
        -: 2533:
        1: 2534:  exit_status = dd_copy ();
call    0 returned 100%
        -: 2535:
        1: 2536:  int sync_status = synchronize_output ();
call    0 returned 100%
        1: 2537:  if (sync_status)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2538:    exit_status = sync_status;
        -: 2539:
       1*: 2540:  if (max_records == 0 && max_bytes == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        -: 2541:    {
        -: 2542:      /* Special case to invalidate cache to end of file.  */
    #####: 2543:      if (i_nocache && !invalidate_cache (STDIN_FILENO, 0))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 2544:        {
    #####: 2545:          diagnose (errno, _("failed to discard cache for: %s"),
call    0 never executed
call    1 never executed
        -: 2546:                    quotef (input_file));
    #####: 2547:          exit_status = EXIT_FAILURE;
        -: 2548:        }
    #####: 2549:      if (o_nocache && !invalidate_cache (STDOUT_FILENO, 0))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 2550:        {
    #####: 2551:          diagnose (errno, _("failed to discard cache for: %s"),
call    0 never executed
call    1 never executed
        -: 2552:                    quotef (output_file));
    #####: 2553:          exit_status = EXIT_FAILURE;
        -: 2554:        }
        -: 2555:    }
        -: 2556:  else
        -: 2557:    {
        -: 2558:      /* Invalidate any pending region or to EOF if appropriate.  */
        1: 2559:      if (i_nocache || i_nocache_eof)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2560:        invalidate_cache (STDIN_FILENO, 0);
call    0 never executed
        1: 2561:      if (o_nocache || o_nocache_eof)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2562:        invalidate_cache (STDOUT_FILENO, 0);
call    0 never executed
        -: 2563:    }
        -: 2564:
        1: 2565:  finish_up ();
call    0 returned 100%
        1: 2566:  main_exit (exit_status);
        -: 2567:}
