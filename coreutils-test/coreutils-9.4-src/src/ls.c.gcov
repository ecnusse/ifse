        -:    0:Source:src/ls.c
        -:    0:Graph:ls.gcno
        -:    0:Data:ls.gcda
        -:    0:Runs:2
        -:    1:/* 'dir', 'vdir' and 'ls' directory listing programs for GNU.
        -:    2:   Copyright (C) 1985-2023 Free Software Foundation, Inc.
        -:    3:
        -:    4:   This program is free software: you can redistribute it and/or modify
        -:    5:   it under the terms of the GNU General Public License as published by
        -:    6:   the Free Software Foundation, either version 3 of the License, or
        -:    7:   (at your option) any later version.
        -:    8:
        -:    9:   This program is distributed in the hope that it will be useful,
        -:   10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   12:   GNU General Public License for more details.
        -:   13:
        -:   14:   You should have received a copy of the GNU General Public License
        -:   15:   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
        -:   16:
        -:   17:/* If ls_mode is LS_MULTI_COL,
        -:   18:   the multi-column format is the default regardless
        -:   19:   of the type of output device.
        -:   20:   This is for the 'dir' program.
        -:   21:
        -:   22:   If ls_mode is LS_LONG_FORMAT,
        -:   23:   the long format is the default regardless of the
        -:   24:   type of output device.
        -:   25:   This is for the 'vdir' program.
        -:   26:
        -:   27:   If ls_mode is LS_LS,
        -:   28:   the output format depends on whether the output
        -:   29:   device is a terminal.
        -:   30:   This is for the 'ls' program.  */
        -:   31:
        -:   32:/* Written by Richard Stallman and David MacKenzie.  */
        -:   33:
        -:   34:/* Color support by Peter Anvin <Peter.Anvin@linux.org> and Dennis
        -:   35:   Flaherty <dennisf@denix.elk.miles.com> based on original patches by
        -:   36:   Greg Lee <lee@uhunix.uhcc.hawaii.edu>.  */
        -:   37:
        -:   38:#include <config.h>
        -:   39:#include <sys/types.h>
        -:   40:
        -:   41:#include <termios.h>
        -:   42:#if HAVE_STROPTS_H
        -:   43:# include <stropts.h>
        -:   44:#endif
        -:   45:#include <sys/ioctl.h>
        -:   46:
        -:   47:#ifdef WINSIZE_IN_PTEM
        -:   48:# include <sys/stream.h>
        -:   49:# include <sys/ptem.h>
        -:   50:#endif
        -:   51:
        -:   52:#include <stdio.h>
        -:   53:#include <setjmp.h>
        -:   54:#include <pwd.h>
        -:   55:#include <getopt.h>
        -:   56:#include <signal.h>
        -:   57:#include <selinux/selinux.h>
        -:   58:#include <wchar.h>
        -:   59:
        -:   60:#if HAVE_LANGINFO_CODESET
        -:   61:# include <langinfo.h>
        -:   62:#endif
        -:   63:
        -:   64:/* Use SA_NOCLDSTOP as a proxy for whether the sigaction machinery is
        -:   65:   present.  */
        -:   66:#ifndef SA_NOCLDSTOP
        -:   67:# define SA_NOCLDSTOP 0
        -:   68:# define sigprocmask(How, Set, Oset) /* empty */
        -:   69:# define sigset_t int
        -:   70:# if ! HAVE_SIGINTERRUPT
        -:   71:#  define siginterrupt(sig, flag) /* empty */
        -:   72:# endif
        -:   73:#endif
        -:   74:
        -:   75:/* NonStop circa 2011 lacks both SA_RESTART and siginterrupt, so don't
        -:   76:   restart syscalls after a signal handler fires.  This may cause
        -:   77:   colors to get messed up on the screen if 'ls' is interrupted, but
        -:   78:   that's the best we can do on such a platform.  */
        -:   79:#ifndef SA_RESTART
        -:   80:# define SA_RESTART 0
        -:   81:#endif
        -:   82:
        -:   83:#include "system.h"
        -:   84:#include <fnmatch.h>
        -:   85:
        -:   86:#include "acl.h"
        -:   87:#include "argmatch.h"
        -:   88:#include "assure.h"
        -:   89:#include "c-strcase.h"
        -:   90:#include "dev-ino.h"
        -:   91:#include "filenamecat.h"
        -:   92:#include "hard-locale.h"
        -:   93:#include "hash.h"
        -:   94:#include "human.h"
        -:   95:#include "filemode.h"
        -:   96:#include "filevercmp.h"
        -:   97:#include "idcache.h"
        -:   98:#include "ls.h"
        -:   99:#include "mbswidth.h"
        -:  100:#include "mpsort.h"
        -:  101:#include "obstack.h"
        -:  102:#include "quote.h"
        -:  103:#include "smack.h"
        -:  104:#include "stat-size.h"
        -:  105:#include "stat-time.h"
        -:  106:#include "strftime.h"
        -:  107:#include "xdectoint.h"
        -:  108:#include "xstrtol.h"
        -:  109:#include "xstrtol-error.h"
        -:  110:#include "areadlink.h"
        -:  111:#include "mbsalign.h"
        -:  112:#include "dircolors.h"
        -:  113:#include "xgethostname.h"
        -:  114:#include "c-ctype.h"
        -:  115:#include "canonicalize.h"
        -:  116:#include "statx.h"
        -:  117:
        -:  118:/* Include <sys/capability.h> last to avoid a clash of <sys/types.h>
        -:  119:   include guards with some premature versions of libcap.
        -:  120:   For more details, see <https://bugzilla.redhat.com/483548>.  */
        -:  121:#ifdef HAVE_CAP
        -:  122:# include <sys/capability.h>
        -:  123:#endif
        -:  124:
        -:  125:#define PROGRAM_NAME (ls_mode == LS_LS ? "ls" \
        -:  126:                      : (ls_mode == LS_MULTI_COL \
        -:  127:                         ? "dir" : "vdir"))
        -:  128:
        -:  129:#define AUTHORS \
        -:  130:  proper_name ("Richard M. Stallman"), \
        -:  131:  proper_name ("David MacKenzie")
        -:  132:
        -:  133:#define obstack_chunk_alloc malloc
        -:  134:#define obstack_chunk_free free
        -:  135:
        -:  136:/* Unix-based readdir implementations have historically returned a dirent.d_ino
        -:  137:   value that is sometimes not equal to the stat-obtained st_ino value for
        -:  138:   that same entry.  This error occurs for a readdir entry that refers
        -:  139:   to a mount point.  readdir's error is to return the inode number of
        -:  140:   the underlying directory -- one that typically cannot be stat'ed, as
        -:  141:   long as a file system is mounted on that directory.  RELIABLE_D_INO
        -:  142:   encapsulates whether we can use the more efficient approach of relying
        -:  143:   on readdir-supplied d_ino values, or whether we must incur the cost of
        -:  144:   calling stat or lstat to obtain each guaranteed-valid inode number.  */
        -:  145:
        -:  146:#ifndef READDIR_LIES_ABOUT_MOUNTPOINT_D_INO
        -:  147:# define READDIR_LIES_ABOUT_MOUNTPOINT_D_INO 1
        -:  148:#endif
        -:  149:
        -:  150:#if READDIR_LIES_ABOUT_MOUNTPOINT_D_INO
        -:  151:# define RELIABLE_D_INO(dp) NOT_AN_INODE_NUMBER
        -:  152:#else
        -:  153:# define RELIABLE_D_INO(dp) D_INO (dp)
        -:  154:#endif
        -:  155:
        -:  156:#if ! HAVE_STRUCT_STAT_ST_AUTHOR
        -:  157:# define st_author st_uid
        -:  158:#endif
        -:  159:
        -:  160:enum filetype
        -:  161:  {
        -:  162:    unknown,
        -:  163:    fifo,
        -:  164:    chardev,
        -:  165:    directory,
        -:  166:    blockdev,
        -:  167:    normal,
        -:  168:    symbolic_link,
        -:  169:    sock,
        -:  170:    whiteout,
        -:  171:    arg_directory
        -:  172:  };
        -:  173:
        -:  174:/* Display letters and indicators for each filetype.
        -:  175:   Keep these in sync with enum filetype.  */
        -:  176:static char const filetype_letter[] = "?pcdb-lswd";
        -:  177:
        -:  178:/* Ensure that filetype and filetype_letter have the same
        -:  179:   number of elements.  */
        -:  180:static_assert (sizeof filetype_letter - 1 == arg_directory + 1);
        -:  181:
        -:  182:#define FILETYPE_INDICATORS				\
        -:  183:  {							\
        -:  184:    C_ORPHAN, C_FIFO, C_CHR, C_DIR, C_BLK, C_FILE,	\
        -:  185:    C_LINK, C_SOCK, C_FILE, C_DIR			\
        -:  186:  }
        -:  187:
        -:  188:enum acl_type
        -:  189:  {
        -:  190:    ACL_T_NONE,
        -:  191:    ACL_T_LSM_CONTEXT_ONLY,
        -:  192:    ACL_T_YES
        -:  193:  };
        -:  194:
        -:  195:struct fileinfo
        -:  196:  {
        -:  197:    /* The file name.  */
        -:  198:    char *name;
        -:  199:
        -:  200:    /* For symbolic link, name of the file linked to, otherwise zero.  */
        -:  201:    char *linkname;
        -:  202:
        -:  203:    /* For terminal hyperlinks. */
        -:  204:    char *absolute_name;
        -:  205:
        -:  206:    struct stat stat;
        -:  207:
        -:  208:    enum filetype filetype;
        -:  209:
        -:  210:    /* For symbolic link and long listing, st_mode of file linked to, otherwise
        -:  211:       zero.  */
        -:  212:    mode_t linkmode;
        -:  213:
        -:  214:    /* security context.  */
        -:  215:    char *scontext;
        -:  216:
        -:  217:    bool stat_ok;
        -:  218:
        -:  219:    /* For symbolic link and color printing, true if linked-to file
        -:  220:       exists, otherwise false.  */
        -:  221:    bool linkok;
        -:  222:
        -:  223:    /* For long listings, true if the file has an access control list,
        -:  224:       or a security context.  */
        -:  225:    enum acl_type acl_type;
        -:  226:
        -:  227:    /* For color listings, true if a regular file has capability info.  */
        -:  228:    bool has_capability;
        -:  229:
        -:  230:    /* Whether file name needs quoting. tri-state with -1 == unknown.  */
        -:  231:    int quoted;
        -:  232:
        -:  233:    /* Cached screen width (including quoting).  */
        -:  234:    size_t width;
        -:  235:  };
        -:  236:
        -:  237:#define LEN_STR_PAIR(s) sizeof (s) - 1, s
        -:  238:
        -:  239:/* Null is a valid character in a color indicator (think about Epson
        -:  240:   printers, for example) so we have to use a length/buffer string
        -:  241:   type.  */
        -:  242:
        -:  243:struct bin_str
        -:  244:  {
        -:  245:    size_t len;			/* Number of bytes */
        -:  246:    char const *string;		/* Pointer to the same */
        -:  247:  };
        -:  248:
        -:  249:#if ! HAVE_TCGETPGRP
        -:  250:# define tcgetpgrp(Fd) 0
        -:  251:#endif
        -:  252:
        -:  253:static size_t quote_name (char const *name,
        -:  254:                          struct quoting_options const *options,
        -:  255:                          int needs_general_quoting,
        -:  256:                          const struct bin_str *color,
        -:  257:                          bool allow_pad, struct obstack *stack,
        -:  258:                          char const *absolute_name);
        -:  259:static size_t quote_name_buf (char **inbuf, size_t bufsize, char *name,
        -:  260:                              struct quoting_options const *options,
        -:  261:                              int needs_general_quoting, size_t *width,
        -:  262:                              bool *pad);
        -:  263:static int decode_switches (int argc, char **argv);
        -:  264:static bool file_ignored (char const *name);
        -:  265:static uintmax_t gobble_file (char const *name, enum filetype type,
        -:  266:                              ino_t inode, bool command_line_arg,
        -:  267:                              char const *dirname);
        -:  268:static const struct bin_str * get_color_indicator (const struct fileinfo *f,
        -:  269:                                                   bool symlink_target);
        -:  270:static bool print_color_indicator (const struct bin_str *ind);
        -:  271:static void put_indicator (const struct bin_str *ind);
        -:  272:static void add_ignore_pattern (char const *pattern);
        -:  273:static void attach (char *dest, char const *dirname, char const *name);
        -:  274:static void clear_files (void);
        -:  275:static void extract_dirs_from_files (char const *dirname,
        -:  276:                                     bool command_line_arg);
        -:  277:static void get_link_name (char const *filename, struct fileinfo *f,
        -:  278:                           bool command_line_arg);
        -:  279:static void indent (size_t from, size_t to);
        -:  280:static size_t calculate_columns (bool by_columns);
        -:  281:static void print_current_files (void);
        -:  282:static void print_dir (char const *name, char const *realname,
        -:  283:                       bool command_line_arg);
        -:  284:static size_t print_file_name_and_frills (const struct fileinfo *f,
        -:  285:                                          size_t start_col);
        -:  286:static void print_horizontal (void);
        -:  287:static int format_user_width (uid_t u);
        -:  288:static int format_group_width (gid_t g);
        -:  289:static void print_long_format (const struct fileinfo *f);
        -:  290:static void print_many_per_line (void);
        -:  291:static size_t print_name_with_quoting (const struct fileinfo *f,
        -:  292:                                       bool symlink_target,
        -:  293:                                       struct obstack *stack,
        -:  294:                                       size_t start_col);
        -:  295:static void prep_non_filename_text (void);
        -:  296:static bool print_type_indicator (bool stat_ok, mode_t mode,
        -:  297:                                  enum filetype type);
        -:  298:static void print_with_separator (char sep);
        -:  299:static void queue_directory (char const *name, char const *realname,
        -:  300:                             bool command_line_arg);
        -:  301:static void sort_files (void);
        -:  302:static void parse_ls_color (void);
        -:  303:
        -:  304:static int getenv_quoting_style (void);
        -:  305:
        -:  306:static size_t quote_name_width (char const *name,
        -:  307:                                struct quoting_options const *options,
        -:  308:                                int needs_general_quoting);
        -:  309:
        -:  310:/* Initial size of hash table.
        -:  311:   Most hierarchies are likely to be shallower than this.  */
        -:  312:enum { INITIAL_TABLE_SIZE = 30 };
        -:  313:
        -:  314:/* The set of 'active' directories, from the current command-line argument
        -:  315:   to the level in the hierarchy at which files are being listed.
        -:  316:   A directory is represented by its device and inode numbers (struct dev_ino).
        -:  317:   A directory is added to this set when ls begins listing it or its
        -:  318:   entries, and it is removed from the set just after ls has finished
        -:  319:   processing it.  This set is used solely to detect loops, e.g., with
        -:  320:   mkdir loop; cd loop; ln -s ../loop sub; ls -RL  */
        -:  321:static Hash_table *active_dir_set;
        -:  322:
        -:  323:#define LOOP_DETECT (!!active_dir_set)
        -:  324:
        -:  325:/* The table of files in the current directory:
        -:  326:
        -:  327:   'cwd_file' points to a vector of 'struct fileinfo', one per file.
        -:  328:   'cwd_n_alloc' is the number of elements space has been allocated for.
        -:  329:   'cwd_n_used' is the number actually in use.  */
        -:  330:
        -:  331:/* Address of block containing the files that are described.  */
        -:  332:static struct fileinfo *cwd_file;
        -:  333:
        -:  334:/* Length of block that 'cwd_file' points to, measured in files.  */
        -:  335:static size_t cwd_n_alloc;
        -:  336:
        -:  337:/* Index of first unused slot in 'cwd_file'.  */
        -:  338:static size_t cwd_n_used;
        -:  339:
        -:  340:/* Whether files needs may need padding due to quoting.  */
        -:  341:static bool cwd_some_quoted;
        -:  342:
        -:  343:/* Whether quoting style _may_ add outer quotes,
        -:  344:   and whether aligning those is useful.  */
        -:  345:static bool align_variable_outer_quotes;
        -:  346:
        -:  347:/* Vector of pointers to files, in proper sorted order, and the number
        -:  348:   of entries allocated for it.  */
        -:  349:static void **sorted_file;
        -:  350:static size_t sorted_file_alloc;
        -:  351:
        -:  352:/* When true, in a color listing, color each symlink name according to the
        -:  353:   type of file it points to.  Otherwise, color them according to the 'ln'
        -:  354:   directive in LS_COLORS.  Dangling (orphan) symlinks are treated specially,
        -:  355:   regardless.  This is set when 'ln=target' appears in LS_COLORS.  */
        -:  356:
        -:  357:static bool color_symlink_as_referent;
        -:  358:
        -:  359:static char const *hostname;
        -:  360:
        -:  361:/* Mode of appropriate file for coloring.  */
        -:  362:static mode_t
function file_or_link_mode called 0 returned 0% blocks executed 0%
    #####:  363:file_or_link_mode (struct fileinfo const *file)
        -:  364:{
    #####:  365:  return (color_symlink_as_referent && file->linkok
branch  0 never executed
branch  1 never executed
    #####:  366:          ? file->linkmode : file->stat.st_mode);
branch  0 never executed
branch  1 never executed
        -:  367:}
        -:  368:
        -:  369:
        -:  370:/* Record of one pending directory waiting to be listed.  */
        -:  371:
        -:  372:struct pending
        -:  373:  {
        -:  374:    char *name;
        -:  375:    /* If the directory is actually the file pointed to by a symbolic link we
        -:  376:       were told to list, 'realname' will contain the name of the symbolic
        -:  377:       link, otherwise zero.  */
        -:  378:    char *realname;
        -:  379:    bool command_line_arg;
        -:  380:    struct pending *next;
        -:  381:  };
        -:  382:
        -:  383:static struct pending *pending_dirs;
        -:  384:
        -:  385:/* Current time in seconds and nanoseconds since 1970, updated as
        -:  386:   needed when deciding whether a file is recent.  */
        -:  387:
        -:  388:static struct timespec current_time;
        -:  389:
        -:  390:static bool print_scontext;
        -:  391:static char UNKNOWN_SECURITY_CONTEXT[] = "?";
        -:  392:
        -:  393:/* Whether any of the files has an ACL.  This affects the width of the
        -:  394:   mode column.  */
        -:  395:
        -:  396:static bool any_has_acl;
        -:  397:
        -:  398:/* The number of columns to use for columns containing inode numbers,
        -:  399:   block sizes, link counts, owners, groups, authors, major device
        -:  400:   numbers, minor device numbers, and file sizes, respectively.  */
        -:  401:
        -:  402:static int inode_number_width;
        -:  403:static int block_size_width;
        -:  404:static int nlink_width;
        -:  405:static int scontext_width;
        -:  406:static int owner_width;
        -:  407:static int group_width;
        -:  408:static int author_width;
        -:  409:static int major_device_number_width;
        -:  410:static int minor_device_number_width;
        -:  411:static int file_size_width;
        -:  412:
        -:  413:/* Option flags */
        -:  414:
        -:  415:/* long_format for lots of info, one per line.
        -:  416:   one_per_line for just names, one per line.
        -:  417:   many_per_line for just names, many per line, sorted vertically.
        -:  418:   horizontal for just names, many per line, sorted horizontally.
        -:  419:   with_commas for just names, many per line, separated by commas.
        -:  420:
        -:  421:   -l (and other options that imply -l), -1, -C, -x and -m control
        -:  422:   this parameter.  */
        -:  423:
        -:  424:enum format
        -:  425:  {
        -:  426:    long_format,		/* -l and other options that imply -l */
        -:  427:    one_per_line,		/* -1 */
        -:  428:    many_per_line,		/* -C */
        -:  429:    horizontal,			/* -x */
        -:  430:    with_commas			/* -m */
        -:  431:  };
        -:  432:
        -:  433:static enum format format;
        -:  434:
        -:  435:/* 'full-iso' uses full ISO-style dates and times.  'long-iso' uses longer
        -:  436:   ISO-style timestamps, though shorter than 'full-iso'.  'iso' uses shorter
        -:  437:   ISO-style timestamps.  'locale' uses locale-dependent timestamps.  */
        -:  438:enum time_style
        -:  439:  {
        -:  440:    full_iso_time_style,	/* --time-style=full-iso */
        -:  441:    long_iso_time_style,	/* --time-style=long-iso */
        -:  442:    iso_time_style,		/* --time-style=iso */
        -:  443:    locale_time_style		/* --time-style=locale */
        -:  444:  };
        -:  445:
        -:  446:static char const *const time_style_args[] =
        -:  447:{
        -:  448:  "full-iso", "long-iso", "iso", "locale", nullptr
        -:  449:};
        -:  450:static enum time_style const time_style_types[] =
        -:  451:{
        -:  452:  full_iso_time_style, long_iso_time_style, iso_time_style,
        -:  453:  locale_time_style
        -:  454:};
        -:  455:ARGMATCH_VERIFY (time_style_args, time_style_types);
        -:  456:
        -:  457:/* Type of time to print or sort by.  Controlled by -c and -u.
        -:  458:   The values of each item of this enum are important since they are
        -:  459:   used as indices in the sort functions array (see sort_files()).  */
        -:  460:
        -:  461:enum time_type
        -:  462:  {
        -:  463:    time_mtime = 0,		/* default */
        -:  464:    time_ctime,			/* -c */
        -:  465:    time_atime,			/* -u */
        -:  466:    time_btime,                 /* birth time */
        -:  467:    time_numtypes		/* the number of elements of this enum */
        -:  468:  };
        -:  469:
        -:  470:static enum time_type time_type;
        -:  471:
        -:  472:/* The file characteristic to sort by.  Controlled by -t, -S, -U, -X, -v.
        -:  473:   The values of each item of this enum are important since they are
        -:  474:   used as indices in the sort functions array (see sort_files()).  */
        -:  475:
        -:  476:enum sort_type
        -:  477:  {
        -:  478:    sort_name = 0,		/* default */
        -:  479:    sort_extension,		/* -X */
        -:  480:    sort_width,
        -:  481:    sort_size,			/* -S */
        -:  482:    sort_version,		/* -v */
        -:  483:    sort_time,			/* -t; must be second to last */
        -:  484:    sort_none,			/* -U; must be last */
        -:  485:    sort_numtypes		/* the number of elements of this enum */
        -:  486:  };
        -:  487:
        -:  488:static enum sort_type sort_type;
        -:  489:
        -:  490:/* Direction of sort.
        -:  491:   false means highest first if numeric,
        -:  492:   lowest first if alphabetic;
        -:  493:   these are the defaults.
        -:  494:   true means the opposite order in each case.  -r  */
        -:  495:
        -:  496:static bool sort_reverse;
        -:  497:
        -:  498:/* True means to display owner information.  -g turns this off.  */
        -:  499:
        -:  500:static bool print_owner = true;
        -:  501:
        -:  502:/* True means to display author information.  */
        -:  503:
        -:  504:static bool print_author;
        -:  505:
        -:  506:/* True means to display group information.  -G and -o turn this off.  */
        -:  507:
        -:  508:static bool print_group = true;
        -:  509:
        -:  510:/* True means print the user and group id's as numbers rather
        -:  511:   than as names.  -n  */
        -:  512:
        -:  513:static bool numeric_ids;
        -:  514:
        -:  515:/* True means mention the size in blocks of each file.  -s  */
        -:  516:
        -:  517:static bool print_block_size;
        -:  518:
        -:  519:/* Human-readable options for output, when printing block counts.  */
        -:  520:static int human_output_opts;
        -:  521:
        -:  522:/* The units to use when printing block counts.  */
        -:  523:static uintmax_t output_block_size;
        -:  524:
        -:  525:/* Likewise, but for file sizes.  */
        -:  526:static int file_human_output_opts;
        -:  527:static uintmax_t file_output_block_size = 1;
        -:  528:
        -:  529:/* Follow the output with a special string.  Using this format,
        -:  530:   Emacs' dired mode starts up twice as fast, and can handle all
        -:  531:   strange characters in file names.  */
        -:  532:static bool dired;
        -:  533:
        -:  534:/* 'none' means don't mention the type of files.
        -:  535:   'slash' means mention directories only, with a '/'.
        -:  536:   'file_type' means mention file types.
        -:  537:   'classify' means mention file types and mark executables.
        -:  538:
        -:  539:   Controlled by -F, -p, and --indicator-style.  */
        -:  540:
        -:  541:enum indicator_style
        -:  542:  {
        -:  543:    none = 0,	/*     --indicator-style=none (default) */
        -:  544:    slash,	/* -p, --indicator-style=slash */
        -:  545:    file_type,	/*     --indicator-style=file-type */
        -:  546:    classify	/* -F, --indicator-style=classify */
        -:  547:  };
        -:  548:
        -:  549:static enum indicator_style indicator_style;
        -:  550:
        -:  551:/* Names of indicator styles.  */
        -:  552:static char const *const indicator_style_args[] =
        -:  553:{
        -:  554:  "none", "slash", "file-type", "classify", nullptr
        -:  555:};
        -:  556:static enum indicator_style const indicator_style_types[] =
        -:  557:{
        -:  558:  none, slash, file_type, classify
        -:  559:};
        -:  560:ARGMATCH_VERIFY (indicator_style_args, indicator_style_types);
        -:  561:
        -:  562:/* True means use colors to mark types.  Also define the different
        -:  563:   colors as well as the stuff for the LS_COLORS environment variable.
        -:  564:   The LS_COLORS variable is now in a termcap-like format.  */
        -:  565:
        -:  566:static bool print_with_color;
        -:  567:
        -:  568:static bool print_hyperlink;
        -:  569:
        -:  570:/* Whether we used any colors in the output so far.  If so, we will
        -:  571:   need to restore the default color later.  If not, we will need to
        -:  572:   call prep_non_filename_text before using color for the first time. */
        -:  573:
        -:  574:static bool used_color = false;
        -:  575:
        -:  576:enum when_type
        -:  577:  {
        -:  578:    when_never,		/* 0: default or --color=never */
        -:  579:    when_always,	/* 1: --color=always */
        -:  580:    when_if_tty		/* 2: --color=tty */
        -:  581:  };
        -:  582:
        -:  583:enum Dereference_symlink
        -:  584:  {
        -:  585:    DEREF_UNDEFINED = 0,		/* default */
        -:  586:    DEREF_NEVER,
        -:  587:    DEREF_COMMAND_LINE_ARGUMENTS,	/* -H */
        -:  588:    DEREF_COMMAND_LINE_SYMLINK_TO_DIR,	/* the default, in certain cases */
        -:  589:    DEREF_ALWAYS			/* -L */
        -:  590:  };
        -:  591:
        -:  592:enum indicator_no
        -:  593:  {
        -:  594:    C_LEFT, C_RIGHT, C_END, C_RESET, C_NORM, C_FILE, C_DIR, C_LINK,
        -:  595:    C_FIFO, C_SOCK,
        -:  596:    C_BLK, C_CHR, C_MISSING, C_ORPHAN, C_EXEC, C_DOOR, C_SETUID, C_SETGID,
        -:  597:    C_STICKY, C_OTHER_WRITABLE, C_STICKY_OTHER_WRITABLE, C_CAP, C_MULTIHARDLINK,
        -:  598:    C_CLR_TO_EOL
        -:  599:  };
        -:  600:
        -:  601:static char const *const indicator_name[]=
        -:  602:  {
        -:  603:    "lc", "rc", "ec", "rs", "no", "fi", "di", "ln", "pi", "so",
        -:  604:    "bd", "cd", "mi", "or", "ex", "do", "su", "sg", "st",
        -:  605:    "ow", "tw", "ca", "mh", "cl", nullptr
        -:  606:  };
        -:  607:
        -:  608:struct color_ext_type
        -:  609:  {
        -:  610:    struct bin_str ext;		/* The extension we're looking for */
        -:  611:    struct bin_str seq;		/* The sequence to output when we do */
        -:  612:    bool   exact_match;		/* Whether to compare case insensitively */
        -:  613:    struct color_ext_type *next;	/* Next in list */
        -:  614:  };
        -:  615:
        -:  616:static struct bin_str color_indicator[] =
        -:  617:  {
        -:  618:    { LEN_STR_PAIR ("\033[") },		/* lc: Left of color sequence */
        -:  619:    { LEN_STR_PAIR ("m") },		/* rc: Right of color sequence */
        -:  620:    { 0, nullptr },			/* ec: End color (replaces lc+rs+rc) */
        -:  621:    { LEN_STR_PAIR ("0") },		/* rs: Reset to ordinary colors */
        -:  622:    { 0, nullptr },			/* no: Normal */
        -:  623:    { 0, nullptr },			/* fi: File: default */
        -:  624:    { LEN_STR_PAIR ("01;34") },		/* di: Directory: bright blue */
        -:  625:    { LEN_STR_PAIR ("01;36") },		/* ln: Symlink: bright cyan */
        -:  626:    { LEN_STR_PAIR ("33") },		/* pi: Pipe: yellow/brown */
        -:  627:    { LEN_STR_PAIR ("01;35") },		/* so: Socket: bright magenta */
        -:  628:    { LEN_STR_PAIR ("01;33") },		/* bd: Block device: bright yellow */
        -:  629:    { LEN_STR_PAIR ("01;33") },		/* cd: Char device: bright yellow */
        -:  630:    { 0, nullptr },			/* mi: Missing file: undefined */
        -:  631:    { 0, nullptr },			/* or: Orphaned symlink: undefined */
        -:  632:    { LEN_STR_PAIR ("01;32") },		/* ex: Executable: bright green */
        -:  633:    { LEN_STR_PAIR ("01;35") },		/* do: Door: bright magenta */
        -:  634:    { LEN_STR_PAIR ("37;41") },		/* su: setuid: white on red */
        -:  635:    { LEN_STR_PAIR ("30;43") },		/* sg: setgid: black on yellow */
        -:  636:    { LEN_STR_PAIR ("37;44") },		/* st: sticky: black on blue */
        -:  637:    { LEN_STR_PAIR ("34;42") },		/* ow: other-writable: blue on green */
        -:  638:    { LEN_STR_PAIR ("30;42") },		/* tw: ow w/ sticky: black on green */
        -:  639:    { 0, nullptr },			/* ca: disabled by default */
        -:  640:    { 0, nullptr },			/* mh: disabled by default */
        -:  641:    { LEN_STR_PAIR ("\033[K") },	/* cl: clear to end of line */
        -:  642:  };
        -:  643:
        -:  644:/* A list mapping file extensions to corresponding display sequence.  */
        -:  645:static struct color_ext_type *color_ext_list = nullptr;
        -:  646:
        -:  647:/* Buffer for color sequences */
        -:  648:static char *color_buf;
        -:  649:
        -:  650:/* True means to check for orphaned symbolic link, for displaying
        -:  651:   colors, or to group symlink to directories with other dirs.  */
        -:  652:
        -:  653:static bool check_symlink_mode;
        -:  654:
        -:  655:/* True means mention the inode number of each file.  -i  */
        -:  656:
        -:  657:static bool print_inode;
        -:  658:
        -:  659:/* What to do with symbolic links.  Affected by -d, -F, -H, -l (and
        -:  660:   other options that imply -l), and -L.  */
        -:  661:
        -:  662:static enum Dereference_symlink dereference;
        -:  663:
        -:  664:/* True means when a directory is found, display info on its
        -:  665:   contents.  -R  */
        -:  666:
        -:  667:static bool recursive;
        -:  668:
        -:  669:/* True means when an argument is a directory name, display info
        -:  670:   on it itself.  -d  */
        -:  671:
        -:  672:static bool immediate_dirs;
        -:  673:
        -:  674:/* True means that directories are grouped before files. */
        -:  675:
        -:  676:static bool directories_first;
        -:  677:
        -:  678:/* Which files to ignore.  */
        -:  679:
        -:  680:static enum
        -:  681:{
        -:  682:  /* Ignore files whose names start with '.', and files specified by
        -:  683:     --hide and --ignore.  */
        -:  684:  IGNORE_DEFAULT = 0,
        -:  685:
        -:  686:  /* Ignore '.', '..', and files specified by --ignore.  */
        -:  687:  IGNORE_DOT_AND_DOTDOT,
        -:  688:
        -:  689:  /* Ignore only files specified by --ignore.  */
        -:  690:  IGNORE_MINIMAL
        -:  691:} ignore_mode;
        -:  692:
        -:  693:/* A linked list of shell-style globbing patterns.  If a non-argument
        -:  694:   file name matches any of these patterns, it is ignored.
        -:  695:   Controlled by -I.  Multiple -I options accumulate.
        -:  696:   The -B option adds '*~' and '.*~' to this list.  */
        -:  697:
        -:  698:struct ignore_pattern
        -:  699:  {
        -:  700:    char const *pattern;
        -:  701:    struct ignore_pattern *next;
        -:  702:  };
        -:  703:
        -:  704:static struct ignore_pattern *ignore_patterns;
        -:  705:
        -:  706:/* Similar to IGNORE_PATTERNS, except that -a or -A causes this
        -:  707:   variable itself to be ignored.  */
        -:  708:static struct ignore_pattern *hide_patterns;
        -:  709:
        -:  710:/* True means output nongraphic chars in file names as '?'.
        -:  711:   (-q, --hide-control-chars)
        -:  712:   qmark_funny_chars and the quoting style (-Q, --quoting-style=WORD) are
        -:  713:   independent.  The algorithm is: first, obey the quoting style to get a
        -:  714:   string representing the file name;  then, if qmark_funny_chars is set,
        -:  715:   replace all nonprintable chars in that string with '?'.  It's necessary
        -:  716:   to replace nonprintable chars even in quoted strings, because we don't
        -:  717:   want to mess up the terminal if control chars get sent to it, and some
        -:  718:   quoting methods pass through control chars as-is.  */
        -:  719:static bool qmark_funny_chars;
        -:  720:
        -:  721:/* Quoting options for file and dir name output.  */
        -:  722:
        -:  723:static struct quoting_options *filename_quoting_options;
        -:  724:static struct quoting_options *dirname_quoting_options;
        -:  725:
        -:  726:/* The number of chars per hardware tab stop.  Setting this to zero
        -:  727:   inhibits the use of TAB characters for separating columns.  -T */
        -:  728:static size_t tabsize;
        -:  729:
        -:  730:/* True means print each directory name before listing it.  */
        -:  731:
        -:  732:static bool print_dir_name;
        -:  733:
        -:  734:/* The line length to use for breaking lines in many-per-line format.
        -:  735:   Can be set with -w.  If zero, there is no limit.  */
        -:  736:
        -:  737:static size_t line_length;
        -:  738:
        -:  739:/* The local time zone rules, as per the TZ environment variable.  */
        -:  740:
        -:  741:static timezone_t localtz;
        -:  742:
        -:  743:/* If true, the file listing format requires that stat be called on
        -:  744:   each file.  */
        -:  745:
        -:  746:static bool format_needs_stat;
        -:  747:
        -:  748:/* Similar to 'format_needs_stat', but set if only the file type is
        -:  749:   needed.  */
        -:  750:
        -:  751:static bool format_needs_type;
        -:  752:
        -:  753:/* An arbitrary limit on the number of bytes in a printed timestamp.
        -:  754:   This is set to a relatively small value to avoid the need to worry
        -:  755:   about denial-of-service attacks on servers that run "ls" on behalf
        -:  756:   of remote clients.  1000 bytes should be enough for any practical
        -:  757:   timestamp format.  */
        -:  758:
        -:  759:enum { TIME_STAMP_LEN_MAXIMUM = MAX (1000, INT_STRLEN_BOUND (time_t)) };
        -:  760:
        -:  761:/* strftime formats for non-recent and recent files, respectively, in
        -:  762:   -l output.  */
        -:  763:
        -:  764:static char const *long_time_format[2] =
        -:  765:  {
        -:  766:    /* strftime format for non-recent files (older than 6 months), in
        -:  767:       -l output.  This should contain the year, month and day (at
        -:  768:       least), in an order that is understood by people in your
        -:  769:       locale's territory.  Please try to keep the number of used
        -:  770:       screen columns small, because many people work in windows with
        -:  771:       only 80 columns.  But make this as wide as the other string
        -:  772:       below, for recent files.  */
        -:  773:    /* TRANSLATORS: ls output needs to be aligned for ease of reading,
        -:  774:       so be wary of using variable width fields from the locale.
        -:  775:       Note %b is handled specially by ls and aligned correctly.
        -:  776:       Note also that specifying a width as in %5b is erroneous as strftime
        -:  777:       will count bytes rather than characters in multibyte locales.  */
        -:  778:    N_("%b %e  %Y"),
        -:  779:    /* strftime format for recent files (younger than 6 months), in -l
        -:  780:       output.  This should contain the month, day and time (at
        -:  781:       least), in an order that is understood by people in your
        -:  782:       locale's territory.  Please try to keep the number of used
        -:  783:       screen columns small, because many people work in windows with
        -:  784:       only 80 columns.  But make this as wide as the other string
        -:  785:       above, for non-recent files.  */
        -:  786:    /* TRANSLATORS: ls output needs to be aligned for ease of reading,
        -:  787:       so be wary of using variable width fields from the locale.
        -:  788:       Note %b is handled specially by ls and aligned correctly.
        -:  789:       Note also that specifying a width as in %5b is erroneous as strftime
        -:  790:       will count bytes rather than characters in multibyte locales.  */
        -:  791:    N_("%b %e %H:%M")
        -:  792:  };
        -:  793:
        -:  794:/* The set of signals that are caught.  */
        -:  795:
        -:  796:static sigset_t caught_signals;
        -:  797:
        -:  798:/* If nonzero, the value of the pending fatal signal.  */
        -:  799:
        -:  800:static sig_atomic_t volatile interrupt_signal;
        -:  801:
        -:  802:/* A count of the number of pending stop signals that have been received.  */
        -:  803:
        -:  804:static sig_atomic_t volatile stop_signal_count;
        -:  805:
        -:  806:/* Desired exit status.  */
        -:  807:
        -:  808:static int exit_status;
        -:  809:
        -:  810:/* Exit statuses.  */
        -:  811:enum
        -:  812:  {
        -:  813:    /* "ls" had a minor problem.  E.g., while processing a directory,
        -:  814:       ls obtained the name of an entry via readdir, yet was later
        -:  815:       unable to stat that name.  This happens when listing a directory
        -:  816:       in which entries are actively being removed or renamed.  */
        -:  817:    LS_MINOR_PROBLEM = 1,
        -:  818:
        -:  819:    /* "ls" had more serious trouble (e.g., memory exhausted, invalid
        -:  820:       option or failure to stat a command line argument.  */
        -:  821:    LS_FAILURE = 2
        -:  822:  };
        -:  823:
        -:  824:/* For long options that have no equivalent short option, use a
        -:  825:   non-character as a pseudo short option, starting with CHAR_MAX + 1.  */
        -:  826:enum
        -:  827:{
        -:  828:  AUTHOR_OPTION = CHAR_MAX + 1,
        -:  829:  BLOCK_SIZE_OPTION,
        -:  830:  COLOR_OPTION,
        -:  831:  DEREFERENCE_COMMAND_LINE_SYMLINK_TO_DIR_OPTION,
        -:  832:  FILE_TYPE_INDICATOR_OPTION,
        -:  833:  FORMAT_OPTION,
        -:  834:  FULL_TIME_OPTION,
        -:  835:  GROUP_DIRECTORIES_FIRST_OPTION,
        -:  836:  HIDE_OPTION,
        -:  837:  HYPERLINK_OPTION,
        -:  838:  INDICATOR_STYLE_OPTION,
        -:  839:  QUOTING_STYLE_OPTION,
        -:  840:  SHOW_CONTROL_CHARS_OPTION,
        -:  841:  SI_OPTION,
        -:  842:  SORT_OPTION,
        -:  843:  TIME_OPTION,
        -:  844:  TIME_STYLE_OPTION,
        -:  845:  ZERO_OPTION,
        -:  846:};
        -:  847:
        -:  848:static struct option const long_options[] =
        -:  849:{
        -:  850:  {"all", no_argument, nullptr, 'a'},
        -:  851:  {"escape", no_argument, nullptr, 'b'},
        -:  852:  {"directory", no_argument, nullptr, 'd'},
        -:  853:  {"dired", no_argument, nullptr, 'D'},
        -:  854:  {"full-time", no_argument, nullptr, FULL_TIME_OPTION},
        -:  855:  {"group-directories-first", no_argument, nullptr,
        -:  856:   GROUP_DIRECTORIES_FIRST_OPTION},
        -:  857:  {"human-readable", no_argument, nullptr, 'h'},
        -:  858:  {"inode", no_argument, nullptr, 'i'},
        -:  859:  {"kibibytes", no_argument, nullptr, 'k'},
        -:  860:  {"numeric-uid-gid", no_argument, nullptr, 'n'},
        -:  861:  {"no-group", no_argument, nullptr, 'G'},
        -:  862:  {"hide-control-chars", no_argument, nullptr, 'q'},
        -:  863:  {"reverse", no_argument, nullptr, 'r'},
        -:  864:  {"size", no_argument, nullptr, 's'},
        -:  865:  {"width", required_argument, nullptr, 'w'},
        -:  866:  {"almost-all", no_argument, nullptr, 'A'},
        -:  867:  {"ignore-backups", no_argument, nullptr, 'B'},
        -:  868:  {"classify", optional_argument, nullptr, 'F'},
        -:  869:  {"file-type", no_argument, nullptr, FILE_TYPE_INDICATOR_OPTION},
        -:  870:  {"si", no_argument, nullptr, SI_OPTION},
        -:  871:  {"dereference-command-line", no_argument, nullptr, 'H'},
        -:  872:  {"dereference-command-line-symlink-to-dir", no_argument, nullptr,
        -:  873:   DEREFERENCE_COMMAND_LINE_SYMLINK_TO_DIR_OPTION},
        -:  874:  {"hide", required_argument, nullptr, HIDE_OPTION},
        -:  875:  {"ignore", required_argument, nullptr, 'I'},
        -:  876:  {"indicator-style", required_argument, nullptr, INDICATOR_STYLE_OPTION},
        -:  877:  {"dereference", no_argument, nullptr, 'L'},
        -:  878:  {"literal", no_argument, nullptr, 'N'},
        -:  879:  {"quote-name", no_argument, nullptr, 'Q'},
        -:  880:  {"quoting-style", required_argument, nullptr, QUOTING_STYLE_OPTION},
        -:  881:  {"recursive", no_argument, nullptr, 'R'},
        -:  882:  {"format", required_argument, nullptr, FORMAT_OPTION},
        -:  883:  {"show-control-chars", no_argument, nullptr, SHOW_CONTROL_CHARS_OPTION},
        -:  884:  {"sort", required_argument, nullptr, SORT_OPTION},
        -:  885:  {"tabsize", required_argument, nullptr, 'T'},
        -:  886:  {"time", required_argument, nullptr, TIME_OPTION},
        -:  887:  {"time-style", required_argument, nullptr, TIME_STYLE_OPTION},
        -:  888:  {"zero", no_argument, nullptr, ZERO_OPTION},
        -:  889:  {"color", optional_argument, nullptr, COLOR_OPTION},
        -:  890:  {"hyperlink", optional_argument, nullptr, HYPERLINK_OPTION},
        -:  891:  {"block-size", required_argument, nullptr, BLOCK_SIZE_OPTION},
        -:  892:  {"context", no_argument, 0, 'Z'},
        -:  893:  {"author", no_argument, nullptr, AUTHOR_OPTION},
        -:  894:  {GETOPT_HELP_OPTION_DECL},
        -:  895:  {GETOPT_VERSION_OPTION_DECL},
        -:  896:  {nullptr, 0, nullptr, 0}
        -:  897:};
        -:  898:
        -:  899:static char const *const format_args[] =
        -:  900:{
        -:  901:  "verbose", "long", "commas", "horizontal", "across",
        -:  902:  "vertical", "single-column", nullptr
        -:  903:};
        -:  904:static enum format const format_types[] =
        -:  905:{
        -:  906:  long_format, long_format, with_commas, horizontal, horizontal,
        -:  907:  many_per_line, one_per_line
        -:  908:};
        -:  909:ARGMATCH_VERIFY (format_args, format_types);
        -:  910:
        -:  911:static char const *const sort_args[] =
        -:  912:{
        -:  913:  "none", "time", "size", "extension", "version", "width", nullptr
        -:  914:};
        -:  915:static enum sort_type const sort_types[] =
        -:  916:{
        -:  917:  sort_none, sort_time, sort_size, sort_extension, sort_version, sort_width
        -:  918:};
        -:  919:ARGMATCH_VERIFY (sort_args, sort_types);
        -:  920:
        -:  921:static char const *const time_args[] =
        -:  922:{
        -:  923:  "atime", "access", "use",
        -:  924:  "ctime", "status",
        -:  925:  "mtime", "modification",
        -:  926:  "birth", "creation",
        -:  927:  nullptr
        -:  928:};
        -:  929:static enum time_type const time_types[] =
        -:  930:{
        -:  931:  time_atime, time_atime, time_atime,
        -:  932:  time_ctime, time_ctime,
        -:  933:  time_mtime, time_mtime,
        -:  934:  time_btime, time_btime,
        -:  935:};
        -:  936:ARGMATCH_VERIFY (time_args, time_types);
        -:  937:
        -:  938:static char const *const when_args[] =
        -:  939:{
        -:  940:  /* force and none are for compatibility with another color-ls version */
        -:  941:  "always", "yes", "force",
        -:  942:  "never", "no", "none",
        -:  943:  "auto", "tty", "if-tty", nullptr
        -:  944:};
        -:  945:static enum when_type const when_types[] =
        -:  946:{
        -:  947:  when_always, when_always, when_always,
        -:  948:  when_never, when_never, when_never,
        -:  949:  when_if_tty, when_if_tty, when_if_tty
        -:  950:};
        -:  951:ARGMATCH_VERIFY (when_args, when_types);
        -:  952:
        -:  953:/* Information about filling a column.  */
        -:  954:struct column_info
        -:  955:{
        -:  956:  bool valid_len;
        -:  957:  size_t line_len;
        -:  958:  size_t *col_arr;
        -:  959:};
        -:  960:
        -:  961:/* Array with information about column fullness.  */
        -:  962:static struct column_info *column_info;
        -:  963:
        -:  964:/* Maximum number of columns ever possible for this display.  */
        -:  965:static size_t max_idx;
        -:  966:
        -:  967:/* The minimum width of a column is 3: 1 character for the name and 2
        -:  968:   for the separating white space.  */
        -:  969:enum { MIN_COLUMN_WIDTH = 3 };
        -:  970:
        -:  971:
        -:  972:/* This zero-based index is for the --dired option.  It is incremented
        -:  973:   for each byte of output generated by this program so that the beginning
        -:  974:   and ending indices (in that output) of every file name can be recorded
        -:  975:   and later output themselves.  */
        -:  976:static off_t dired_pos;
        -:  977:
        -:  978:static void
function dired_outbyte called 0 returned 0% blocks executed 0%
    #####:  979:dired_outbyte (char c)
        -:  980:{
    #####:  981:  dired_pos++;
    #####:  982:  putchar (c);
call    0 never executed
    #####:  983:}
        -:  984:
        -:  985:/* Output the buffer S, of length S_LEN, and increment DIRED_POS by S_LEN.  */
        -:  986:static void
function dired_outbuf called 0 returned 0% blocks executed 0%
    #####:  987:dired_outbuf (char const *s, size_t s_len)
        -:  988:{
    #####:  989:  dired_pos += s_len;
    #####:  990:  fwrite (s, sizeof *s, s_len, stdout);
call    0 never executed
    #####:  991:}
        -:  992:
        -:  993:/* Output the string S, and increment DIRED_POS by its length.  */
        -:  994:static void
function dired_outstring called 0 returned 0% blocks executed 0%
    #####:  995:dired_outstring (char const *s)
        -:  996:{
    #####:  997:  dired_outbuf (s, strlen (s));
call    0 never executed
    #####:  998:}
        -:  999:
        -: 1000:static void
function dired_indent called 0 returned 0% blocks executed 0%
    #####: 1001:dired_indent (void)
        -: 1002:{
    #####: 1003:  if (dired)
branch  0 never executed
branch  1 never executed
    #####: 1004:    dired_outstring ("  ");
call    0 never executed
    #####: 1005:}
        -: 1006:
        -: 1007:/* With --dired, store pairs of beginning and ending indices of file names.  */
        -: 1008:static struct obstack dired_obstack;
        -: 1009:
        -: 1010:/* With --dired, store pairs of beginning and ending indices of any
        -: 1011:   directory names that appear as headers (just before 'total' line)
        -: 1012:   for lists of directory entries.  Such directory names are seen when
        -: 1013:   listing hierarchies using -R and when a directory is listed with at
        -: 1014:   least one other command line argument.  */
        -: 1015:static struct obstack subdired_obstack;
        -: 1016:
        -: 1017:/* Save the current index on the specified obstack, OBS.  */
        -: 1018:static void
function push_current_dired_pos called 0 returned 0% blocks executed 0%
    #####: 1019:push_current_dired_pos (struct obstack *obs)
        -: 1020:{
    #####: 1021:  if (dired)
branch  0 never executed
branch  1 never executed
    #####: 1022:    obstack_grow (obs, &dired_pos, sizeof dired_pos);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1023:}
        -: 1024:
        -: 1025:/* With -R, this stack is used to help detect directory cycles.
        -: 1026:   The device/inode pairs on this stack mirror the pairs in the
        -: 1027:   active_dir_set hash table.  */
        -: 1028:static struct obstack dev_ino_obstack;
        -: 1029:
        -: 1030:/* Push a pair onto the device/inode stack.  */
        -: 1031:static void
function dev_ino_push called 0 returned 0% blocks executed 0%
    #####: 1032:dev_ino_push (dev_t dev, ino_t ino)
        -: 1033:{
        -: 1034:  void *vdi;
        -: 1035:  struct dev_ino *di;
    #####: 1036:  int dev_ino_size = sizeof *di;
    #####: 1037:  obstack_blank (&dev_ino_obstack, dev_ino_size);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1038:  vdi = obstack_next_free (&dev_ino_obstack);
    #####: 1039:  di = vdi;
    #####: 1040:  di--;
    #####: 1041:  di->st_dev = dev;
    #####: 1042:  di->st_ino = ino;
    #####: 1043:}
        -: 1044:
        -: 1045:/* Pop a dev/ino struct off the global dev_ino_obstack
        -: 1046:   and return that struct.  */
        -: 1047:static struct dev_ino
function dev_ino_pop called 0 returned 0% blocks executed 0%
    #####: 1048:dev_ino_pop (void)
        -: 1049:{
        -: 1050:  void *vdi;
        -: 1051:  struct dev_ino *di;
    #####: 1052:  int dev_ino_size = sizeof *di;
    #####: 1053:  affirm (dev_ino_size <= obstack_object_size (&dev_ino_obstack));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1054:  obstack_blank_fast (&dev_ino_obstack, -dev_ino_size);
    #####: 1055:  vdi = obstack_next_free (&dev_ino_obstack);
    #####: 1056:  di = vdi;
    #####: 1057:  return *di;
        -: 1058:}
        -: 1059:
        -: 1060:static void
function assert_matching_dev_ino called 0 returned 0% blocks executed 0%
    #####: 1061:assert_matching_dev_ino (char const *name, struct dev_ino di)
        -: 1062:{
        -: 1063:  MAYBE_UNUSED struct stat sb;
    #####: 1064:  assure (0 <= stat (name, &sb));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1065:  assure (sb.st_dev == di.st_dev);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1066:  assure (sb.st_ino == di.st_ino);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1067:}
        -: 1068:
        -: 1069:static char eolbyte = '\n';
        -: 1070:
        -: 1071:/* Write to standard output PREFIX, followed by the quoting style and
        -: 1072:   a space-separated list of the integers stored in OS all on one line.  */
        -: 1073:
        -: 1074:static void
function dired_dump_obstack called 0 returned 0% blocks executed 0%
    #####: 1075:dired_dump_obstack (char const *prefix, struct obstack *os)
        -: 1076:{
        -: 1077:  size_t n_pos;
        -: 1078:
    #####: 1079:  n_pos = obstack_object_size (os) / sizeof (dired_pos);
    #####: 1080:  if (n_pos > 0)
branch  0 never executed
branch  1 never executed
        -: 1081:    {
    #####: 1082:      off_t *pos = obstack_finish (os);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1083:      fputs (prefix, stdout);
call    0 never executed
    #####: 1084:      for (size_t i = 0; i < n_pos; i++)
branch  0 never executed
branch  1 never executed
        -: 1085:        {
    #####: 1086:          intmax_t p = pos[i];
    #####: 1087:          printf (" %"PRIdMAX, p);
call    0 never executed
        -: 1088:        }
    #####: 1089:      putchar ('\n');
call    0 never executed
        -: 1090:    }
    #####: 1091:}
        -: 1092:
        -: 1093:/* Return the platform birthtime member of the stat structure,
        -: 1094:   or fallback to the mtime member, which we have populated
        -: 1095:   from the statx structure or reset to an invalid timestamp
        -: 1096:   where birth time is not supported.  */
        -: 1097:static struct timespec
function get_stat_btime called 0 returned 0% blocks executed 0%
    #####: 1098:get_stat_btime (struct stat const *st)
        -: 1099:{
        -: 1100:  struct timespec btimespec;
        -: 1101:
        -: 1102:#if HAVE_STATX && defined STATX_INO
    #####: 1103:  btimespec = get_stat_mtime (st);
        -: 1104:#else
        -: 1105:  btimespec = get_stat_birthtime (st);
        -: 1106:#endif
        -: 1107:
    #####: 1108:  return btimespec;
        -: 1109:}
        -: 1110:
        -: 1111:#if HAVE_STATX && defined STATX_INO
        -: 1112:ATTRIBUTE_PURE
        -: 1113:static unsigned int
function time_type_to_statx called 0 returned 0% blocks executed 0%
    #####: 1114:time_type_to_statx (void)
        -: 1115:{
    #####: 1116:  switch (time_type)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 1117:    {
    #####: 1118:    case time_ctime:
    #####: 1119:      return STATX_CTIME;
    #####: 1120:    case time_mtime:
    #####: 1121:      return STATX_MTIME;
    #####: 1122:    case time_atime:
    #####: 1123:      return STATX_ATIME;
    #####: 1124:    case time_btime:
    #####: 1125:      return STATX_BTIME;
    #####: 1126:    default:
    #####: 1127:      unreachable ();
call    0 never executed
        -: 1128:    }
        -: 1129:    return 0;
        -: 1130:}
        -: 1131:
        -: 1132:ATTRIBUTE_PURE
        -: 1133:static unsigned int
function calc_req_mask called 2 returned 100% blocks executed 41%
        2: 1134:calc_req_mask (void)
        -: 1135:{
        2: 1136:  unsigned int mask = STATX_MODE;
        -: 1137:
        2: 1138:  if (print_inode)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1139:    mask |= STATX_INO;
        -: 1140:
        2: 1141:  if (print_block_size)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1142:    mask |= STATX_BLOCKS;
        -: 1143:
        2: 1144:  if (format == long_format) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1145:    mask |= STATX_NLINK | STATX_SIZE | time_type_to_statx ();
    #####: 1146:    if (print_owner || print_author)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1147:      mask |= STATX_UID;
    #####: 1148:    if (print_group)
branch  0 never executed
branch  1 never executed
    #####: 1149:      mask |= STATX_GID;
        -: 1150:  }
        -: 1151:
        2: 1152:  switch (sort_type)
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
        -: 1153:    {
        2: 1154:    case sort_none:
        -: 1155:    case sort_name:
        -: 1156:    case sort_version:
        -: 1157:    case sort_extension:
        -: 1158:    case sort_width:
        2: 1159:      break;
    #####: 1160:    case sort_time:
    #####: 1161:      mask |= time_type_to_statx ();
    #####: 1162:      break;
    #####: 1163:    case sort_size:
    #####: 1164:      mask |= STATX_SIZE;
    #####: 1165:      break;
    #####: 1166:    default:
    #####: 1167:      unreachable ();
call    0 never executed
        -: 1168:    }
        -: 1169:
        2: 1170:  return mask;
        -: 1171:}
        -: 1172:
        -: 1173:static int
function do_statx called 2 returned 100% blocks executed 44%
        2: 1174:do_statx (int fd, char const *name, struct stat *st, int flags,
        -: 1175:          unsigned int mask)
        -: 1176:{
        -: 1177:  struct statx stx;
        2: 1178:  bool want_btime = mask & STATX_BTIME;
        2: 1179:  int ret = statx (fd, name, flags | AT_NO_AUTOMOUNT, mask, &stx);
call    0 returned 100%
        2: 1180:  if (ret >= 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1181:    {
    #####: 1182:      statx_to_stat (&stx, st);
call    0 never executed
        -: 1183:      /* Since we only need one timestamp type,
        -: 1184:         store birth time in st_mtim.  */
    #####: 1185:      if (want_btime)
branch  0 never executed
branch  1 never executed
        -: 1186:        {
    #####: 1187:          if (stx.stx_mask & STATX_BTIME)
branch  0 never executed
branch  1 never executed
    #####: 1188:            st->st_mtim = statx_timestamp_to_timespec (stx.stx_btime);
call    0 never executed
        -: 1189:          else
    #####: 1190:            st->st_mtim.tv_sec = st->st_mtim.tv_nsec = -1;
        -: 1191:        }
        -: 1192:    }
        -: 1193:
        2: 1194:  return ret;
        -: 1195:}
        -: 1196:
        -: 1197:static int
function do_stat called 1 returned 100% blocks executed 100%
        1: 1198:do_stat (char const *name, struct stat *st)
        -: 1199:{
        1: 1200:  return do_statx (AT_FDCWD, name, st, 0, calc_req_mask ());
call    0 returned 100%
        -: 1201:}
        -: 1202:
        -: 1203:static int
function do_lstat called 1 returned 100% blocks executed 100%
        1: 1204:do_lstat (char const *name, struct stat *st)
        -: 1205:{
        1: 1206:  return do_statx (AT_FDCWD, name, st, AT_SYMLINK_NOFOLLOW, calc_req_mask ());
call    0 returned 100%
        -: 1207:}
        -: 1208:
        -: 1209:static int
function stat_for_mode called 0 returned 0% blocks executed 0%
    #####: 1210:stat_for_mode (char const *name, struct stat *st)
        -: 1211:{
    #####: 1212:  return do_statx (AT_FDCWD, name, st, 0, STATX_MODE);
call    0 never executed
        -: 1213:}
        -: 1214:
        -: 1215:/* dev+ino should be static, so no need to sync with backing store */
        -: 1216:static int
function stat_for_ino called 0 returned 0% blocks executed 0%
    #####: 1217:stat_for_ino (char const *name, struct stat *st)
        -: 1218:{
    #####: 1219:  return do_statx (AT_FDCWD, name, st, 0, STATX_INO);
call    0 never executed
        -: 1220:}
        -: 1221:
        -: 1222:static int
function fstat_for_ino called 0 returned 0% blocks executed 0%
    #####: 1223:fstat_for_ino (int fd, struct stat *st)
        -: 1224:{
    #####: 1225:  return do_statx (fd, "", st, AT_EMPTY_PATH, STATX_INO);
call    0 never executed
        -: 1226:}
        -: 1227:#else
        -: 1228:static int
        -: 1229:do_stat (char const *name, struct stat *st)
        -: 1230:{
        -: 1231:  return stat (name, st);
        -: 1232:}
        -: 1233:
        -: 1234:static int
        -: 1235:do_lstat (char const *name, struct stat *st)
        -: 1236:{
        -: 1237:  return lstat (name, st);
        -: 1238:}
        -: 1239:
        -: 1240:static int
        -: 1241:stat_for_mode (char const *name, struct stat *st)
        -: 1242:{
        -: 1243:  return stat (name, st);
        -: 1244:}
        -: 1245:
        -: 1246:static int
        -: 1247:stat_for_ino (char const *name, struct stat *st)
        -: 1248:{
        -: 1249:  return stat (name, st);
        -: 1250:}
        -: 1251:
        -: 1252:static int
        -: 1253:fstat_for_ino (int fd, struct stat *st)
        -: 1254:{
        -: 1255:  return fstat (fd, st);
        -: 1256:}
        -: 1257:#endif
        -: 1258:
        -: 1259:/* Return the address of the first plain %b spec in FMT, or nullptr if
        -: 1260:   there is no such spec.  %5b etc. do not match, so that user
        -: 1261:   widths/flags are honored.  */
        -: 1262:
        -: 1263:ATTRIBUTE_PURE
        -: 1264:static char const *
function first_percent_b called 0 returned 0% blocks executed 0%
    #####: 1265:first_percent_b (char const *fmt)
        -: 1266:{
    #####: 1267:  for (; *fmt; fmt++)
branch  0 never executed
branch  1 never executed
    #####: 1268:    if (fmt[0] == '%')
branch  0 never executed
branch  1 never executed
    #####: 1269:      switch (fmt[1])
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -: 1270:        {
    #####: 1271:        case 'b': return fmt;
    #####: 1272:        case '%': fmt++; break;
        -: 1273:        }
    #####: 1274:  return nullptr;
        -: 1275:}
        -: 1276:
        -: 1277:static char RFC3986[256];
        -: 1278:static void
function file_escape_init called 0 returned 0% blocks executed 0%
    #####: 1279:file_escape_init (void)
        -: 1280:{
    #####: 1281:  for (int i = 0; i < 256; i++)
branch  0 never executed
branch  1 never executed
    #####: 1282:    RFC3986[i] |= c_isalnum (i) || i == '~' || i == '-' || i == '.' || i == '_';
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
    #####: 1283:}
        -: 1284:
        -: 1285:/* Read the abbreviated month names from the locale, to align them
        -: 1286:   and to determine the max width of the field and to truncate names
        -: 1287:   greater than our max allowed.
        -: 1288:   Note even though this handles multibyte locales correctly
        -: 1289:   it's not restricted to them as single byte locales can have
        -: 1290:   variable width abbreviated months and also precomputing/caching
        -: 1291:   the names was seen to increase the performance of ls significantly.  */
        -: 1292:
        -: 1293:/* max number of display cells to use.
        -: 1294:   As of 2018 the abmon for Arabic has entries with width 12.
        -: 1295:   It doesn't make much sense to support wider than this
        -: 1296:   and locales should aim for abmon entries of width <= 5.  */
        -: 1297:enum { MAX_MON_WIDTH = 12 };
        -: 1298:/* abformat[RECENT][MON] is the format to use for timestamps with
        -: 1299:   recentness RECENT and month MON.  */
        -: 1300:enum { ABFORMAT_SIZE = 128 };
        -: 1301:static char abformat[2][12][ABFORMAT_SIZE];
        -: 1302:/* True if precomputed formats should be used.  This can be false if
        -: 1303:   nl_langinfo fails, if a format or month abbreviation is unusually
        -: 1304:   long, or if a month abbreviation contains '%'.  */
        -: 1305:static bool use_abformat;
        -: 1306:
        -: 1307:/* Store into ABMON the abbreviated month names, suitably aligned.
        -: 1308:   Return true if successful.  */
        -: 1309:
        -: 1310:static bool
function abmon_init called 0 returned 0% blocks executed 0%
    #####: 1311:abmon_init (char abmon[12][ABFORMAT_SIZE])
        -: 1312:{
        -: 1313:#ifndef HAVE_NL_LANGINFO
        -: 1314:  return false;
        -: 1315:#else
    #####: 1316:  size_t required_mon_width = MAX_MON_WIDTH;
        -: 1317:  size_t curr_max_width;
        -: 1318:  do
        -: 1319:    {
    #####: 1320:      curr_max_width = required_mon_width;
    #####: 1321:      required_mon_width = 0;
    #####: 1322:      for (int i = 0; i < 12; i++)
branch  0 never executed
branch  1 never executed
        -: 1323:        {
    #####: 1324:          size_t width = curr_max_width;
    #####: 1325:          char const *abbr = nl_langinfo (ABMON_1 + i);
call    0 never executed
    #####: 1326:          if (strchr (abbr, '%'))
branch  0 never executed
branch  1 never executed
    #####: 1327:            return false;
    #####: 1328:          mbs_align_t alignment = isdigit (to_uchar (*abbr))
call    0 never executed
    #####: 1329:                                  ? MBS_ALIGN_RIGHT : MBS_ALIGN_LEFT;
    #####: 1330:          size_t req = mbsalign (abbr, abmon[i], ABFORMAT_SIZE,
call    0 never executed
        -: 1331:                                 &width, alignment, 0);
    #####: 1332:          if (! (req < ABFORMAT_SIZE))
branch  0 never executed
branch  1 never executed
    #####: 1333:            return false;
    #####: 1334:          required_mon_width = MAX (required_mon_width, width);
        -: 1335:        }
        -: 1336:    }
    #####: 1337:  while (curr_max_width > required_mon_width);
branch  0 never executed
branch  1 never executed
        -: 1338:
    #####: 1339:  return true;
        -: 1340:#endif
        -: 1341:}
        -: 1342:
        -: 1343:/* Initialize ABFORMAT and USE_ABFORMAT.  */
        -: 1344:
        -: 1345:static void
function abformat_init called 0 returned 0% blocks executed 0%
    #####: 1346:abformat_init (void)
        -: 1347:{
        -: 1348:  char const *pb[2];
    #####: 1349:  for (int recent = 0; recent < 2; recent++)
branch  0 never executed
branch  1 never executed
    #####: 1350:    pb[recent] = first_percent_b (long_time_format[recent]);
    #####: 1351:  if (! (pb[0] || pb[1]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1352:    return;
        -: 1353:
        -: 1354:  char abmon[12][ABFORMAT_SIZE];
    #####: 1355:  if (! abmon_init (abmon))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1356:    return;
        -: 1357:
    #####: 1358:  for (int recent = 0; recent < 2; recent++)
branch  0 never executed
branch  1 never executed
        -: 1359:    {
    #####: 1360:      char const *fmt = long_time_format[recent];
    #####: 1361:      for (int i = 0; i < 12; i++)
branch  0 never executed
branch  1 never executed
        -: 1362:        {
    #####: 1363:          char *nfmt = abformat[recent][i];
        -: 1364:          int nbytes;
        -: 1365:
    #####: 1366:          if (! pb[recent])
branch  0 never executed
branch  1 never executed
    #####: 1367:            nbytes = snprintf (nfmt, ABFORMAT_SIZE, "%s", fmt);
        -: 1368:          else
        -: 1369:            {
    #####: 1370:              if (! (pb[recent] - fmt <= MIN (ABFORMAT_SIZE, INT_MAX)))
branch  0 never executed
branch  1 never executed
    #####: 1371:                return;
    #####: 1372:              int prefix_len = pb[recent] - fmt;
    #####: 1373:              nbytes = snprintf (nfmt, ABFORMAT_SIZE, "%.*s%s%s",
    #####: 1374:                                 prefix_len, fmt, abmon[i], pb[recent] + 2);
        -: 1375:            }
        -: 1376:
    #####: 1377:          if (! (0 <= nbytes && nbytes < ABFORMAT_SIZE))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1378:            return;
        -: 1379:        }
        -: 1380:    }
        -: 1381:
    #####: 1382:  use_abformat = true;
        -: 1383:}
        -: 1384:
        -: 1385:static size_t
function dev_ino_hash called 0 returned 0% blocks executed 0%
    #####: 1386:dev_ino_hash (void const *x, size_t table_size)
        -: 1387:{
    #####: 1388:  struct dev_ino const *p = x;
    #####: 1389:  return (uintmax_t) p->st_ino % table_size;
        -: 1390:}
        -: 1391:
        -: 1392:static bool
function dev_ino_compare called 0 returned 0% blocks executed 0%
    #####: 1393:dev_ino_compare (void const *x, void const *y)
        -: 1394:{
    #####: 1395:  struct dev_ino const *a = x;
    #####: 1396:  struct dev_ino const *b = y;
    #####: 1397:  return SAME_INODE (*a, *b) ? true : false;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1398:}
        -: 1399:
        -: 1400:static void
function dev_ino_free called 0 returned 0% blocks executed 0%
    #####: 1401:dev_ino_free (void *x)
        -: 1402:{
    #####: 1403:  free (x);
    #####: 1404:}
        -: 1405:
        -: 1406:/* Add the device/inode pair (P->st_dev/P->st_ino) to the set of
        -: 1407:   active directories.  Return true if there is already a matching
        -: 1408:   entry in the table.  */
        -: 1409:
        -: 1410:static bool
function visit_dir called 0 returned 0% blocks executed 0%
    #####: 1411:visit_dir (dev_t dev, ino_t ino)
        -: 1412:{
        -: 1413:  struct dev_ino *ent;
        -: 1414:  struct dev_ino *ent_from_table;
        -: 1415:  bool found_match;
        -: 1416:
    #####: 1417:  ent = xmalloc (sizeof *ent);
call    0 never executed
    #####: 1418:  ent->st_ino = ino;
    #####: 1419:  ent->st_dev = dev;
        -: 1420:
        -: 1421:  /* Attempt to insert this entry into the table.  */
    #####: 1422:  ent_from_table = hash_insert (active_dir_set, ent);
call    0 never executed
        -: 1423:
    #####: 1424:  if (ent_from_table == nullptr)
branch  0 never executed
branch  1 never executed
        -: 1425:    {
        -: 1426:      /* Insertion failed due to lack of memory.  */
    #####: 1427:      xalloc_die ();
call    0 never executed
        -: 1428:    }
        -: 1429:
    #####: 1430:  found_match = (ent_from_table != ent);
        -: 1431:
    #####: 1432:  if (found_match)
branch  0 never executed
branch  1 never executed
        -: 1433:    {
        -: 1434:      /* ent was not inserted, so free it.  */
    #####: 1435:      free (ent);
        -: 1436:    }
        -: 1437:
    #####: 1438:  return found_match;
        -: 1439:}
        -: 1440:
        -: 1441:static void
function free_pending_ent called 0 returned 0% blocks executed 0%
    #####: 1442:free_pending_ent (struct pending *p)
        -: 1443:{
    #####: 1444:  free (p->name);
    #####: 1445:  free (p->realname);
    #####: 1446:  free (p);
    #####: 1447:}
        -: 1448:
        -: 1449:static bool
function is_colored called 0 returned 0% blocks executed 0%
    #####: 1450:is_colored (enum indicator_no type)
        -: 1451:{
    #####: 1452:  size_t len = color_indicator[type].len;
    #####: 1453:  char const *s = color_indicator[type].string;
    #####: 1454:  return ! (len == 0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1455:            || (len == 1 && STRNCMP_LIT (s, "0") == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1456:            || (len == 2 && STRNCMP_LIT (s, "00") == 0));
branch  0 never executed
branch  1 never executed
        -: 1457:}
        -: 1458:
        -: 1459:static void
function restore_default_color called 0 returned 0% blocks executed 0%
    #####: 1460:restore_default_color (void)
        -: 1461:{
    #####: 1462:  put_indicator (&color_indicator[C_LEFT]);
call    0 never executed
    #####: 1463:  put_indicator (&color_indicator[C_RIGHT]);
call    0 never executed
    #####: 1464:}
        -: 1465:
        -: 1466:static void
function set_normal_color called 0 returned 0% blocks executed 0%
    #####: 1467:set_normal_color (void)
        -: 1468:{
    #####: 1469:  if (print_with_color && is_colored (C_NORM))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1470:    {
    #####: 1471:      put_indicator (&color_indicator[C_LEFT]);
call    0 never executed
    #####: 1472:      put_indicator (&color_indicator[C_NORM]);
call    0 never executed
    #####: 1473:      put_indicator (&color_indicator[C_RIGHT]);
call    0 never executed
        -: 1474:    }
    #####: 1475:}
        -: 1476:
        -: 1477:/* An ordinary signal was received; arrange for the program to exit.  */
        -: 1478:
        -: 1479:static void
function sighandler called 0 returned 0% blocks executed 0%
    #####: 1480:sighandler (int sig)
        -: 1481:{
        -: 1482:  if (! SA_NOCLDSTOP)
        -: 1483:    signal (sig, SIG_IGN);
    #####: 1484:  if (! interrupt_signal)
branch  0 never executed
branch  1 never executed
    #####: 1485:    interrupt_signal = sig;
    #####: 1486:}
        -: 1487:
        -: 1488:/* A SIGTSTP was received; arrange for the program to suspend itself.  */
        -: 1489:
        -: 1490:static void
function stophandler called 0 returned 0% blocks executed 0%
    #####: 1491:stophandler (int sig)
        -: 1492:{
        -: 1493:  if (! SA_NOCLDSTOP)
        -: 1494:    signal (sig, stophandler);
    #####: 1495:  if (! interrupt_signal)
branch  0 never executed
branch  1 never executed
    #####: 1496:    stop_signal_count++;
    #####: 1497:}
        -: 1498:
        -: 1499:/* Process any pending signals.  If signals are caught, this function
        -: 1500:   should be called periodically.  Ideally there should never be an
        -: 1501:   unbounded amount of time when signals are not being processed.
        -: 1502:   Signal handling can restore the default colors, so callers must
        -: 1503:   immediately change colors after invoking this function.  */
        -: 1504:
        -: 1505:static void
function process_signals called 0 returned 0% blocks executed 0%
    #####: 1506:process_signals (void)
        -: 1507:{
    #####: 1508:  while (interrupt_signal || stop_signal_count)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1509:    {
        -: 1510:      int sig;
        -: 1511:      int stops;
        -: 1512:      sigset_t oldset;
        -: 1513:
    #####: 1514:      if (used_color)
branch  0 never executed
branch  1 never executed
    #####: 1515:        restore_default_color ();
call    0 never executed
    #####: 1516:      fflush (stdout);
call    0 never executed
        -: 1517:
    #####: 1518:      sigprocmask (SIG_BLOCK, &caught_signals, &oldset);
call    0 never executed
        -: 1519:
        -: 1520:      /* Reload interrupt_signal and stop_signal_count, in case a new
        -: 1521:         signal was handled before sigprocmask took effect.  */
    #####: 1522:      sig = interrupt_signal;
    #####: 1523:      stops = stop_signal_count;
        -: 1524:
        -: 1525:      /* SIGTSTP is special, since the application can receive that signal
        -: 1526:         more than once.  In this case, don't set the signal handler to the
        -: 1527:         default.  Instead, just raise the uncatchable SIGSTOP.  */
    #####: 1528:      if (stops)
branch  0 never executed
branch  1 never executed
        -: 1529:        {
    #####: 1530:          stop_signal_count = stops - 1;
    #####: 1531:          sig = SIGSTOP;
        -: 1532:        }
        -: 1533:      else
    #####: 1534:        signal (sig, SIG_DFL);
call    0 never executed
        -: 1535:
        -: 1536:      /* Exit or suspend the program.  */
    #####: 1537:      raise (sig);
call    0 never executed
    #####: 1538:      sigprocmask (SIG_SETMASK, &oldset, nullptr);
call    0 never executed
        -: 1539:
        -: 1540:      /* If execution reaches here, then the program has been
        -: 1541:         continued (after being suspended).  */
        -: 1542:    }
    #####: 1543:}
        -: 1544:
        -: 1545:/* Setup signal handlers if INIT is true,
        -: 1546:   otherwise restore to the default.  */
        -: 1547:
        -: 1548:static void
function signal_setup called 0 returned 0% blocks executed 0%
    #####: 1549:signal_setup (bool init)
        -: 1550:{
        -: 1551:  /* The signals that are trapped, and the number of such signals.  */
        -: 1552:  static int const sig[] =
        -: 1553:    {
        -: 1554:      /* This one is handled specially.  */
        -: 1555:      SIGTSTP,
        -: 1556:
        -: 1557:      /* The usual suspects.  */
        -: 1558:      SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM,
        -: 1559:#ifdef SIGPOLL
        -: 1560:      SIGPOLL,
        -: 1561:#endif
        -: 1562:#ifdef SIGPROF
        -: 1563:      SIGPROF,
        -: 1564:#endif
        -: 1565:#ifdef SIGVTALRM
        -: 1566:      SIGVTALRM,
        -: 1567:#endif
        -: 1568:#ifdef SIGXCPU
        -: 1569:      SIGXCPU,
        -: 1570:#endif
        -: 1571:#ifdef SIGXFSZ
        -: 1572:      SIGXFSZ,
        -: 1573:#endif
        -: 1574:    };
        -: 1575:  enum { nsigs = ARRAY_CARDINALITY (sig) };
        -: 1576:
        -: 1577:#if ! SA_NOCLDSTOP
        -: 1578:  static bool caught_sig[nsigs];
        -: 1579:#endif
        -: 1580:
        -: 1581:  int j;
        -: 1582:
    #####: 1583:  if (init)
branch  0 never executed
branch  1 never executed
        -: 1584:    {
        -: 1585:#if SA_NOCLDSTOP
        -: 1586:      struct sigaction act;
        -: 1587:
    #####: 1588:      sigemptyset (&caught_signals);
call    0 never executed
    #####: 1589:      for (j = 0; j < nsigs; j++)
branch  0 never executed
branch  1 never executed
        -: 1590:        {
    #####: 1591:          sigaction (sig[j], nullptr, &act);
call    0 never executed
    #####: 1592:          if (act.sa_handler != SIG_IGN)
branch  0 never executed
branch  1 never executed
    #####: 1593:            sigaddset (&caught_signals, sig[j]);
call    0 never executed
        -: 1594:        }
        -: 1595:
    #####: 1596:      act.sa_mask = caught_signals;
    #####: 1597:      act.sa_flags = SA_RESTART;
        -: 1598:
    #####: 1599:      for (j = 0; j < nsigs; j++)
branch  0 never executed
branch  1 never executed
    #####: 1600:        if (sigismember (&caught_signals, sig[j]))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1601:          {
    #####: 1602:            act.sa_handler = sig[j] == SIGTSTP ? stophandler : sighandler;
branch  0 never executed
branch  1 never executed
    #####: 1603:            sigaction (sig[j], &act, nullptr);
call    0 never executed
        -: 1604:          }
        -: 1605:#else
        -: 1606:      for (j = 0; j < nsigs; j++)
        -: 1607:        {
        -: 1608:          caught_sig[j] = (signal (sig[j], SIG_IGN) != SIG_IGN);
        -: 1609:          if (caught_sig[j])
        -: 1610:            {
        -: 1611:              signal (sig[j], sig[j] == SIGTSTP ? stophandler : sighandler);
        -: 1612:              siginterrupt (sig[j], 0);
        -: 1613:            }
        -: 1614:        }
        -: 1615:#endif
        -: 1616:    }
        -: 1617:  else /* restore.  */
        -: 1618:    {
        -: 1619:#if SA_NOCLDSTOP
    #####: 1620:      for (j = 0; j < nsigs; j++)
branch  0 never executed
branch  1 never executed
    #####: 1621:        if (sigismember (&caught_signals, sig[j]))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1622:          signal (sig[j], SIG_DFL);
call    0 never executed
        -: 1623:#else
        -: 1624:      for (j = 0; j < nsigs; j++)
        -: 1625:        if (caught_sig[j])
        -: 1626:          signal (sig[j], SIG_DFL);
        -: 1627:#endif
        -: 1628:    }
    #####: 1629:}
        -: 1630:
        -: 1631:static void
function signal_init called 0 returned 0% blocks executed 0%
    #####: 1632:signal_init (void)
        -: 1633:{
    #####: 1634:  signal_setup (true);
call    0 never executed
    #####: 1635:}
        -: 1636:
        -: 1637:static void
function signal_restore called 0 returned 0% blocks executed 0%
    #####: 1638:signal_restore (void)
        -: 1639:{
    #####: 1640:  signal_setup (false);
call    0 never executed
    #####: 1641:}
        -: 1642:
        -: 1643:int
function main called 2 returned 50% blocks executed 41%
        2: 1644:main (int argc, char **argv)
        -: 1645:{
        -: 1646:  int i;
        -: 1647:  struct pending *thispend;
        -: 1648:  int n_files;
        -: 1649:
        -: 1650:  initialize_main (&argc, &argv);
        2: 1651:  set_program_name (argv[0]);
call    0 returned 100%
        2: 1652:  setlocale (LC_ALL, "");
call    0 returned 100%
        -: 1653:  bindtextdomain (PACKAGE, LOCALEDIR);
        -: 1654:  textdomain (PACKAGE);
        -: 1655:
        2: 1656:  initialize_exit_failure (LS_FAILURE);
call    0 returned 100%
        2: 1657:  atexit (close_stdout);
call    0 returned 100%
        -: 1658:
        -: 1659:  static_assert (ARRAY_CARDINALITY (color_indicator) + 1
        -: 1660:                 == ARRAY_CARDINALITY (indicator_name));
        -: 1661:
        2: 1662:  exit_status = EXIT_SUCCESS;
        2: 1663:  print_dir_name = true;
        2: 1664:  pending_dirs = nullptr;
        -: 1665:
        2: 1666:  current_time.tv_sec = TYPE_MINIMUM (time_t);
        2: 1667:  current_time.tv_nsec = -1;
        -: 1668:
        2: 1669:  i = decode_switches (argc, argv);
call    0 returned 50%
        -: 1670:
        1: 1671:  if (print_with_color)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1672:    parse_ls_color ();
call    0 never executed
        -: 1673:
        -: 1674:  /* Test print_with_color again, because the call to parse_ls_color
        -: 1675:     may have just reset it -- e.g., if LS_COLORS is invalid.  */
        -: 1676:
        1: 1677:  if (print_with_color)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1678:    {
        -: 1679:      /* Don't use TAB characters in output.  Some terminal
        -: 1680:         emulators can't handle the combination of tabs and
        -: 1681:         color codes on the same line.  */
    #####: 1682:      tabsize = 0;
        -: 1683:    }
        -: 1684:
        1: 1685:  if (directories_first)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1686:    check_symlink_mode = true;
        1: 1687:  else if (print_with_color)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1688:    {
        -: 1689:      /* Avoid following symbolic links when possible.  */
    #####: 1690:      if (is_colored (C_ORPHAN)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1691:          || (is_colored (C_EXEC) && color_symlink_as_referent)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1692:          || (is_colored (C_MISSING) && format == long_format))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1693:        check_symlink_mode = true;
        -: 1694:    }
        -: 1695:
        1: 1696:  if (dereference == DEREF_UNDEFINED)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 1697:    dereference = ((immediate_dirs
        1: 1698:                    || indicator_style == classify
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 1699:                    || format == long_format)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1700:                   ? DEREF_NEVER
       2*: 1701:                   : DEREF_COMMAND_LINE_SYMLINK_TO_DIR);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1702:
        -: 1703:  /* When using -R, initialize a data structure we'll use to
        -: 1704:     detect any directory cycles.  */
        1: 1705:  if (recursive)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1706:    {
    #####: 1707:      active_dir_set = hash_initialize (INITIAL_TABLE_SIZE, nullptr,
call    0 never executed
        -: 1708:                                        dev_ino_hash,
        -: 1709:                                        dev_ino_compare,
        -: 1710:                                        dev_ino_free);
    #####: 1711:      if (active_dir_set == nullptr)
branch  0 never executed
branch  1 never executed
    #####: 1712:        xalloc_die ();
call    0 never executed
        -: 1713:
    #####: 1714:      obstack_init (&dev_ino_obstack);
call    0 never executed
        -: 1715:    }
        -: 1716:
        1: 1717:  localtz = tzalloc (getenv ("TZ"));
call    0 returned 100%
call    1 returned 100%
        -: 1718:
        1: 1719:  format_needs_stat = sort_type == sort_time || sort_type == sort_size
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 1720:    || format == long_format
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 1721:    || print_scontext
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       2*: 1722:    || print_block_size;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        2: 1723:  format_needs_type = (! format_needs_stat
       2*: 1724:                       && (recursive
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1: 1725:                           || print_with_color
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 1726:                           || indicator_style != none
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 1727:                           || directories_first));
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1728:
        1: 1729:  if (dired)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1730:    {
    #####: 1731:      obstack_init (&dired_obstack);
call    0 never executed
    #####: 1732:      obstack_init (&subdired_obstack);
call    0 never executed
        -: 1733:    }
        -: 1734:
        1: 1735:  if (print_hyperlink)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1736:    {
    #####: 1737:      file_escape_init ();
call    0 never executed
        -: 1738:
    #####: 1739:      hostname = xgethostname ();
call    0 never executed
        -: 1740:      /* The hostname is generally ignored,
        -: 1741:         so ignore failures obtaining it.  */
    #####: 1742:      if (! hostname)
branch  0 never executed
branch  1 never executed
    #####: 1743:        hostname = "";
        -: 1744:    }
        -: 1745:
        1: 1746:  cwd_n_alloc = 100;
        1: 1747:  cwd_file = xnmalloc (cwd_n_alloc, sizeof *cwd_file);
call    0 returned 100%
        1: 1748:  cwd_n_used = 0;
        -: 1749:
        1: 1750:  clear_files ();
call    0 returned 100%
        -: 1751:
        1: 1752:  n_files = argc - i;
        -: 1753:
        1: 1754:  if (n_files <= 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1755:    {
    #####: 1756:      if (immediate_dirs)
branch  0 never executed
branch  1 never executed
    #####: 1757:        gobble_file (".", directory, NOT_AN_INODE_NUMBER, true, "");
call    0 never executed
        -: 1758:      else
    #####: 1759:        queue_directory (".", nullptr, true);
call    0 never executed
        -: 1760:    }
        -: 1761:  else
        -: 1762:    do
        1: 1763:      gobble_file (argv[i++], unknown, NOT_AN_INODE_NUMBER, true, "");
call    0 returned 100%
        1: 1764:    while (i < argc);
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
        -: 1765:
        1: 1766:  if (cwd_n_used)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1767:    {
    #####: 1768:      sort_files ();
call    0 never executed
    #####: 1769:      if (!immediate_dirs)
branch  0 never executed
branch  1 never executed
    #####: 1770:        extract_dirs_from_files (nullptr, true);
call    0 never executed
        -: 1771:      /* 'cwd_n_used' might be zero now.  */
        -: 1772:    }
        -: 1773:
        -: 1774:  /* In the following if/else blocks, it is sufficient to test 'pending_dirs'
        -: 1775:     (and not pending_dirs->name) because there may be no markers in the queue
        -: 1776:     at this point.  A marker may be enqueued when extract_dirs_from_files is
        -: 1777:     called with a non-empty string or via print_dir.  */
        1: 1778:  if (cwd_n_used)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1779:    {
    #####: 1780:      print_current_files ();
call    0 never executed
    #####: 1781:      if (pending_dirs)
branch  0 never executed
branch  1 never executed
    #####: 1782:        dired_outbyte ('\n');
call    0 never executed
        -: 1783:    }
       1*: 1784:  else if (n_files <= 1 && pending_dirs && pending_dirs->next == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 never executed
branch  5 never executed
    #####: 1785:    print_dir_name = false;
        -: 1786:
        1: 1787:  while (pending_dirs)
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
        -: 1788:    {
    #####: 1789:      thispend = pending_dirs;
    #####: 1790:      pending_dirs = pending_dirs->next;
        -: 1791:
    #####: 1792:      if (LOOP_DETECT)
branch  0 never executed
branch  1 never executed
        -: 1793:        {
    #####: 1794:          if (thispend->name == nullptr)
branch  0 never executed
branch  1 never executed
    #####: 1795:            {
        -: 1796:              /* thispend->name == nullptr means this is a marker entry
        -: 1797:                 indicating we've finished processing the directory.
        -: 1798:                 Use its dev/ino numbers to remove the corresponding
        -: 1799:                 entry from the active_dir_set hash table.  */
    #####: 1800:              struct dev_ino di = dev_ino_pop ();
call    0 never executed
    #####: 1801:              struct dev_ino *found = hash_remove (active_dir_set, &di);
call    0 never executed
        -: 1802:              if (false)
        -: 1803:                assert_matching_dev_ino (thispend->realname, di);
    #####: 1804:              affirm (found);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1805:              dev_ino_free (found);
call    0 never executed
    #####: 1806:              free_pending_ent (thispend);
call    0 never executed
    #####: 1807:              continue;
        -: 1808:            }
        -: 1809:        }
        -: 1810:
    #####: 1811:      print_dir (thispend->name, thispend->realname,
    #####: 1812:                 thispend->command_line_arg);
call    0 never executed
        -: 1813:
    #####: 1814:      free_pending_ent (thispend);
call    0 never executed
    #####: 1815:      print_dir_name = true;
        -: 1816:    }
        -: 1817:
       1*: 1818:  if (print_with_color && used_color)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        -: 1819:    {
        -: 1820:      int j;
        -: 1821:
        -: 1822:      /* Skip the restore when it would be a no-op, i.e.,
        -: 1823:         when left is "\033[" and right is "m".  */
    #####: 1824:      if (!(color_indicator[C_LEFT].len == 2
branch  0 never executed
branch  1 never executed
    #####: 1825:            && memcmp (color_indicator[C_LEFT].string, "\033[", 2) == 0
branch  0 never executed
branch  1 never executed
    #####: 1826:            && color_indicator[C_RIGHT].len == 1
branch  0 never executed
branch  1 never executed
    #####: 1827:            && color_indicator[C_RIGHT].string[0] == 'm'))
branch  0 never executed
branch  1 never executed
    #####: 1828:        restore_default_color ();
call    0 never executed
        -: 1829:
    #####: 1830:      fflush (stdout);
call    0 never executed
        -: 1831:
    #####: 1832:      signal_restore ();
call    0 never executed
        -: 1833:
        -: 1834:      /* Act on any signals that arrived before the default was restored.
        -: 1835:         This can process signals out of order, but there doesn't seem to
        -: 1836:         be an easy way to do them in order, and the order isn't that
        -: 1837:         important anyway.  */
    #####: 1838:      for (j = stop_signal_count; j; j--)
branch  0 never executed
branch  1 never executed
    #####: 1839:        raise (SIGSTOP);
call    0 never executed
    #####: 1840:      j = interrupt_signal;
    #####: 1841:      if (j)
branch  0 never executed
branch  1 never executed
    #####: 1842:        raise (j);
call    0 never executed
        -: 1843:    }
        -: 1844:
        1: 1845:  if (dired)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1846:    {
        -: 1847:      /* No need to free these since we're about to exit.  */
    #####: 1848:      dired_dump_obstack ("//DIRED//", &dired_obstack);
call    0 never executed
    #####: 1849:      dired_dump_obstack ("//SUBDIRED//", &subdired_obstack);
call    0 never executed
    #####: 1850:      printf ("//DIRED-OPTIONS// --quoting-style=%s\n",
    #####: 1851:              quoting_style_args[get_quoting_style (filename_quoting_options)]);
call    0 never executed
call    1 never executed
        -: 1852:    }
        -: 1853:
        1: 1854:  if (LOOP_DETECT)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1855:    {
    #####: 1856:      assure (hash_get_n_entries (active_dir_set) == 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1857:      hash_free (active_dir_set);
call    0 never executed
        -: 1858:    }
        -: 1859:
        1: 1860:  return exit_status;
        -: 1861:}
        -: 1862:
        -: 1863:/* Return the line length indicated by the value given by SPEC, or -1
        -: 1864:   if unsuccessful.  0 means no limit on line length.  */
        -: 1865:
        -: 1866:static ptrdiff_t
function decode_line_length called 0 returned 0% blocks executed 0%
    #####: 1867:decode_line_length (char const *spec)
        -: 1868:{
        -: 1869:  uintmax_t val;
        -: 1870:
        -: 1871:  /* Treat too-large values as if they were 0, which is
        -: 1872:     effectively infinity.  */
    #####: 1873:  switch (xstrtoumax (spec, nullptr, 0, &val, ""))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1874:    {
    #####: 1875:    case LONGINT_OK:
    #####: 1876:      return val <= MIN (PTRDIFF_MAX, SIZE_MAX) ? val : 0;
        -: 1877:
    #####: 1878:    case LONGINT_OVERFLOW:
    #####: 1879:      return 0;
        -: 1880:
    #####: 1881:    default:
    #####: 1882:      return -1;
        -: 1883:    }
        -: 1884:}
        -: 1885:
        -: 1886:/* Return true if standard output is a tty, caching the result.  */
        -: 1887:
        -: 1888:static bool
function stdout_isatty called 4 returned 100% blocks executed 88%
        4: 1889:stdout_isatty (void)
        -: 1890:{
        -: 1891:  static signed char out_tty = -1;
        4: 1892:  if (out_tty < 0)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        1: 1893:    out_tty = isatty (STDOUT_FILENO);
call    0 returned 100%
       4*: 1894:  assume (out_tty == 0 || out_tty == 1);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        4: 1895:  return out_tty;
        -: 1896:}
        -: 1897:
        -: 1898:/* Set all the option flags according to the switches specified.
        -: 1899:   Return the index of the first non-option argument.  */
        -: 1900:
        -: 1901:static int
function decode_switches called 2 returned 50% blocks executed 26%
        2: 1902:decode_switches (int argc, char **argv)
        -: 1903:{
        2: 1904:  char *time_style_option = nullptr;
        -: 1905:
        -: 1906:  /* These variables are false or -1 unless a switch says otherwise.  */
        2: 1907:  bool kibibytes_specified = false;
        2: 1908:  int format_opt = -1;
        2: 1909:  int hide_control_chars_opt = -1;
        2: 1910:  int quoting_style_opt = -1;
        2: 1911:  int sort_opt = -1;
        2: 1912:  ptrdiff_t tabsize_opt = -1;
        2: 1913:  ptrdiff_t width_opt = -1;
        -: 1914:
        -: 1915:  while (true)
    #####: 1916:    {
        2: 1917:      int oi = -1;
        2: 1918:      int c = getopt_long (argc, argv,
call    0 returned 100%
        -: 1919:                           "abcdfghiklmnopqrstuvw:xABCDFGHI:LNQRST:UXZ1",
        -: 1920:                           long_options, &oi);
        2: 1921:      if (c == -1)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        1: 1922:        break;
        -: 1923:
        1: 1924:      switch (c)
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 0%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 0%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 0%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
branch 21 taken 0%
branch 22 taken 0%
branch 23 taken 0%
branch 24 taken 0%
branch 25 taken 0%
branch 26 taken 0%
branch 27 taken 0%
branch 28 taken 0%
branch 29 taken 0%
branch 30 taken 0%
branch 31 taken 0%
branch 32 taken 0%
branch 33 taken 0%
branch 34 taken 0%
branch 35 taken 0%
branch 36 taken 0%
branch 37 taken 0%
branch 38 taken 0%
branch 39 taken 0%
branch 40 taken 0%
branch 41 taken 0%
branch 42 taken 0%
branch 43 taken 0%
branch 44 taken 0%
branch 45 taken 0%
branch 46 taken 0%
branch 47 taken 0%
branch 48 taken 0%
branch 49 taken 0%
branch 50 taken 0%
branch 51 taken 0%
branch 52 taken 0%
branch 53 taken 0%
branch 54 taken 0%
branch 55 taken 0%
branch 56 taken 0%
branch 57 taken 0%
branch 58 taken 0%
branch 59 taken 0%
branch 60 taken 100%
        -: 1925:        {
    #####: 1926:        case 'a':
    #####: 1927:          ignore_mode = IGNORE_MINIMAL;
    #####: 1928:          break;
        -: 1929:
    #####: 1930:        case 'b':
    #####: 1931:          quoting_style_opt = escape_quoting_style;
    #####: 1932:          break;
        -: 1933:
    #####: 1934:        case 'c':
    #####: 1935:          time_type = time_ctime;
    #####: 1936:          break;
        -: 1937:
    #####: 1938:        case 'd':
    #####: 1939:          immediate_dirs = true;
    #####: 1940:          break;
        -: 1941:
    #####: 1942:        case 'f':
        -: 1943:          /* Same as -a -U -1 --color=none --hyperlink=none,
        -: 1944:             while disabling -s.  */
    #####: 1945:          ignore_mode = IGNORE_MINIMAL;
    #####: 1946:          sort_opt = sort_none;
    #####: 1947:          if (format_opt == long_format)
branch  0 never executed
branch  1 never executed
    #####: 1948:            format_opt = -1;
    #####: 1949:          print_with_color = false;
    #####: 1950:          print_hyperlink = false;
    #####: 1951:          print_block_size = false;
    #####: 1952:          break;
        -: 1953:
    #####: 1954:        case FILE_TYPE_INDICATOR_OPTION: /* --file-type */
    #####: 1955:          indicator_style = file_type;
    #####: 1956:          break;
        -: 1957:
    #####: 1958:        case 'g':
    #####: 1959:          format_opt = long_format;
    #####: 1960:          print_owner = false;
    #####: 1961:          break;
        -: 1962:
    #####: 1963:        case 'h':
    #####: 1964:          file_human_output_opts = human_output_opts =
        -: 1965:            human_autoscale | human_SI | human_base_1024;
    #####: 1966:          file_output_block_size = output_block_size = 1;
    #####: 1967:          break;
        -: 1968:
    #####: 1969:        case 'i':
    #####: 1970:          print_inode = true;
    #####: 1971:          break;
        -: 1972:
    #####: 1973:        case 'k':
    #####: 1974:          kibibytes_specified = true;
    #####: 1975:          break;
        -: 1976:
    #####: 1977:        case 'l':
    #####: 1978:          format_opt = long_format;
    #####: 1979:          break;
        -: 1980:
    #####: 1981:        case 'm':
    #####: 1982:          format_opt = with_commas;
    #####: 1983:          break;
        -: 1984:
    #####: 1985:        case 'n':
    #####: 1986:          numeric_ids = true;
    #####: 1987:          format_opt = long_format;
    #####: 1988:          break;
        -: 1989:
    #####: 1990:        case 'o':  /* Just like -l, but don't display group info.  */
    #####: 1991:          format_opt = long_format;
    #####: 1992:          print_group = false;
    #####: 1993:          break;
        -: 1994:
    #####: 1995:        case 'p':
    #####: 1996:          indicator_style = slash;
    #####: 1997:          break;
        -: 1998:
    #####: 1999:        case 'q':
    #####: 2000:          hide_control_chars_opt = true;
    #####: 2001:          break;
        -: 2002:
    #####: 2003:        case 'r':
    #####: 2004:          sort_reverse = true;
    #####: 2005:          break;
        -: 2006:
    #####: 2007:        case 's':
    #####: 2008:          print_block_size = true;
    #####: 2009:          break;
        -: 2010:
    #####: 2011:        case 't':
    #####: 2012:          sort_opt = sort_time;
    #####: 2013:          break;
        -: 2014:
    #####: 2015:        case 'u':
    #####: 2016:          time_type = time_atime;
    #####: 2017:          break;
        -: 2018:
    #####: 2019:        case 'v':
    #####: 2020:          sort_opt = sort_version;
    #####: 2021:          break;
        -: 2022:
    #####: 2023:        case 'w':
    #####: 2024:          width_opt = decode_line_length (optarg);
call    0 never executed
    #####: 2025:          if (width_opt < 0)
branch  0 never executed
branch  1 never executed
    #####: 2026:            error (LS_FAILURE, 0, "%s: %s", _("invalid line width"),
call    0 never executed
call    1 never executed
        -: 2027:                   quote (optarg));
    #####: 2028:          break;
        -: 2029:
    #####: 2030:        case 'x':
    #####: 2031:          format_opt = horizontal;
    #####: 2032:          break;
        -: 2033:
    #####: 2034:        case 'A':
    #####: 2035:          ignore_mode = IGNORE_DOT_AND_DOTDOT;
    #####: 2036:          break;
        -: 2037:
    #####: 2038:        case 'B':
    #####: 2039:          add_ignore_pattern ("*~");
call    0 never executed
    #####: 2040:          add_ignore_pattern (".*~");
call    0 never executed
    #####: 2041:          break;
        -: 2042:
    #####: 2043:        case 'C':
    #####: 2044:          format_opt = many_per_line;
    #####: 2045:          break;
        -: 2046:
    #####: 2047:        case 'D':
    #####: 2048:          dired = true;
    #####: 2049:          break;
        -: 2050:
    #####: 2051:        case 'F':
        -: 2052:          {
        -: 2053:            int i;
    #####: 2054:            if (optarg)
branch  0 never executed
branch  1 never executed
    #####: 2055:              i = XARGMATCH ("--classify", optarg, when_args, when_types);
call    0 never executed
        -: 2056:            else
        -: 2057:              /* Using --classify with no argument is equivalent to using
        -: 2058:                 --classify=always.  */
    #####: 2059:              i = when_always;
        -: 2060:
    #####: 2061:            if (i == when_always || (i == when_if_tty && stdout_isatty ()))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####: 2062:              indicator_style = classify;
    #####: 2063:            break;
        -: 2064:          }
        -: 2065:
    #####: 2066:        case 'G':		/* inhibit display of group info */
    #####: 2067:          print_group = false;
    #####: 2068:          break;
        -: 2069:
    #####: 2070:        case 'H':
    #####: 2071:          dereference = DEREF_COMMAND_LINE_ARGUMENTS;
    #####: 2072:          break;
        -: 2073:
    #####: 2074:        case DEREFERENCE_COMMAND_LINE_SYMLINK_TO_DIR_OPTION:
    #####: 2075:          dereference = DEREF_COMMAND_LINE_SYMLINK_TO_DIR;
    #####: 2076:          break;
        -: 2077:
    #####: 2078:        case 'I':
    #####: 2079:          add_ignore_pattern (optarg);
call    0 never executed
    #####: 2080:          break;
        -: 2081:
    #####: 2082:        case 'L':
    #####: 2083:          dereference = DEREF_ALWAYS;
    #####: 2084:          break;
        -: 2085:
    #####: 2086:        case 'N':
    #####: 2087:          quoting_style_opt = literal_quoting_style;
    #####: 2088:          break;
        -: 2089:
    #####: 2090:        case 'Q':
    #####: 2091:          quoting_style_opt = c_quoting_style;
    #####: 2092:          break;
        -: 2093:
    #####: 2094:        case 'R':
    #####: 2095:          recursive = true;
    #####: 2096:          break;
        -: 2097:
    #####: 2098:        case 'S':
    #####: 2099:          sort_opt = sort_size;
    #####: 2100:          break;
        -: 2101:
    #####: 2102:        case 'T':
    #####: 2103:          tabsize_opt = xnumtoumax (optarg, 0, 0, MIN (PTRDIFF_MAX, SIZE_MAX),
call    0 never executed
        -: 2104:                                    "", _("invalid tab size"), LS_FAILURE);
    #####: 2105:          break;
        -: 2106:
    #####: 2107:        case 'U':
    #####: 2108:          sort_opt = sort_none;
    #####: 2109:          break;
        -: 2110:
    #####: 2111:        case 'X':
    #####: 2112:          sort_opt = sort_extension;
    #####: 2113:          break;
        -: 2114:
    #####: 2115:        case '1':
        -: 2116:          /* -1 has no effect after -l.  */
    #####: 2117:          if (format_opt != long_format)
branch  0 never executed
branch  1 never executed
    #####: 2118:            format_opt = one_per_line;
    #####: 2119:          break;
        -: 2120:
    #####: 2121:        case AUTHOR_OPTION:
    #####: 2122:          print_author = true;
    #####: 2123:          break;
        -: 2124:
    #####: 2125:        case HIDE_OPTION:
        -: 2126:          {
    #####: 2127:            struct ignore_pattern *hide = xmalloc (sizeof *hide);
call    0 never executed
    #####: 2128:            hide->pattern = optarg;
    #####: 2129:            hide->next = hide_patterns;
    #####: 2130:            hide_patterns = hide;
        -: 2131:          }
    #####: 2132:          break;
        -: 2133:
    #####: 2134:        case SORT_OPTION:
    #####: 2135:          sort_opt = XARGMATCH ("--sort", optarg, sort_args, sort_types);
call    0 never executed
    #####: 2136:          break;
        -: 2137:
    #####: 2138:        case GROUP_DIRECTORIES_FIRST_OPTION:
    #####: 2139:          directories_first = true;
    #####: 2140:          break;
        -: 2141:
    #####: 2142:        case TIME_OPTION:
    #####: 2143:          time_type = XARGMATCH ("--time", optarg, time_args, time_types);
call    0 never executed
    #####: 2144:          break;
        -: 2145:
    #####: 2146:        case FORMAT_OPTION:
    #####: 2147:          format_opt = XARGMATCH ("--format", optarg, format_args,
call    0 never executed
        -: 2148:                                  format_types);
    #####: 2149:          break;
        -: 2150:
    #####: 2151:        case FULL_TIME_OPTION:
    #####: 2152:          format_opt = long_format;
    #####: 2153:          time_style_option = bad_cast ("full-iso");
call    0 never executed
    #####: 2154:          break;
        -: 2155:
    #####: 2156:        case COLOR_OPTION:
        -: 2157:          {
        -: 2158:            int i;
    #####: 2159:            if (optarg)
branch  0 never executed
branch  1 never executed
    #####: 2160:              i = XARGMATCH ("--color", optarg, when_args, when_types);
call    0 never executed
        -: 2161:            else
        -: 2162:              /* Using --color with no argument is equivalent to using
        -: 2163:                 --color=always.  */
    #####: 2164:              i = when_always;
        -: 2165:
    #####: 2166:            print_with_color = (i == when_always
    #####: 2167:                                || (i == when_if_tty && stdout_isatty ()));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####: 2168:            break;
        -: 2169:          }
        -: 2170:
    #####: 2171:        case HYPERLINK_OPTION:
        -: 2172:          {
        -: 2173:            int i;
    #####: 2174:            if (optarg)
branch  0 never executed
branch  1 never executed
    #####: 2175:              i = XARGMATCH ("--hyperlink", optarg, when_args, when_types);
call    0 never executed
        -: 2176:            else
        -: 2177:              /* Using --hyperlink with no argument is equivalent to using
        -: 2178:                 --hyperlink=always.  */
    #####: 2179:              i = when_always;
        -: 2180:
    #####: 2181:            print_hyperlink = (i == when_always
    #####: 2182:                               || (i == when_if_tty && stdout_isatty ()));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####: 2183:            break;
        -: 2184:          }
        -: 2185:
    #####: 2186:        case INDICATOR_STYLE_OPTION:
    #####: 2187:          indicator_style = XARGMATCH ("--indicator-style", optarg,
call    0 never executed
        -: 2188:                                       indicator_style_args,
        -: 2189:                                       indicator_style_types);
    #####: 2190:          break;
        -: 2191:
    #####: 2192:        case QUOTING_STYLE_OPTION:
    #####: 2193:          quoting_style_opt = XARGMATCH ("--quoting-style", optarg,
call    0 never executed
        -: 2194:                                         quoting_style_args,
        -: 2195:                                         quoting_style_vals);
    #####: 2196:          break;
        -: 2197:
    #####: 2198:        case TIME_STYLE_OPTION:
    #####: 2199:          time_style_option = optarg;
    #####: 2200:          break;
        -: 2201:
    #####: 2202:        case SHOW_CONTROL_CHARS_OPTION:
    #####: 2203:          hide_control_chars_opt = false;
    #####: 2204:          break;
        -: 2205:
    #####: 2206:        case BLOCK_SIZE_OPTION:
        -: 2207:          {
    #####: 2208:            enum strtol_error e = human_options (optarg, &human_output_opts,
call    0 never executed
        -: 2209:                                                 &output_block_size);
    #####: 2210:            if (e != LONGINT_OK)
branch  0 never executed
branch  1 never executed
    #####: 2211:              xstrtol_fatal (e, oi, 0, long_options, optarg);
call    0 never executed
    #####: 2212:            file_human_output_opts = human_output_opts;
    #####: 2213:            file_output_block_size = output_block_size;
        -: 2214:          }
    #####: 2215:          break;
        -: 2216:
    #####: 2217:        case SI_OPTION:
    #####: 2218:          file_human_output_opts = human_output_opts =
        -: 2219:            human_autoscale | human_SI;
    #####: 2220:          file_output_block_size = output_block_size = 1;
    #####: 2221:          break;
        -: 2222:
    #####: 2223:        case 'Z':
    #####: 2224:          print_scontext = true;
    #####: 2225:          break;
        -: 2226:
    #####: 2227:        case ZERO_OPTION:
    #####: 2228:          eolbyte = 0;
    #####: 2229:          hide_control_chars_opt = false;
    #####: 2230:          if (format_opt != long_format)
branch  0 never executed
branch  1 never executed
    #####: 2231:            format_opt = one_per_line;
    #####: 2232:          print_with_color = false;
    #####: 2233:          quoting_style_opt = literal_quoting_style;
    #####: 2234:          break;
        -: 2235:
    #####: 2236:        case_GETOPT_HELP_CHAR;
call    0 never executed
        -: 2237:
    #####: 2238:        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
call    7 never executed
        -: 2239:
        1: 2240:        default:
        1: 2241:          usage (LS_FAILURE);
call    0 returned 0%
        -: 2242:        }
        -: 2243:    }
        -: 2244:
        1: 2245:  if (! output_block_size)
branch  0 taken 100%
branch  1 taken 0%
        -: 2246:    {
        1: 2247:      char const *ls_block_size = getenv ("LS_BLOCK_SIZE");
call    0 returned 100%
        1: 2248:      human_options (ls_block_size,
call    0 returned 100%
        -: 2249:                     &human_output_opts, &output_block_size);
        1: 2250:      if (ls_block_size || getenv ("BLOCK_SIZE"))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -: 2251:        {
    #####: 2252:          file_human_output_opts = human_output_opts;
    #####: 2253:          file_output_block_size = output_block_size;
        -: 2254:        }
        1: 2255:      if (kibibytes_specified)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2256:        {
    #####: 2257:          human_output_opts = 0;
    #####: 2258:          output_block_size = 1024;
        -: 2259:        }
        -: 2260:    }
        -: 2261:
        1: 2262:  format = (0 <= format_opt ? format_opt
       1*: 2263:            : ls_mode == LS_LS ? (stdout_isatty ()
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
        -: 2264:                                  ? many_per_line : one_per_line)
    #####: 2265:            : ls_mode == LS_MULTI_COL ? many_per_line
branch  0 never executed
branch  1 never executed
        -: 2266:            : /* ls_mode == LS_LONG_FORMAT */ long_format);
        -: 2267:
        -: 2268:  /* If the line length was not set by a switch but is needed to determine
        -: 2269:     output, go to the work of obtaining it from the environment.  */
        1: 2270:  ptrdiff_t linelen = width_opt;
       1*: 2271:  if (format == many_per_line || format == horizontal || format == with_commas
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2272:      || print_with_color)
branch  0 never executed
branch  1 never executed
        -: 2273:    {
        -: 2274:#ifdef TIOCGWINSZ
        1: 2275:      if (linelen < 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 2276:        {
        -: 2277:          /* Suppress bogus warning re comparing ws.ws_col to big integer.  */
        -: 2278:# if 4 < __GNUC__ + (6 <= __GNUC_MINOR__)
        -: 2279:#  pragma GCC diagnostic push
        -: 2280:#  pragma GCC diagnostic ignored "-Wtype-limits"
        -: 2281:# endif
        -: 2282:          struct winsize ws;
        1: 2283:          if (stdout_isatty ()
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        1: 2284:              && 0 <= ioctl (STDOUT_FILENO, TIOCGWINSZ, &ws)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        1: 2285:              && 0 < ws.ws_col)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 2286:            linelen = ws.ws_col <= MIN (PTRDIFF_MAX, SIZE_MAX) ? ws.ws_col : 0;
        -: 2287:# if 4 < __GNUC__ + (6 <= __GNUC_MINOR__)
        -: 2288:#  pragma GCC diagnostic pop
        -: 2289:# endif
        -: 2290:        }
        -: 2291:#endif
        1: 2292:      if (linelen < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2293:        {
    #####: 2294:          char const *p = getenv ("COLUMNS");
call    0 never executed
    #####: 2295:          if (p && *p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2296:            {
    #####: 2297:              linelen = decode_line_length (p);
call    0 never executed
    #####: 2298:              if (linelen < 0)
branch  0 never executed
branch  1 never executed
    #####: 2299:                error (0, 0,
call    0 never executed
        -: 2300:                       _("ignoring invalid width"
        -: 2301:                         " in environment variable COLUMNS: %s"),
        -: 2302:                       quote (p));
        -: 2303:            }
        -: 2304:        }
        -: 2305:    }
        -: 2306:
       1*: 2307:  line_length = linelen < 0 ? 80 : linelen;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 2308:
        -: 2309:  /* Determine the max possible number of display columns.  */
        1: 2310:  max_idx = line_length / MIN_COLUMN_WIDTH;
        -: 2311:  /* Account for first display column not having a separator,
        -: 2312:     or line_lengths shorter than MIN_COLUMN_WIDTH.  */
        1: 2313:  max_idx += line_length % MIN_COLUMN_WIDTH != 0;
        -: 2314:
       1*: 2315:  if (format == many_per_line || format == horizontal || format == with_commas)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 2316:    {
        1: 2317:      if (0 <= tabsize_opt)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2318:        tabsize = tabsize_opt;
        -: 2319:      else
        -: 2320:        {
        1: 2321:          tabsize = 8;
        1: 2322:          char const *p = getenv ("TABSIZE");
call    0 returned 100%
        1: 2323:          if (p)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2324:            {
        -: 2325:              uintmax_t tmp;
    #####: 2326:              if (xstrtoumax (p, nullptr, 0, &tmp, "") == LONGINT_OK
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2327:                  && tmp <= SIZE_MAX)
    #####: 2328:                tabsize = tmp;
        -: 2329:              else
    #####: 2330:                error (0, 0,
call    0 never executed
        -: 2331:                       _("ignoring invalid tab size"
        -: 2332:                         " in environment variable TABSIZE: %s"),
        -: 2333:                       quote (p));
        -: 2334:            }
        -: 2335:        }
        -: 2336:    }
        -: 2337:
        1: 2338:  qmark_funny_chars = (hide_control_chars_opt < 0
       1*: 2339:                       ? ls_mode == LS_LS && stdout_isatty ()
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
       2*: 2340:                       : hide_control_chars_opt);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 2341:
        1: 2342:  int qs = quoting_style_opt;
        1: 2343:  if (qs < 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 2344:    qs = getenv_quoting_style ();
call    0 returned 100%
        1: 2345:  if (qs < 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 2346:    qs = (ls_mode == LS_LS
       1*: 2347:          ? (stdout_isatty () ? shell_escape_quoting_style : -1)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
       2*: 2348:          : escape_quoting_style);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 2349:  if (0 <= qs)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 2350:    set_quoting_style (nullptr, qs);
call    0 returned 100%
        1: 2351:  qs = get_quoting_style (nullptr);
call    0 returned 100%
        -: 2352:  align_variable_outer_quotes
        2: 2353:    = ((format == long_format
       1*: 2354:        || ((format == many_per_line || format == horizontal) && line_length))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
       3*: 2355:       && (qs == shell_quoting_style
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1: 2356:           || qs == shell_escape_quoting_style
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2357:           || qs == c_maybe_quoting_style));
branch  0 never executed
branch  1 never executed
        1: 2358:  filename_quoting_options = clone_quoting_options (nullptr);
call    0 returned 100%
        1: 2359:  if (qs == escape_quoting_style)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2360:    set_char_quoting (filename_quoting_options, ' ', 1);
call    0 never executed
        1: 2361:  if (file_type <= indicator_style)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2362:    {
        -: 2363:      char const *p;
    #####: 2364:      for (p = &"*=>@|"[indicator_style - file_type]; *p; p++)
branch  0 never executed
branch  1 never executed
    #####: 2365:        set_char_quoting (filename_quoting_options, *p, 1);
call    0 never executed
        -: 2366:    }
        -: 2367:
        1: 2368:  dirname_quoting_options = clone_quoting_options (nullptr);
call    0 returned 100%
        1: 2369:  set_char_quoting (dirname_quoting_options, ':', 1);
call    0 returned 100%
        -: 2370:
        -: 2371:  /* --dired is meaningful only with --format=long (-l) and sans --hyperlink.
        -: 2372:     Otherwise, ignore it.  FIXME: warn about this?
        -: 2373:     Alternatively, make --dired imply --format=long?  */
        1: 2374:  dired &= (format == long_format) & !print_hyperlink;
        -: 2375:
        1: 2376:  if (eolbyte < dired)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2377:    error (LS_FAILURE, 0, _("--dired and --zero are incompatible"));
call    0 never executed
        -: 2378:
        -: 2379:  /* If -c or -u is specified and not -l (or any other option that implies -l),
        -: 2380:     and no sort-type was specified, then sort by the ctime (-c) or atime (-u).
        -: 2381:     The behavior of ls when using either -c or -u but with neither -l nor -t
        -: 2382:     appears to be unspecified by POSIX.  So, with GNU ls, '-u' alone means
        -: 2383:     sort by atime (this is the one that's not specified by the POSIX spec),
        -: 2384:     -lu means show atime and sort by name, -lut means show atime and sort
        -: 2385:     by atime.  */
        -: 2386:
        1: 2387:  sort_type = (0 <= sort_opt ? sort_opt
       2*: 2388:               : (format != long_format
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1: 2389:                  && (time_type == time_ctime || time_type == time_atime
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1: 2390:                      || time_type == time_btime))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2391:               ? sort_time : sort_name);
        -: 2392:
        1: 2393:  if (format == long_format)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2394:    {
    #####: 2395:      char *style = time_style_option;
        -: 2396:      static char const posix_prefix[] = "posix-";
        -: 2397:
    #####: 2398:      if (! style)
branch  0 never executed
branch  1 never executed
    #####: 2399:        if (! (style = getenv ("TIME_STYLE")))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2400:          style = bad_cast ("locale");
call    0 never executed
        -: 2401:
    #####: 2402:      while (STREQ_LEN (style, posix_prefix, sizeof posix_prefix - 1))
branch  0 never executed
branch  1 never executed
        -: 2403:        {
    #####: 2404:          if (! hard_locale (LC_TIME))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2405:            return optind;
    #####: 2406:          style += sizeof posix_prefix - 1;
        -: 2407:        }
        -: 2408:
    #####: 2409:      if (*style == '+')
branch  0 never executed
branch  1 never executed
        -: 2410:        {
    #####: 2411:          char *p0 = style + 1;
    #####: 2412:          char *p1 = strchr (p0, '\n');
    #####: 2413:          if (! p1)
branch  0 never executed
branch  1 never executed
    #####: 2414:            p1 = p0;
        -: 2415:          else
        -: 2416:            {
    #####: 2417:              if (strchr (p1 + 1, '\n'))
branch  0 never executed
branch  1 never executed
    #####: 2418:                error (LS_FAILURE, 0, _("invalid time style format %s"),
call    0 never executed
call    1 never executed
        -: 2419:                       quote (p0));
    #####: 2420:              *p1++ = '\0';
        -: 2421:            }
    #####: 2422:          long_time_format[0] = p0;
    #####: 2423:          long_time_format[1] = p1;
        -: 2424:        }
        -: 2425:      else
        -: 2426:        {
    #####: 2427:          ptrdiff_t res = argmatch (style, time_style_args,
        -: 2428:                                    (char const *) time_style_types,
        -: 2429:                                    sizeof (*time_style_types));
    #####: 2430:          if (res < 0)
branch  0 never executed
branch  1 never executed
        -: 2431:            {
        -: 2432:              /* This whole block used to be a simple use of XARGMATCH.
        -: 2433:                 but that didn't print the "posix-"-prefixed variants or
        -: 2434:                 the "+"-prefixed format string option upon failure.  */
    #####: 2435:              argmatch_invalid ("time style", style, res);
call    0 never executed
        -: 2436:
        -: 2437:              /* The following is a manual expansion of argmatch_valid,
        -: 2438:                 but with the added "+ ..." description and the [posix-]
        -: 2439:                 prefixes prepended.  Note that this simplification works
        -: 2440:                 only because all four existing time_style_types values
        -: 2441:                 are distinct.  */
    #####: 2442:              fputs (_("Valid arguments are:\n"), stderr);
call    0 never executed
    #####: 2443:              char const *const *p = time_style_args;
    #####: 2444:              while (*p)
branch  0 never executed
branch  1 never executed
    #####: 2445:                fprintf (stderr, "  - [posix-]%s\n", *p++);
call    0 never executed
    #####: 2446:              fputs (_("  - +FORMAT (e.g., +%H:%M) for a 'date'-style"
call    0 never executed
        -: 2447:                       " format\n"), stderr);
    #####: 2448:              usage (LS_FAILURE);
call    0 never executed
        -: 2449:            }
    #####: 2450:          switch (res)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 2451:            {
    #####: 2452:            case full_iso_time_style:
    #####: 2453:              long_time_format[0] = long_time_format[1] =
        -: 2454:                "%Y-%m-%d %H:%M:%S.%N %z";
    #####: 2455:              break;
        -: 2456:
    #####: 2457:            case long_iso_time_style:
    #####: 2458:              long_time_format[0] = long_time_format[1] = "%Y-%m-%d %H:%M";
    #####: 2459:              break;
        -: 2460:
    #####: 2461:            case iso_time_style:
    #####: 2462:              long_time_format[0] = "%Y-%m-%d ";
    #####: 2463:              long_time_format[1] = "%m-%d %H:%M";
    #####: 2464:              break;
        -: 2465:
    #####: 2466:            case locale_time_style:
    #####: 2467:              if (hard_locale (LC_TIME))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2468:                {
    #####: 2469:                  for (int i = 0; i < 2; i++)
branch  0 never executed
branch  1 never executed
    #####: 2470:                    long_time_format[i] =
    #####: 2471:                      dcgettext (nullptr, long_time_format[i], LC_TIME);
        -: 2472:                }
        -: 2473:            }
        -: 2474:        }
        -: 2475:
    #####: 2476:      abformat_init ();
call    0 never executed
        -: 2477:    }
        -: 2478:
        1: 2479:  return optind;
        -: 2480:}
        -: 2481:
        -: 2482:/* Parse a string as part of the LS_COLORS variable; this may involve
        -: 2483:   decoding all kinds of escape characters.  If equals_end is set an
        -: 2484:   unescaped equal sign ends the string, otherwise only a : or \0
        -: 2485:   does.  Set *OUTPUT_COUNT to the number of bytes output.  Return
        -: 2486:   true if successful.
        -: 2487:
        -: 2488:   The resulting string is *not* null-terminated, but may contain
        -: 2489:   embedded nulls.
        -: 2490:
        -: 2491:   Note that both dest and src are char **; on return they point to
        -: 2492:   the first free byte after the array and the character that ended
        -: 2493:   the input string, respectively.  */
        -: 2494:
        -: 2495:static bool
function get_funky_string called 0 returned 0% blocks executed 0%
    #####: 2496:get_funky_string (char **dest, char const **src, bool equals_end,
        -: 2497:                  size_t *output_count)
        -: 2498:{
        -: 2499:  char num;			/* For numerical codes */
        -: 2500:  size_t count;			/* Something to count with */
        -: 2501:  enum {
        -: 2502:    ST_GND, ST_BACKSLASH, ST_OCTAL, ST_HEX, ST_CARET, ST_END, ST_ERROR
        -: 2503:  } state;
        -: 2504:  char const *p;
        -: 2505:  char *q;
        -: 2506:
    #####: 2507:  p = *src;			/* We don't want to double-indirect */
    #####: 2508:  q = *dest;			/* the whole darn time.  */
        -: 2509:
    #####: 2510:  count = 0;			/* No characters counted in yet.  */
    #####: 2511:  num = 0;
        -: 2512:
    #####: 2513:  state = ST_GND;		/* Start in ground state.  */
    #####: 2514:  while (state < ST_END)
branch  0 never executed
branch  1 never executed
        -: 2515:    {
    #####: 2516:      switch (state)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 2517:        {
    #####: 2518:        case ST_GND:		/* Ground state (no escapes) */
    #####: 2519:          switch (*p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 2520:            {
    #####: 2521:            case ':':
        -: 2522:            case '\0':
    #####: 2523:              state = ST_END;	/* End of string */
    #####: 2524:              break;
    #####: 2525:            case '\\':
    #####: 2526:              state = ST_BACKSLASH; /* Backslash escape sequence */
    #####: 2527:              ++p;
    #####: 2528:              break;
    #####: 2529:            case '^':
    #####: 2530:              state = ST_CARET; /* Caret escape */
    #####: 2531:              ++p;
    #####: 2532:              break;
    #####: 2533:            case '=':
    #####: 2534:              if (equals_end)
branch  0 never executed
branch  1 never executed
        -: 2535:                {
    #####: 2536:                  state = ST_END; /* End */
    #####: 2537:                  break;
        -: 2538:                }
        -: 2539:              FALLTHROUGH;
        -: 2540:            default:
    #####: 2541:              *(q++) = *(p++);
    #####: 2542:              ++count;
    #####: 2543:              break;
        -: 2544:            }
    #####: 2545:          break;
        -: 2546:
    #####: 2547:        case ST_BACKSLASH:	/* Backslash escaped character */
    #####: 2548:          switch (*p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
        -: 2549:            {
    #####: 2550:            case '0':
        -: 2551:            case '1':
        -: 2552:            case '2':
        -: 2553:            case '3':
        -: 2554:            case '4':
        -: 2555:            case '5':
        -: 2556:            case '6':
        -: 2557:            case '7':
    #####: 2558:              state = ST_OCTAL;	/* Octal sequence */
    #####: 2559:              num = *p - '0';
    #####: 2560:              break;
    #####: 2561:            case 'x':
        -: 2562:            case 'X':
    #####: 2563:              state = ST_HEX;	/* Hex sequence */
    #####: 2564:              num = 0;
    #####: 2565:              break;
    #####: 2566:            case 'a':		/* Bell */
    #####: 2567:              num = '\a';
    #####: 2568:              break;
    #####: 2569:            case 'b':		/* Backspace */
    #####: 2570:              num = '\b';
    #####: 2571:              break;
    #####: 2572:            case 'e':		/* Escape */
    #####: 2573:              num = 27;
    #####: 2574:              break;
    #####: 2575:            case 'f':		/* Form feed */
    #####: 2576:              num = '\f';
    #####: 2577:              break;
    #####: 2578:            case 'n':		/* Newline */
    #####: 2579:              num = '\n';
    #####: 2580:              break;
    #####: 2581:            case 'r':		/* Carriage return */
    #####: 2582:              num = '\r';
    #####: 2583:              break;
    #####: 2584:            case 't':		/* Tab */
    #####: 2585:              num = '\t';
    #####: 2586:              break;
    #####: 2587:            case 'v':		/* Vtab */
    #####: 2588:              num = '\v';
    #####: 2589:              break;
    #####: 2590:            case '?':		/* Delete */
    #####: 2591:              num = 127;
    #####: 2592:              break;
    #####: 2593:            case '_':		/* Space */
    #####: 2594:              num = ' ';
    #####: 2595:              break;
    #####: 2596:            case '\0':		/* End of string */
    #####: 2597:              state = ST_ERROR;	/* Error! */
    #####: 2598:              break;
    #####: 2599:            default:		/* Escaped character like \ ^ : = */
    #####: 2600:              num = *p;
    #####: 2601:              break;
        -: 2602:            }
    #####: 2603:          if (state == ST_BACKSLASH)
branch  0 never executed
branch  1 never executed
        -: 2604:            {
    #####: 2605:              *(q++) = num;
    #####: 2606:              ++count;
    #####: 2607:              state = ST_GND;
        -: 2608:            }
    #####: 2609:          ++p;
    #####: 2610:          break;
        -: 2611:
    #####: 2612:        case ST_OCTAL:		/* Octal sequence */
    #####: 2613:          if (*p < '0' || *p > '7')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2614:            {
    #####: 2615:              *(q++) = num;
    #####: 2616:              ++count;
    #####: 2617:              state = ST_GND;
        -: 2618:            }
        -: 2619:          else
    #####: 2620:            num = (num << 3) + (*(p++) - '0');
    #####: 2621:          break;
        -: 2622:
    #####: 2623:        case ST_HEX:		/* Hex sequence */
    #####: 2624:          switch (*p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2625:            {
    #####: 2626:            case '0':
        -: 2627:            case '1':
        -: 2628:            case '2':
        -: 2629:            case '3':
        -: 2630:            case '4':
        -: 2631:            case '5':
        -: 2632:            case '6':
        -: 2633:            case '7':
        -: 2634:            case '8':
        -: 2635:            case '9':
    #####: 2636:              num = (num << 4) + (*(p++) - '0');
    #####: 2637:              break;
    #####: 2638:            case 'a':
        -: 2639:            case 'b':
        -: 2640:            case 'c':
        -: 2641:            case 'd':
        -: 2642:            case 'e':
        -: 2643:            case 'f':
    #####: 2644:              num = (num << 4) + (*(p++) - 'a') + 10;
    #####: 2645:              break;
    #####: 2646:            case 'A':
        -: 2647:            case 'B':
        -: 2648:            case 'C':
        -: 2649:            case 'D':
        -: 2650:            case 'E':
        -: 2651:            case 'F':
    #####: 2652:              num = (num << 4) + (*(p++) - 'A') + 10;
    #####: 2653:              break;
    #####: 2654:            default:
    #####: 2655:              *(q++) = num;
    #####: 2656:              ++count;
    #####: 2657:              state = ST_GND;
    #####: 2658:              break;
        -: 2659:            }
    #####: 2660:          break;
        -: 2661:
    #####: 2662:        case ST_CARET:		/* Caret escape */
    #####: 2663:          state = ST_GND;	/* Should be the next state... */
    #####: 2664:          if (*p >= '@' && *p <= '~')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2665:            {
    #####: 2666:              *(q++) = *(p++) & 037;
    #####: 2667:              ++count;
        -: 2668:            }
    #####: 2669:          else if (*p == '?')
branch  0 never executed
branch  1 never executed
        -: 2670:            {
    #####: 2671:              *(q++) = 127;
    #####: 2672:              ++count;
        -: 2673:            }
        -: 2674:          else
    #####: 2675:            state = ST_ERROR;
    #####: 2676:          break;
        -: 2677:
    #####: 2678:        default:
    #####: 2679:          unreachable ();
call    0 never executed
        -: 2680:        }
        -: 2681:    }
        -: 2682:
    #####: 2683:  *dest = q;
    #####: 2684:  *src = p;
    #####: 2685:  *output_count = count;
        -: 2686:
    #####: 2687:  return state != ST_ERROR;
        -: 2688:}
        -: 2689:
        -: 2690:enum parse_state
        -: 2691:  {
        -: 2692:    PS_START = 1,
        -: 2693:    PS_2,
        -: 2694:    PS_3,
        -: 2695:    PS_4,
        -: 2696:    PS_DONE,
        -: 2697:    PS_FAIL
        -: 2698:  };
        -: 2699:
        -: 2700:
        -: 2701:/* Check if the content of TERM is a valid name in dircolors.  */
        -: 2702:
        -: 2703:static bool
function known_term_type called 0 returned 0% blocks executed 0%
    #####: 2704:known_term_type (void)
        -: 2705:{
    #####: 2706:  char const *term = getenv ("TERM");
call    0 never executed
    #####: 2707:  if (! term || ! *term)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2708:    return false;
        -: 2709:
    #####: 2710:  char const *line = G_line;
    #####: 2711:  while (line - G_line < sizeof (G_line))
branch  0 never executed
branch  1 never executed
        -: 2712:    {
    #####: 2713:      if (STRNCMP_LIT (line, "TERM ") == 0)
branch  0 never executed
branch  1 never executed
        -: 2714:        {
    #####: 2715:          if (fnmatch (line + 5, term, 0) == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2716:            return true;
        -: 2717:        }
    #####: 2718:      line += strlen (line) + 1;
        -: 2719:    }
        -: 2720:
    #####: 2721:  return false;
        -: 2722:}
        -: 2723:
        -: 2724:static void
function parse_ls_color called 0 returned 0% blocks executed 0%
    #####: 2725:parse_ls_color (void)
        -: 2726:{
        -: 2727:  char const *p;		/* Pointer to character being parsed */
        -: 2728:  char *buf;			/* color_buf buffer pointer */
        -: 2729:  int ind_no;			/* Indicator number */
        -: 2730:  char label[3];		/* Indicator label */
        -: 2731:  struct color_ext_type *ext;	/* Extension we are working on */
        -: 2732:
    #####: 2733:  if ((p = getenv ("LS_COLORS")) == nullptr || *p == '\0')
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 2734:    {
        -: 2735:      /* LS_COLORS takes precedence, but if that's not set then
        -: 2736:         honor the COLORTERM and TERM env variables so that
        -: 2737:         we only go with the internal ANSI color codes if the
        -: 2738:         former is non empty or the latter is set to a known value.  */
    #####: 2739:      char const *colorterm = getenv ("COLORTERM");
call    0 never executed
    #####: 2740:      if (! (colorterm && *colorterm) && ! known_term_type ())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####: 2741:        print_with_color = false;
    #####: 2742:      return;
        -: 2743:    }
        -: 2744:
    #####: 2745:  ext = nullptr;
    #####: 2746:  strcpy (label, "??");
        -: 2747:
        -: 2748:  /* This is an overly conservative estimate, but any possible
        -: 2749:     LS_COLORS string will *not* generate a color_buf longer than
        -: 2750:     itself, so it is a safe way of allocating a buffer in
        -: 2751:     advance.  */
    #####: 2752:  buf = color_buf = xstrdup (p);
call    0 never executed
        -: 2753:
    #####: 2754:  enum parse_state state = PS_START;
        -: 2755:  while (true)
        -: 2756:    {
    #####: 2757:      switch (state)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 2758:        {
    #####: 2759:        case PS_START:		/* First label character */
    #####: 2760:          switch (*p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2761:            {
    #####: 2762:            case ':':
    #####: 2763:              ++p;
    #####: 2764:              break;
        -: 2765:
    #####: 2766:            case '*':
        -: 2767:              /* Allocate new extension block and add to head of
        -: 2768:                 linked list (this way a later definition will
        -: 2769:                 override an earlier one, which can be useful for
        -: 2770:                 having terminal-specific defs override global).  */
        -: 2771:
    #####: 2772:              ext = xmalloc (sizeof *ext);
call    0 never executed
    #####: 2773:              ext->next = color_ext_list;
    #####: 2774:              color_ext_list = ext;
    #####: 2775:              ext->exact_match = false;
        -: 2776:
    #####: 2777:              ++p;
    #####: 2778:              ext->ext.string = buf;
        -: 2779:
    #####: 2780:              state = (get_funky_string (&buf, &p, true, &ext->ext.len)
call    0 never executed
    #####: 2781:                       ? PS_4 : PS_FAIL);
branch  0 never executed
branch  1 never executed
    #####: 2782:              break;
        -: 2783:
    #####: 2784:            case '\0':
    #####: 2785:              state = PS_DONE;	/* Done! */
    #####: 2786:              goto done;
        -: 2787:
    #####: 2788:            default:	/* Assume it is file type label */
    #####: 2789:              label[0] = *(p++);
    #####: 2790:              state = PS_2;
    #####: 2791:              break;
        -: 2792:            }
    #####: 2793:          break;
        -: 2794:
    #####: 2795:        case PS_2:		/* Second label character */
    #####: 2796:          if (*p)
branch  0 never executed
branch  1 never executed
        -: 2797:            {
    #####: 2798:              label[1] = *(p++);
    #####: 2799:              state = PS_3;
        -: 2800:            }
        -: 2801:          else
    #####: 2802:            state = PS_FAIL;	/* Error */
    #####: 2803:          break;
        -: 2804:
    #####: 2805:        case PS_3:		/* Equal sign after indicator label */
    #####: 2806:          state = PS_FAIL;	/* Assume failure...  */
    #####: 2807:          if (*(p++) == '=')/* It *should* be...  */
branch  0 never executed
branch  1 never executed
        -: 2808:            {
    #####: 2809:              for (ind_no = 0; indicator_name[ind_no] != nullptr; ++ind_no)
branch  0 never executed
branch  1 never executed
        -: 2810:                {
    #####: 2811:                  if (STREQ (label, indicator_name[ind_no]))
branch  0 never executed
branch  1 never executed
        -: 2812:                    {
    #####: 2813:                      color_indicator[ind_no].string = buf;
    #####: 2814:                      state = (get_funky_string (&buf, &p, false,
call    0 never executed
        -: 2815:                                                 &color_indicator[ind_no].len)
    #####: 2816:                               ? PS_START : PS_FAIL);
branch  0 never executed
branch  1 never executed
    #####: 2817:                      break;
        -: 2818:                    }
        -: 2819:                }
    #####: 2820:              if (state == PS_FAIL)
branch  0 never executed
branch  1 never executed
    #####: 2821:                error (0, 0, _("unrecognized prefix: %s"), quote (label));
call    0 never executed
        -: 2822:            }
    #####: 2823:          break;
        -: 2824:
    #####: 2825:        case PS_4:		/* Equal sign after *.ext */
    #####: 2826:          if (*(p++) == '=')
branch  0 never executed
branch  1 never executed
        -: 2827:            {
    #####: 2828:              ext->seq.string = buf;
    #####: 2829:              state = (get_funky_string (&buf, &p, false, &ext->seq.len)
call    0 never executed
    #####: 2830:                       ? PS_START : PS_FAIL);
branch  0 never executed
branch  1 never executed
        -: 2831:            }
        -: 2832:          else
    #####: 2833:            state = PS_FAIL;
    #####: 2834:          break;
        -: 2835:
    #####: 2836:        case PS_FAIL:
    #####: 2837:          goto done;
        -: 2838:
    #####: 2839:        default:
    #####: 2840:          affirm (false);
call    0 never executed
        -: 2841:        }
        -: 2842:    }
    #####: 2843: done:
        -: 2844:
    #####: 2845:  if (state == PS_FAIL)
branch  0 never executed
branch  1 never executed
        -: 2846:    {
        -: 2847:      struct color_ext_type *e;
        -: 2848:      struct color_ext_type *e2;
        -: 2849:
        -: 2850:      error (0, 0,
        -: 2851:             _("unparsable value for LS_COLORS environment variable"));
    #####: 2852:      free (color_buf);
    #####: 2853:      for (e = color_ext_list; e != nullptr; /* empty */)
branch  0 never executed
branch  1 never executed
        -: 2854:        {
    #####: 2855:          e2 = e;
    #####: 2856:          e = e->next;
    #####: 2857:          free (e2);
        -: 2858:        }
    #####: 2859:      print_with_color = false;
        -: 2860:    }
        -: 2861:  else
        -: 2862:    {
        -: 2863:      /* Postprocess list to set EXACT_MATCH on entries where there are
        -: 2864:         different cased extensions with separate sequences defined.
        -: 2865:         Also set ext.len to SIZE_MAX on any entries that can't
        -: 2866:         match due to precedence, to avoid redundant string compares.  */
        -: 2867:      struct color_ext_type *e1;
        -: 2868:
    #####: 2869:      for (e1 = color_ext_list; e1 != nullptr; e1 = e1->next)
branch  0 never executed
branch  1 never executed
        -: 2870:        {
        -: 2871:          struct color_ext_type *e2;
    #####: 2872:          bool case_ignored = false;
        -: 2873:
    #####: 2874:          for (e2 = e1->next; e2 != nullptr; e2 = e2->next)
branch  0 never executed
branch  1 never executed
        -: 2875:            {
    #####: 2876:              if (e2->ext.len < SIZE_MAX && e1->ext.len == e2->ext.len)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2877:                {
    #####: 2878:                  if (memcmp (e1->ext.string, e2->ext.string, e1->ext.len) == 0)
branch  0 never executed
branch  1 never executed
    #####: 2879:                    e2->ext.len = SIZE_MAX; /* Ignore */
    #####: 2880:                  else if (c_strncasecmp (e1->ext.string, e2->ext.string,
branch  0 never executed
branch  1 never executed
        -: 2881:                                          e1->ext.len) == 0)
        -: 2882:                    {
    #####: 2883:                      if (case_ignored)
branch  0 never executed
branch  1 never executed
        -: 2884:                        {
    #####: 2885:                          e2->ext.len = SIZE_MAX; /* Ignore */
        -: 2886:                        }
    #####: 2887:                      else if (e1->seq.len == e2->seq.len
branch  0 never executed
branch  1 never executed
    #####: 2888:                               && memcmp (e1->seq.string, e2->seq.string,
branch  0 never executed
branch  1 never executed
        -: 2889:                                          e1->seq.len) == 0)
        -: 2890:                        {
    #####: 2891:                          e2->ext.len = SIZE_MAX; /* Ignore */
    #####: 2892:                          case_ignored = true;    /* Ignore all subsequent */
        -: 2893:                        }
        -: 2894:                      else
        -: 2895:                        {
    #####: 2896:                          e1->exact_match = true;
    #####: 2897:                          e2->exact_match = true;
        -: 2898:                        }
        -: 2899:                    }
        -: 2900:                }
        -: 2901:            }
        -: 2902:        }
        -: 2903:    }
        -: 2904:
    #####: 2905:  if (color_indicator[C_LINK].len == 6
branch  0 never executed
branch  1 never executed
    #####: 2906:      && !STRNCMP_LIT (color_indicator[C_LINK].string, "target"))
branch  0 never executed
branch  1 never executed
    #####: 2907:    color_symlink_as_referent = true;
        -: 2908:}
        -: 2909:
        -: 2910:/* Return the quoting style specified by the environment variable
        -: 2911:   QUOTING_STYLE if set and valid, -1 otherwise.  */
        -: 2912:
        -: 2913:static int
function getenv_quoting_style called 1 returned 100% blocks executed 36%
        1: 2914:getenv_quoting_style (void)
        -: 2915:{
        1: 2916:  char const *q_style = getenv ("QUOTING_STYLE");
call    0 returned 100%
        1: 2917:  if (!q_style)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 2918:    return -1;
    #####: 2919:  int i = ARGMATCH (q_style, quoting_style_args, quoting_style_vals);
    #####: 2920:  if (i < 0)
branch  0 never executed
branch  1 never executed
        -: 2921:    {
    #####: 2922:      error (0, 0,
call    0 never executed
        -: 2923:             _("ignoring invalid value"
        -: 2924:               " of environment variable QUOTING_STYLE: %s"),
        -: 2925:             quote (q_style));
    #####: 2926:      return -1;
        -: 2927:    }
    #####: 2928:  return quoting_style_vals[i];
        -: 2929:}
        -: 2930:
        -: 2931:/* Set the exit status to report a failure.  If SERIOUS, it is a
        -: 2932:   serious failure; otherwise, it is merely a minor problem.  */
        -: 2933:
        -: 2934:static void
function set_exit_status called 1 returned 100% blocks executed 60%
        1: 2935:set_exit_status (bool serious)
        -: 2936:{
        1: 2937:  if (serious)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 2938:    exit_status = LS_FAILURE;
    #####: 2939:  else if (exit_status == EXIT_SUCCESS)
branch  0 never executed
branch  1 never executed
    #####: 2940:    exit_status = LS_MINOR_PROBLEM;
        1: 2941:}
        -: 2942:
        -: 2943:/* Assuming a failure is serious if SERIOUS, use the printf-style
        -: 2944:   MESSAGE to report the failure to access a file named FILE.  Assume
        -: 2945:   errno is set appropriately for the failure.  */
        -: 2946:
        -: 2947:static void
function file_failure called 1 returned 100% blocks executed 100%
        1: 2948:file_failure (bool serious, char const *message, char const *file)
        -: 2949:{
        1: 2950:  error (0, errno, message, quoteaf (file));
call    0 returned 100%
        1: 2951:  set_exit_status (serious);
call    0 returned 100%
        1: 2952:}
        -: 2953:
        -: 2954:/* Request that the directory named NAME have its contents listed later.
        -: 2955:   If REALNAME is nonzero, it will be used instead of NAME when the
        -: 2956:   directory name is printed.  This allows symbolic links to directories
        -: 2957:   to be treated as regular directories but still be listed under their
        -: 2958:   real names.  NAME == nullptr is used to insert a marker entry for the
        -: 2959:   directory named in REALNAME.
        -: 2960:   If NAME is non-null, we use its dev/ino information to save
        -: 2961:   a call to stat -- when doing a recursive (-R) traversal.
        -: 2962:   COMMAND_LINE_ARG means this directory was mentioned on the command line.  */
        -: 2963:
        -: 2964:static void
function queue_directory called 0 returned 0% blocks executed 0%
    #####: 2965:queue_directory (char const *name, char const *realname, bool command_line_arg)
        -: 2966:{
    #####: 2967:  struct pending *new = xmalloc (sizeof *new);
call    0 never executed
    #####: 2968:  new->realname = realname ? xstrdup (realname) : nullptr;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2969:  new->name = name ? xstrdup (name) : nullptr;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2970:  new->command_line_arg = command_line_arg;
    #####: 2971:  new->next = pending_dirs;
    #####: 2972:  pending_dirs = new;
    #####: 2973:}
        -: 2974:
        -: 2975:/* Read directory NAME, and list the files in it.
        -: 2976:   If REALNAME is nonzero, print its name instead of NAME;
        -: 2977:   this is used for symbolic links to directories.
        -: 2978:   COMMAND_LINE_ARG means this directory was mentioned on the command line.  */
        -: 2979:
        -: 2980:static void
function print_dir called 0 returned 0% blocks executed 0%
    #####: 2981:print_dir (char const *name, char const *realname, bool command_line_arg)
        -: 2982:{
        -: 2983:  DIR *dirp;
        -: 2984:  struct dirent *next;
    #####: 2985:  uintmax_t total_blocks = 0;
        -: 2986:  static bool first = true;
        -: 2987:
    #####: 2988:  errno = 0;
    #####: 2989:  dirp = opendir (name);
call    0 never executed
    #####: 2990:  if (!dirp)
branch  0 never executed
branch  1 never executed
        -: 2991:    {
    #####: 2992:      file_failure (command_line_arg, _("cannot open directory %s"), name);
call    0 never executed
    #####: 2993:      return;
        -: 2994:    }
        -: 2995:
    #####: 2996:  if (LOOP_DETECT)
branch  0 never executed
branch  1 never executed
        -: 2997:    {
        -: 2998:      struct stat dir_stat;
    #####: 2999:      int fd = dirfd (dirp);
call    0 never executed
        -: 3000:
        -: 3001:      /* If dirfd failed, endure the overhead of stat'ing by path  */
    #####: 3002:      if ((0 <= fd
branch  0 never executed
branch  1 never executed
    #####: 3003:           ? fstat_for_ino (fd, &dir_stat)
call    0 never executed
    #####: 3004:           : stat_for_ino (name, &dir_stat)) < 0)
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3005:        {
    #####: 3006:          file_failure (command_line_arg,
call    0 never executed
        -: 3007:                        _("cannot determine device and inode of %s"), name);
    #####: 3008:          closedir (dirp);
call    0 never executed
    #####: 3009:          return;
        -: 3010:        }
        -: 3011:
        -: 3012:      /* If we've already visited this dev/inode pair, warn that
        -: 3013:         we've found a loop, and do not process this directory.  */
    #####: 3014:      if (visit_dir (dir_stat.st_dev, dir_stat.st_ino))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3015:        {
    #####: 3016:          error (0, 0, _("%s: not listing already-listed directory"),
call    0 never executed
        -: 3017:                 quotef (name));
    #####: 3018:          closedir (dirp);
call    0 never executed
    #####: 3019:          set_exit_status (true);
call    0 never executed
    #####: 3020:          return;
        -: 3021:        }
        -: 3022:
    #####: 3023:      dev_ino_push (dir_stat.st_dev, dir_stat.st_ino);
call    0 never executed
        -: 3024:    }
        -: 3025:
    #####: 3026:  clear_files ();
call    0 never executed
        -: 3027:
    #####: 3028:  if (recursive || print_dir_name)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3029:    {
    #####: 3030:      if (!first)
branch  0 never executed
branch  1 never executed
    #####: 3031:        dired_outbyte ('\n');
call    0 never executed
    #####: 3032:      first = false;
    #####: 3033:      dired_indent ();
call    0 never executed
        -: 3034:
    #####: 3035:      char *absolute_name = nullptr;
    #####: 3036:      if (print_hyperlink)
branch  0 never executed
branch  1 never executed
        -: 3037:        {
    #####: 3038:          absolute_name = canonicalize_filename_mode (name, CAN_MISSING);
call    0 never executed
    #####: 3039:          if (! absolute_name)
branch  0 never executed
branch  1 never executed
    #####: 3040:            file_failure (command_line_arg,
call    0 never executed
        -: 3041:                          _("error canonicalizing %s"), name);
        -: 3042:        }
    #####: 3043:      quote_name (realname ? realname : name, dirname_quoting_options, -1,
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3044:                  nullptr, true, &subdired_obstack, absolute_name);
        -: 3045:
    #####: 3046:      free (absolute_name);
        -: 3047:
    #####: 3048:      dired_outstring (":\n");
call    0 never executed
        -: 3049:    }
        -: 3050:
        -: 3051:  /* Read the directory entries, and insert the subfiles into the 'cwd_file'
        -: 3052:     table.  */
        -: 3053:
        -: 3054:  while (true)
        -: 3055:    {
        -: 3056:      /* Set errno to zero so we can distinguish between a readdir failure
        -: 3057:         and when readdir simply finds that there are no more entries.  */
    #####: 3058:      errno = 0;
    #####: 3059:      next = readdir (dirp);
call    0 never executed
    #####: 3060:      if (next)
branch  0 never executed
branch  1 never executed
        -: 3061:        {
    #####: 3062:          if (! file_ignored (next->d_name))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3063:            {
    #####: 3064:              enum filetype type = unknown;
        -: 3065:
        -: 3066:#if HAVE_STRUCT_DIRENT_D_TYPE
    #####: 3067:              switch (next->d_type)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -: 3068:                {
    #####: 3069:                case DT_BLK:  type = blockdev;		break;
    #####: 3070:                case DT_CHR:  type = chardev;		break;
    #####: 3071:                case DT_DIR:  type = directory;		break;
    #####: 3072:                case DT_FIFO: type = fifo;		break;
    #####: 3073:                case DT_LNK:  type = symbolic_link;	break;
    #####: 3074:                case DT_REG:  type = normal;		break;
    #####: 3075:                case DT_SOCK: type = sock;		break;
        -: 3076:# ifdef DT_WHT
    #####: 3077:                case DT_WHT:  type = whiteout;		break;
        -: 3078:# endif
        -: 3079:                }
        -: 3080:#endif
    #####: 3081:              total_blocks += gobble_file (next->d_name, type,
call    0 never executed
        -: 3082:                                           RELIABLE_D_INO (next),
        -: 3083:                                           false, name);
        -: 3084:
        -: 3085:              /* In this narrow case, print out each name right away, so
        -: 3086:                 ls uses constant memory while processing the entries of
        -: 3087:                 this directory.  Useful when there are many (millions)
        -: 3088:                 of entries in a directory.  */
    #####: 3089:              if (format == one_per_line && sort_type == sort_none
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3090:                      && !print_block_size && !recursive)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3091:                {
        -: 3092:                  /* We must call sort_files in spite of
        -: 3093:                     "sort_type == sort_none" for its initialization
        -: 3094:                     of the sorted_file vector.  */
    #####: 3095:                  sort_files ();
call    0 never executed
    #####: 3096:                  print_current_files ();
call    0 never executed
    #####: 3097:                  clear_files ();
call    0 never executed
        -: 3098:                }
        -: 3099:            }
        -: 3100:        }
    #####: 3101:      else if (errno != 0)
branch  0 never executed
branch  1 never executed
        -: 3102:        {
    #####: 3103:          file_failure (command_line_arg, _("reading directory %s"), name);
call    0 never executed
    #####: 3104:          if (errno != EOVERFLOW)
branch  0 never executed
branch  1 never executed
    #####: 3105:            break;
        -: 3106:        }
        -: 3107:      else
    #####: 3108:        break;
        -: 3109:
        -: 3110:      /* When processing a very large directory, and since we've inhibited
        -: 3111:         interrupts, this loop would take so long that ls would be annoyingly
        -: 3112:         uninterruptible.  This ensures that it handles signals promptly.  */
    #####: 3113:      process_signals ();
call    0 never executed
        -: 3114:    }
        -: 3115:
    #####: 3116:  if (closedir (dirp) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3117:    {
    #####: 3118:      file_failure (command_line_arg, _("closing directory %s"), name);
call    0 never executed
        -: 3119:      /* Don't return; print whatever we got.  */
        -: 3120:    }
        -: 3121:
        -: 3122:  /* Sort the directory contents.  */
    #####: 3123:  sort_files ();
call    0 never executed
        -: 3124:
        -: 3125:  /* If any member files are subdirectories, perhaps they should have their
        -: 3126:     contents listed rather than being mentioned here as files.  */
        -: 3127:
    #####: 3128:  if (recursive)
branch  0 never executed
branch  1 never executed
    #####: 3129:    extract_dirs_from_files (name, false);
call    0 never executed
        -: 3130:
    #####: 3131:  if (format == long_format || print_block_size)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3132:    {
        -: 3133:      char buf[LONGEST_HUMAN_READABLE + 3];
    #####: 3134:      char *p = human_readable (total_blocks, buf + 1, human_output_opts,
call    0 never executed
        -: 3135:                                ST_NBLOCKSIZE, output_block_size);
    #####: 3136:      char *pend = p + strlen (p);
    #####: 3137:      *--p = ' ';
    #####: 3138:      *pend++ = eolbyte;
    #####: 3139:      dired_indent ();
call    0 never executed
    #####: 3140:      dired_outstring (_("total"));
call    0 never executed
    #####: 3141:      dired_outbuf (p, pend - p);
call    0 never executed
        -: 3142:    }
        -: 3143:
    #####: 3144:  if (cwd_n_used)
branch  0 never executed
branch  1 never executed
    #####: 3145:    print_current_files ();
call    0 never executed
        -: 3146:}
        -: 3147:
        -: 3148:/* Add 'pattern' to the list of patterns for which files that match are
        -: 3149:   not listed.  */
        -: 3150:
        -: 3151:static void
function add_ignore_pattern called 0 returned 0% blocks executed 0%
    #####: 3152:add_ignore_pattern (char const *pattern)
        -: 3153:{
        -: 3154:  struct ignore_pattern *ignore;
        -: 3155:
    #####: 3156:  ignore = xmalloc (sizeof *ignore);
call    0 never executed
    #####: 3157:  ignore->pattern = pattern;
        -: 3158:  /* Add it to the head of the linked list.  */
    #####: 3159:  ignore->next = ignore_patterns;
    #####: 3160:  ignore_patterns = ignore;
    #####: 3161:}
        -: 3162:
        -: 3163:/* Return true if one of the PATTERNS matches FILE.  */
        -: 3164:
        -: 3165:static bool
function patterns_match called 0 returned 0% blocks executed 0%
    #####: 3166:patterns_match (struct ignore_pattern const *patterns, char const *file)
        -: 3167:{
        -: 3168:  struct ignore_pattern const *p;
    #####: 3169:  for (p = patterns; p; p = p->next)
branch  0 never executed
branch  1 never executed
    #####: 3170:    if (fnmatch (p->pattern, file, FNM_PERIOD) == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3171:      return true;
    #####: 3172:  return false;
        -: 3173:}
        -: 3174:
        -: 3175:/* Return true if FILE should be ignored.  */
        -: 3176:
        -: 3177:static bool
function file_ignored called 0 returned 0% blocks executed 0%
    #####: 3178:file_ignored (char const *name)
        -: 3179:{
    #####: 3180:  return ((ignore_mode != IGNORE_MINIMAL
    #####: 3181:           && name[0] == '.'
branch  0 never executed
branch  1 never executed
    #####: 3182:           && (ignore_mode == IGNORE_DEFAULT || ! name[1 + (name[1] == '.')]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3183:          || (ignore_mode == IGNORE_DEFAULT
branch  0 never executed
branch  1 never executed
    #####: 3184:              && patterns_match (hide_patterns, name))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3185:          || patterns_match (ignore_patterns, name));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 3186:}
        -: 3187:
        -: 3188:/* POSIX requires that a file size be printed without a sign, even
        -: 3189:   when negative.  Assume the typical case where negative sizes are
        -: 3190:   actually positive values that have wrapped around.  */
        -: 3191:
        -: 3192:static uintmax_t
function unsigned_file_size called 0 returned 0% blocks executed 0%
    #####: 3193:unsigned_file_size (off_t size)
        -: 3194:{
    #####: 3195:  return size + (size < 0) * ((uintmax_t) OFF_T_MAX - OFF_T_MIN + 1);
        -: 3196:}
        -: 3197:
        -: 3198:#ifdef HAVE_CAP
        -: 3199:/* Return true if NAME has a capability (see linux/capability.h) */
        -: 3200:static bool
        -: 3201:has_capability (char const *name)
        -: 3202:{
        -: 3203:  char *result;
        -: 3204:  bool has_cap;
        -: 3205:
        -: 3206:  cap_t cap_d = cap_get_file (name);
        -: 3207:  if (cap_d == nullptr)
        -: 3208:    return false;
        -: 3209:
        -: 3210:  result = cap_to_text (cap_d, nullptr);
        -: 3211:  cap_free (cap_d);
        -: 3212:  if (!result)
        -: 3213:    return false;
        -: 3214:
        -: 3215:  /* check if human-readable capability string is empty */
        -: 3216:  has_cap = !!*result;
        -: 3217:
        -: 3218:  cap_free (result);
        -: 3219:  return has_cap;
        -: 3220:}
        -: 3221:#else
        -: 3222:static bool
function has_capability called 0 returned 0% blocks executed 0%
    #####: 3223:has_capability (MAYBE_UNUSED char const *name)
        -: 3224:{
    #####: 3225:  errno = ENOTSUP;
    #####: 3226:  return false;
        -: 3227:}
        -: 3228:#endif
        -: 3229:
        -: 3230:/* Enter and remove entries in the table 'cwd_file'.  */
        -: 3231:
        -: 3232:static void
function free_ent called 0 returned 0% blocks executed 0%
    #####: 3233:free_ent (struct fileinfo *f)
        -: 3234:{
    #####: 3235:  free (f->name);
    #####: 3236:  free (f->linkname);
    #####: 3237:  free (f->absolute_name);
    #####: 3238:  if (f->scontext != UNKNOWN_SECURITY_CONTEXT)
branch  0 never executed
branch  1 never executed
        -: 3239:    {
    #####: 3240:      if (is_smack_enabled ())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3241:        free (f->scontext);
        -: 3242:      else
    #####: 3243:        freecon (f->scontext);
call    0 never executed
        -: 3244:    }
    #####: 3245:}
        -: 3246:
        -: 3247:/* Empty the table of files.  */
        -: 3248:static void
function clear_files called 1 returned 100% blocks executed 60%
        1: 3249:clear_files (void)
        -: 3250:{
       1*: 3251:  for (size_t i = 0; i < cwd_n_used; i++)
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
        -: 3252:    {
    #####: 3253:      struct fileinfo *f = sorted_file[i];
    #####: 3254:      free_ent (f);
call    0 never executed
        -: 3255:    }
        -: 3256:
        1: 3257:  cwd_n_used = 0;
        1: 3258:  cwd_some_quoted = false;
        1: 3259:  any_has_acl = false;
        1: 3260:  inode_number_width = 0;
        1: 3261:  block_size_width = 0;
        1: 3262:  nlink_width = 0;
        1: 3263:  owner_width = 0;
        1: 3264:  group_width = 0;
        1: 3265:  author_width = 0;
        1: 3266:  scontext_width = 0;
        1: 3267:  major_device_number_width = 0;
        1: 3268:  minor_device_number_width = 0;
        1: 3269:  file_size_width = 0;
        1: 3270:}
        -: 3271:
        -: 3272:/* Return true if ERR implies lack-of-support failure by a
        -: 3273:   getxattr-calling function like getfilecon or file_has_acl.  */
        -: 3274:static bool
function errno_unsupported called 0 returned 0% blocks executed 0%
    #####: 3275:errno_unsupported (int err)
        -: 3276:{
    #####: 3277:  return (err == EINVAL || err == ENOSYS || is_ENOTSUP (err));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -: 3278:}
        -: 3279:
        -: 3280:/* Cache *getfilecon failure, when it's trivial to do so.
        -: 3281:   Like getfilecon/lgetfilecon, but when F's st_dev says it's doesn't
        -: 3282:   support getting the security context, fail with ENOTSUP immediately.  */
        -: 3283:static int
function getfilecon_cache called 0 returned 0% blocks executed 0%
    #####: 3284:getfilecon_cache (char const *file, struct fileinfo *f, bool deref)
        -: 3285:{
        -: 3286:  /* st_dev of the most recently processed device for which we've
        -: 3287:     found that [l]getfilecon fails indicating lack of support.  */
        -: 3288:  static dev_t unsupported_device;
        -: 3289:
    #####: 3290:  if (f->stat.st_dev == unsupported_device)
branch  0 never executed
branch  1 never executed
        -: 3291:    {
    #####: 3292:      errno = ENOTSUP;
    #####: 3293:      return -1;
        -: 3294:    }
    #####: 3295:  int r = 0;
        -: 3296:#ifdef HAVE_SMACK
        -: 3297:  if (is_smack_enabled ())
        -: 3298:    r = smack_new_label_from_path (file, "security.SMACK64", deref,
        -: 3299:                                   &f->scontext);
        -: 3300:  else
        -: 3301:#endif
    #####: 3302:    r = (deref
    #####: 3303:         ? getfilecon (file, &f->scontext)
call    0 never executed
    #####: 3304:         : lgetfilecon (file, &f->scontext));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 3305:  if (r < 0 && errno_unsupported (errno))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3306:    unsupported_device = f->stat.st_dev;
    #####: 3307:  return r;
        -: 3308:}
        -: 3309:
        -: 3310:/* Cache file_has_acl failure, when it's trivial to do.
        -: 3311:   Like file_has_acl, but when F's st_dev says it's on a file
        -: 3312:   system lacking ACL support, return 0 with ENOTSUP immediately.  */
        -: 3313:static int
function file_has_acl_cache called 0 returned 0% blocks executed 0%
    #####: 3314:file_has_acl_cache (char const *file, struct fileinfo *f)
        -: 3315:{
        -: 3316:  /* st_dev of the most recently processed device for which we've
        -: 3317:     found that file_has_acl fails indicating lack of support.  */
        -: 3318:  static dev_t unsupported_device;
        -: 3319:
    #####: 3320:  if (f->stat.st_dev == unsupported_device)
branch  0 never executed
branch  1 never executed
        -: 3321:    {
    #####: 3322:      errno = ENOTSUP;
    #####: 3323:      return 0;
        -: 3324:    }
        -: 3325:
        -: 3326:  /* Zero errno so that we can distinguish between two 0-returning cases:
        -: 3327:     "has-ACL-support, but only a default ACL" and "no ACL support". */
    #####: 3328:  errno = 0;
    #####: 3329:  int n = file_has_acl (file, &f->stat);
call    0 never executed
    #####: 3330:  if (n <= 0 && errno_unsupported (errno))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3331:    unsupported_device = f->stat.st_dev;
    #####: 3332:  return n;
        -: 3333:}
        -: 3334:
        -: 3335:/* Cache has_capability failure, when it's trivial to do.
        -: 3336:   Like has_capability, but when F's st_dev says it's on a file
        -: 3337:   system lacking capability support, return 0 with ENOTSUP immediately.  */
        -: 3338:static bool
function has_capability_cache called 0 returned 0% blocks executed 0%
    #####: 3339:has_capability_cache (char const *file, struct fileinfo *f)
        -: 3340:{
        -: 3341:  /* st_dev of the most recently processed device for which we've
        -: 3342:     found that has_capability fails indicating lack of support.  */
        -: 3343:  static dev_t unsupported_device;
        -: 3344:
    #####: 3345:  if (f->stat.st_dev == unsupported_device)
branch  0 never executed
branch  1 never executed
        -: 3346:    {
    #####: 3347:      errno = ENOTSUP;
    #####: 3348:      return 0;
        -: 3349:    }
        -: 3350:
    #####: 3351:  bool b = has_capability (file);
call    0 never executed
    #####: 3352:  if ( !b && errno_unsupported (errno))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3353:    unsupported_device = f->stat.st_dev;
    #####: 3354:  return b;
        -: 3355:}
        -: 3356:
        -: 3357:static bool
function needs_quoting called 1 returned 100% blocks executed 71%
        1: 3358:needs_quoting (char const *name)
        -: 3359:{
        -: 3360:  char test[2];
        1: 3361:  size_t len = quotearg_buffer (test, sizeof test , name, -1,
call    0 returned 100%
        -: 3362:                                filename_quoting_options);
       1*: 3363:  return *name != *test || strlen (name) != len;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        -: 3364:}
        -: 3365:
        -: 3366:/* Add a file to the current table of files.
        -: 3367:   Verify that the file exists, and print an error message if it does not.
        -: 3368:   Return the number of blocks that the file occupies.  */
        -: 3369:static uintmax_t
function gobble_file called 1 returned 100% blocks executed 15%
        1: 3370:gobble_file (char const *name, enum filetype type, ino_t inode,
        -: 3371:             bool command_line_arg, char const *dirname)
        -: 3372:{
        1: 3373:  uintmax_t blocks = 0;
        -: 3374:  struct fileinfo *f;
        -: 3375:
        -: 3376:  /* An inode value prior to gobble_file necessarily came from readdir,
        -: 3377:     which is not used for command line arguments.  */
       1*: 3378:  affirm (! command_line_arg || inode == NOT_AN_INODE_NUMBER);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -: 3379:
        1: 3380:  if (cwd_n_used == cwd_n_alloc)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3381:    {
    #####: 3382:      cwd_file = xnrealloc (cwd_file, cwd_n_alloc, 2 * sizeof *cwd_file);
call    0 never executed
    #####: 3383:      cwd_n_alloc *= 2;
        -: 3384:    }
        -: 3385:
        1: 3386:  f = &cwd_file[cwd_n_used];
        1: 3387:  memset (f, '\0', sizeof *f);
        1: 3388:  f->stat.st_ino = inode;
        1: 3389:  f->filetype = type;
        -: 3390:
        1: 3391:  f->quoted = -1;
        1: 3392:  if ((! cwd_some_quoted) && align_variable_outer_quotes)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -: 3393:    {
        -: 3394:      /* Determine if any quoted for padding purposes.  */
        1: 3395:      f->quoted = needs_quoting (name);
call    0 returned 100%
        1: 3396:      if (f->quoted)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 3397:        cwd_some_quoted = 1;
        -: 3398:    }
        -: 3399:
        1: 3400:  if (command_line_arg
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3401:      || print_hyperlink
branch  0 never executed
branch  1 never executed
    #####: 3402:      || format_needs_stat
branch  0 never executed
branch  1 never executed
        -: 3403:      /* When coloring a directory (we may know the type from
        -: 3404:         direct.d_type), we have to stat it in order to indicate
        -: 3405:         sticky and/or other-writable attributes.  */
    #####: 3406:      || (type == directory && print_with_color
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3407:          && (is_colored (C_OTHER_WRITABLE)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3408:              || is_colored (C_STICKY)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3409:              || is_colored (C_STICKY_OTHER_WRITABLE)))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3410:      /* When dereferencing symlinks, the inode and type must come from
        -: 3411:         stat, but readdir provides the inode and type of lstat.  */
    #####: 3412:      || ((print_inode || format_needs_type)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3413:          && (type == symbolic_link || type == unknown)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3414:          && (dereference == DEREF_ALWAYS
branch  0 never executed
branch  1 never executed
    #####: 3415:              || color_symlink_as_referent || check_symlink_mode))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3416:      /* Command line dereferences are already taken care of by the above
        -: 3417:         assertion that the inode number is not yet known.  */
    #####: 3418:      || (print_inode && inode == NOT_AN_INODE_NUMBER)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3419:      || (format_needs_type
branch  0 never executed
branch  1 never executed
    #####: 3420:          && (type == unknown || command_line_arg
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3421:              /* --indicator-style=classify (aka -F)
        -: 3422:                 requires that we stat each regular file
        -: 3423:                 to see if it's executable.  */
    #####: 3424:              || (type == normal && (indicator_style == classify
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3425:                                     /* This is so that --color ends up
        -: 3426:                                        highlighting files with these mode
        -: 3427:                                        bits set even when options like -F are
        -: 3428:                                        not specified.  Note we do a redundant
        -: 3429:                                        stat in the very unlikely case where
        -: 3430:                                        C_CAP is set but not the others. */
    #####: 3431:                                     || (print_with_color
branch  0 never executed
branch  1 never executed
    #####: 3432:                                         && (is_colored (C_EXEC)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3433:                                             || is_colored (C_SETUID)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3434:                                             || is_colored (C_SETGID)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3435:                                             || is_colored (C_CAP)))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3436:                                     )))))
        -: 3437:
        -: 3438:    {
        -: 3439:      /* Absolute name of this file.  */
        -: 3440:      char *full_name;
        -: 3441:      bool do_deref;
        -: 3442:      int err;
        -: 3443:
        1: 3444:      if (name[0] == '/' || dirname[0] == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1: 3445:        full_name = (char *) name;
        -: 3446:      else
        -: 3447:        {
    #####: 3448:          full_name = alloca (strlen (name) + strlen (dirname) + 2);
    #####: 3449:          attach (full_name, dirname, name);
call    0 never executed
        -: 3450:        }
        -: 3451:
        1: 3452:      if (print_hyperlink)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3453:        {
    #####: 3454:          f->absolute_name = canonicalize_filename_mode (full_name,
call    0 never executed
        -: 3455:                                                         CAN_MISSING);
    #####: 3456:          if (! f->absolute_name)
branch  0 never executed
branch  1 never executed
    #####: 3457:            file_failure (command_line_arg,
call    0 never executed
        -: 3458:                          _("error canonicalizing %s"), full_name);
        -: 3459:        }
        -: 3460:
        1: 3461:      switch (dereference)
branch  0 taken 0%
branch  1 taken 100%
branch  2 taken 0%
        -: 3462:        {
    #####: 3463:        case DEREF_ALWAYS:
    #####: 3464:          err = do_stat (full_name, &f->stat);
call    0 never executed
    #####: 3465:          do_deref = true;
    #####: 3466:          break;
        -: 3467:
        1: 3468:        case DEREF_COMMAND_LINE_ARGUMENTS:
        -: 3469:        case DEREF_COMMAND_LINE_SYMLINK_TO_DIR:
        1: 3470:          if (command_line_arg)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 3471:            {
        -: 3472:              bool need_lstat;
        1: 3473:              err = do_stat (full_name, &f->stat);
call    0 returned 100%
        1: 3474:              do_deref = true;
        -: 3475:
        1: 3476:              if (dereference == DEREF_COMMAND_LINE_ARGUMENTS)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3477:                break;
        -: 3478:
        1: 3479:              need_lstat = (err < 0
       1*: 3480:                            ? (errno == ENOENT || errno == ELOOP)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
       2*: 3481:                            : ! S_ISDIR (f->stat.st_mode));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 3482:              if (!need_lstat)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3483:                break;
        -: 3484:
        -: 3485:              /* stat failed because of ENOENT || ELOOP, maybe indicating a
        -: 3486:                 non-traversable symlink.  Or stat succeeded,
        -: 3487:                 FULL_NAME does not refer to a directory,
        -: 3488:                 and --dereference-command-line-symlink-to-dir is in effect.
        -: 3489:                 Fall through so that we call lstat instead.  */
        -: 3490:            }
        -: 3491:          FALLTHROUGH;
        -: 3492:
        -: 3493:        default: /* DEREF_NEVER */
        1: 3494:          err = do_lstat (full_name, &f->stat);
call    0 returned 100%
        1: 3495:          do_deref = false;
        1: 3496:          break;
        -: 3497:        }
        -: 3498:
        1: 3499:      if (err != 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 3500:        {
        -: 3501:          /* Failure to stat a command line argument leads to
        -: 3502:             an exit status of 2.  For other files, stat failure
        -: 3503:             provokes an exit status of 1.  */
        1: 3504:          file_failure (command_line_arg,
call    0 returned 100%
        -: 3505:                        _("cannot access %s"), full_name);
        -: 3506:
        1: 3507:          f->scontext = UNKNOWN_SECURITY_CONTEXT;
        -: 3508:
        1: 3509:          if (command_line_arg)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 3510:            return 0;
        -: 3511:
    #####: 3512:          f->name = xstrdup (name);
call    0 never executed
    #####: 3513:          cwd_n_used++;
        -: 3514:
    #####: 3515:          return 0;
        -: 3516:        }
        -: 3517:
    #####: 3518:      f->stat_ok = true;
        -: 3519:
        -: 3520:      /* Note has_capability() adds around 30% runtime to 'ls --color'  */
    #####: 3521:      if ((type == normal || S_ISREG (f->stat.st_mode))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3522:          && print_with_color && is_colored (C_CAP))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3523:        f->has_capability = has_capability_cache (full_name, f);
call    0 never executed
        -: 3524:
    #####: 3525:      if (format == long_format || print_scontext)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3526:        {
    #####: 3527:          bool have_scontext = false;
    #####: 3528:          bool have_acl = false;
    #####: 3529:          int attr_len = getfilecon_cache (full_name, f, do_deref);
call    0 never executed
    #####: 3530:          err = (attr_len < 0);
        -: 3531:
    #####: 3532:          if (err == 0)
branch  0 never executed
branch  1 never executed
        -: 3533:            {
    #####: 3534:              if (is_smack_enabled ())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3535:                have_scontext = ! STREQ ("_", f->scontext);
        -: 3536:              else
    #####: 3537:                have_scontext = ! STREQ ("unlabeled", f->scontext);
        -: 3538:            }
        -: 3539:          else
        -: 3540:            {
    #####: 3541:              f->scontext = UNKNOWN_SECURITY_CONTEXT;
        -: 3542:
        -: 3543:              /* When requesting security context information, don't make
        -: 3544:                 ls fail just because the file (even a command line argument)
        -: 3545:                 isn't on the right type of file system.  I.e., a getfilecon
        -: 3546:                 failure isn't in the same class as a stat failure.  */
    #####: 3547:              if (is_ENOTSUP (errno) || errno == ENODATA)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3548:                err = 0;
        -: 3549:            }
        -: 3550:
    #####: 3551:          if (err == 0 && format == long_format)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3552:            {
    #####: 3553:              int n = file_has_acl_cache (full_name, f);
call    0 never executed
    #####: 3554:              err = (n < 0);
    #####: 3555:              have_acl = (0 < n);
        -: 3556:            }
        -: 3557:
    #####: 3558:          f->acl_type = (!have_scontext && !have_acl
branch  0 never executed
branch  1 never executed
        -: 3559:                         ? ACL_T_NONE
    #####: 3560:                         : (have_scontext && !have_acl
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 3561:                            ? ACL_T_LSM_CONTEXT_ONLY
        -: 3562:                            : ACL_T_YES));
    #####: 3563:          any_has_acl |= f->acl_type != ACL_T_NONE;
        -: 3564:
    #####: 3565:          if (err)
branch  0 never executed
branch  1 never executed
    #####: 3566:            error (0, errno, "%s", quotef (full_name));
call    0 never executed
        -: 3567:        }
        -: 3568:
    #####: 3569:      if (S_ISLNK (f->stat.st_mode)
branch  0 never executed
branch  1 never executed
    #####: 3570:          && (format == long_format || check_symlink_mode))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3571:        {
        -: 3572:          struct stat linkstats;
        -: 3573:
    #####: 3574:          get_link_name (full_name, f, command_line_arg);
call    0 never executed
        -: 3575:
        -: 3576:          /* Use the slower quoting path for this entry, though
        -: 3577:             don't update CWD_SOME_QUOTED since alignment not affected.  */
    #####: 3578:          if (f->linkname && f->quoted == 0 && needs_quoting (f->linkname))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####: 3579:            f->quoted = -1;
        -: 3580:
        -: 3581:          /* Avoid following symbolic links when possible, i.e., when
        -: 3582:             they won't be traced and when no indicator is needed.  */
    #####: 3583:          if (f->linkname
branch  0 never executed
branch  1 never executed
    #####: 3584:              && (file_type <= indicator_style || check_symlink_mode)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3585:              && stat_for_mode (full_name, &linkstats) == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3586:            {
    #####: 3587:              f->linkok = true;
    #####: 3588:              f->linkmode = linkstats.st_mode;
        -: 3589:            }
        -: 3590:        }
        -: 3591:
    #####: 3592:      if (S_ISLNK (f->stat.st_mode))
branch  0 never executed
branch  1 never executed
    #####: 3593:        f->filetype = symbolic_link;
    #####: 3594:      else if (S_ISDIR (f->stat.st_mode))
branch  0 never executed
branch  1 never executed
        -: 3595:        {
    #####: 3596:          if (command_line_arg && !immediate_dirs)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3597:            f->filetype = arg_directory;
        -: 3598:          else
    #####: 3599:            f->filetype = directory;
        -: 3600:        }
        -: 3601:      else
    #####: 3602:        f->filetype = normal;
        -: 3603:
    #####: 3604:      blocks = ST_NBLOCKS (f->stat);
    #####: 3605:      if (format == long_format || print_block_size)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3606:        {
        -: 3607:          char buf[LONGEST_HUMAN_READABLE + 1];
    #####: 3608:          int len = mbswidth (human_readable (blocks, buf, human_output_opts,
call    0 never executed
call    1 never executed
        -: 3609:                                              ST_NBLOCKSIZE, output_block_size),
        -: 3610:                              0);
    #####: 3611:          if (block_size_width < len)
branch  0 never executed
branch  1 never executed
    #####: 3612:            block_size_width = len;
        -: 3613:        }
        -: 3614:
    #####: 3615:      if (format == long_format)
branch  0 never executed
branch  1 never executed
        -: 3616:        {
    #####: 3617:          if (print_owner)
branch  0 never executed
branch  1 never executed
        -: 3618:            {
    #####: 3619:              int len = format_user_width (f->stat.st_uid);
call    0 never executed
    #####: 3620:              if (owner_width < len)
branch  0 never executed
branch  1 never executed
    #####: 3621:                owner_width = len;
        -: 3622:            }
        -: 3623:
    #####: 3624:          if (print_group)
branch  0 never executed
branch  1 never executed
        -: 3625:            {
    #####: 3626:              int len = format_group_width (f->stat.st_gid);
call    0 never executed
    #####: 3627:              if (group_width < len)
branch  0 never executed
branch  1 never executed
    #####: 3628:                group_width = len;
        -: 3629:            }
        -: 3630:
    #####: 3631:          if (print_author)
branch  0 never executed
branch  1 never executed
        -: 3632:            {
    #####: 3633:              int len = format_user_width (f->stat.st_author);
call    0 never executed
    #####: 3634:              if (author_width < len)
branch  0 never executed
branch  1 never executed
    #####: 3635:                author_width = len;
        -: 3636:            }
        -: 3637:        }
        -: 3638:
    #####: 3639:      if (print_scontext)
branch  0 never executed
branch  1 never executed
        -: 3640:        {
    #####: 3641:          int len = strlen (f->scontext);
    #####: 3642:          if (scontext_width < len)
branch  0 never executed
branch  1 never executed
    #####: 3643:            scontext_width = len;
        -: 3644:        }
        -: 3645:
    #####: 3646:      if (format == long_format)
branch  0 never executed
branch  1 never executed
        -: 3647:        {
        -: 3648:          char b[INT_BUFSIZE_BOUND (uintmax_t)];
    #####: 3649:          int b_len = strlen (umaxtostr (f->stat.st_nlink, b));
call    0 never executed
    #####: 3650:          if (nlink_width < b_len)
branch  0 never executed
branch  1 never executed
    #####: 3651:            nlink_width = b_len;
        -: 3652:
    #####: 3653:          if (S_ISCHR (f->stat.st_mode) || S_ISBLK (f->stat.st_mode))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3654:            {
        -: 3655:              char buf[INT_BUFSIZE_BOUND (uintmax_t)];
    #####: 3656:              int len = strlen (umaxtostr (major (f->stat.st_rdev), buf));
call    0 never executed
    #####: 3657:              if (major_device_number_width < len)
branch  0 never executed
branch  1 never executed
    #####: 3658:                major_device_number_width = len;
    #####: 3659:              len = strlen (umaxtostr (minor (f->stat.st_rdev), buf));
call    0 never executed
    #####: 3660:              if (minor_device_number_width < len)
branch  0 never executed
branch  1 never executed
    #####: 3661:                minor_device_number_width = len;
    #####: 3662:              len = major_device_number_width + 2 + minor_device_number_width;
    #####: 3663:              if (file_size_width < len)
branch  0 never executed
branch  1 never executed
    #####: 3664:                file_size_width = len;
        -: 3665:            }
        -: 3666:          else
        -: 3667:            {
        -: 3668:              char buf[LONGEST_HUMAN_READABLE + 1];
    #####: 3669:              uintmax_t size = unsigned_file_size (f->stat.st_size);
call    0 never executed
    #####: 3670:              int len = mbswidth (human_readable (size, buf,
call    0 never executed
call    1 never executed
        -: 3671:                                                  file_human_output_opts,
        -: 3672:                                                  1, file_output_block_size),
        -: 3673:                                  0);
    #####: 3674:              if (file_size_width < len)
branch  0 never executed
branch  1 never executed
    #####: 3675:                file_size_width = len;
        -: 3676:            }
        -: 3677:        }
        -: 3678:    }
        -: 3679:
    #####: 3680:  if (print_inode)
branch  0 never executed
branch  1 never executed
        -: 3681:    {
        -: 3682:      char buf[INT_BUFSIZE_BOUND (uintmax_t)];
    #####: 3683:      int len = strlen (umaxtostr (f->stat.st_ino, buf));
call    0 never executed
    #####: 3684:      if (inode_number_width < len)
branch  0 never executed
branch  1 never executed
    #####: 3685:        inode_number_width = len;
        -: 3686:    }
        -: 3687:
    #####: 3688:  f->name = xstrdup (name);
call    0 never executed
    #####: 3689:  cwd_n_used++;
        -: 3690:
    #####: 3691:  return blocks;
        -: 3692:}
        -: 3693:
        -: 3694:/* Return true if F refers to a directory.  */
        -: 3695:static bool
function is_directory called 0 returned 0% blocks executed 0%
    #####: 3696:is_directory (const struct fileinfo *f)
        -: 3697:{
    #####: 3698:  return f->filetype == directory || f->filetype == arg_directory;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3699:}
        -: 3700:
        -: 3701:/* Return true if F refers to a (symlinked) directory.  */
        -: 3702:static bool
function is_linked_directory called 0 returned 0% blocks executed 0%
    #####: 3703:is_linked_directory (const struct fileinfo *f)
        -: 3704:{
    #####: 3705:  return f->filetype == directory || f->filetype == arg_directory
branch  0 never executed
branch  1 never executed
    #####: 3706:         || S_ISDIR (f->linkmode);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3707:}
        -: 3708:
        -: 3709:/* Put the name of the file that FILENAME is a symbolic link to
        -: 3710:   into the LINKNAME field of 'f'.  COMMAND_LINE_ARG indicates whether
        -: 3711:   FILENAME is a command-line argument.  */
        -: 3712:
        -: 3713:static void
function get_link_name called 0 returned 0% blocks executed 0%
    #####: 3714:get_link_name (char const *filename, struct fileinfo *f, bool command_line_arg)
        -: 3715:{
    #####: 3716:  f->linkname = areadlink_with_size (filename, f->stat.st_size);
call    0 never executed
    #####: 3717:  if (f->linkname == nullptr)
branch  0 never executed
branch  1 never executed
    #####: 3718:    file_failure (command_line_arg, _("cannot read symbolic link %s"),
call    0 never executed
        -: 3719:                  filename);
    #####: 3720:}
        -: 3721:
        -: 3722:/* Return true if the last component of NAME is '.' or '..'
        -: 3723:   This is so we don't try to recurse on '././././. ...' */
        -: 3724:
        -: 3725:static bool
function basename_is_dot_or_dotdot called 0 returned 0% blocks executed 0%
    #####: 3726:basename_is_dot_or_dotdot (char const *name)
        -: 3727:{
    #####: 3728:  char const *base = last_component (name);
    #####: 3729:  return dot_or_dotdot (base);
call    0 never executed
        -: 3730:}
        -: 3731:
        -: 3732:/* Remove any entries from CWD_FILE that are for directories,
        -: 3733:   and queue them to be listed as directories instead.
        -: 3734:   DIRNAME is the prefix to prepend to each dirname
        -: 3735:   to make it correct relative to ls's working dir;
        -: 3736:   if it is null, no prefix is needed and "." and ".." should not be ignored.
        -: 3737:   If COMMAND_LINE_ARG is true, this directory was mentioned at the top level,
        -: 3738:   This is desirable when processing directories recursively.  */
        -: 3739:
        -: 3740:static void
function extract_dirs_from_files called 0 returned 0% blocks executed 0%
    #####: 3741:extract_dirs_from_files (char const *dirname, bool command_line_arg)
        -: 3742:{
        -: 3743:  size_t i;
        -: 3744:  size_t j;
    #####: 3745:  bool ignore_dot_and_dot_dot = (dirname != nullptr);
        -: 3746:
    #####: 3747:  if (dirname && LOOP_DETECT)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3748:    {
        -: 3749:      /* Insert a marker entry first.  When we dequeue this marker entry,
        -: 3750:         we'll know that DIRNAME has been processed and may be removed
        -: 3751:         from the set of active directories.  */
    #####: 3752:      queue_directory (nullptr, dirname, false);
call    0 never executed
        -: 3753:    }
        -: 3754:
        -: 3755:  /* Queue the directories last one first, because queueing reverses the
        -: 3756:     order.  */
    #####: 3757:  for (i = cwd_n_used; i-- != 0; )
branch  0 never executed
branch  1 never executed
        -: 3758:    {
    #####: 3759:      struct fileinfo *f = sorted_file[i];
        -: 3760:
    #####: 3761:      if (is_directory (f)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3762:          && (! ignore_dot_and_dot_dot
branch  0 never executed
branch  1 never executed
    #####: 3763:              || ! basename_is_dot_or_dotdot (f->name)))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3764:        {
    #####: 3765:          if (!dirname || f->name[0] == '/')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3766:            queue_directory (f->name, f->linkname, command_line_arg);
call    0 never executed
        -: 3767:          else
        -: 3768:            {
    #####: 3769:              char *name = file_name_concat (dirname, f->name, nullptr);
call    0 never executed
    #####: 3770:              queue_directory (name, f->linkname, command_line_arg);
call    0 never executed
    #####: 3771:              free (name);
        -: 3772:            }
    #####: 3773:          if (f->filetype == arg_directory)
branch  0 never executed
branch  1 never executed
    #####: 3774:            free_ent (f);
call    0 never executed
        -: 3775:        }
        -: 3776:    }
        -: 3777:
        -: 3778:  /* Now delete the directories from the table, compacting all the remaining
        -: 3779:     entries.  */
        -: 3780:
    #####: 3781:  for (i = 0, j = 0; i < cwd_n_used; i++)
branch  0 never executed
branch  1 never executed
        -: 3782:    {
    #####: 3783:      struct fileinfo *f = sorted_file[i];
    #####: 3784:      sorted_file[j] = f;
    #####: 3785:      j += (f->filetype != arg_directory);
        -: 3786:    }
    #####: 3787:  cwd_n_used = j;
    #####: 3788:}
        -: 3789:
        -: 3790:/* Use strcoll to compare strings in this locale.  If an error occurs,
        -: 3791:   report an error and longjmp to failed_strcoll.  */
        -: 3792:
        -: 3793:static jmp_buf failed_strcoll;
        -: 3794:
        -: 3795:static int
function xstrcoll called 0 returned 0% blocks executed 0%
    #####: 3796:xstrcoll (char const *a, char const *b)
        -: 3797:{
        -: 3798:  int diff;
    #####: 3799:  errno = 0;
    #####: 3800:  diff = strcoll (a, b);
    #####: 3801:  if (errno)
branch  0 never executed
branch  1 never executed
        -: 3802:    {
    #####: 3803:      error (0, errno, _("cannot compare file names %s and %s"),
call    0 never executed
call    1 never executed
        -: 3804:             quote_n (0, a), quote_n (1, b));
    #####: 3805:      set_exit_status (false);
call    0 never executed
    #####: 3806:      longjmp (failed_strcoll, 1);
call    0 never executed
        -: 3807:    }
    #####: 3808:  return diff;
        -: 3809:}
        -: 3810:
        -: 3811:/* Comparison routines for sorting the files.  */
        -: 3812:
        -: 3813:typedef void const *V;
        -: 3814:typedef int (*qsortFunc)(V a, V b);
        -: 3815:
        -: 3816:/* Used below in DEFINE_SORT_FUNCTIONS for _df_ sort function variants.  */
        -: 3817:static int
function dirfirst_check called 0 returned 0% blocks executed 0%
    #####: 3818:dirfirst_check (struct fileinfo const *a, struct fileinfo const *b,
        -: 3819:                int (*cmp) (V, V))
        -: 3820:{
    #####: 3821:  int diff = is_linked_directory (b) - is_linked_directory (a);
call    0 never executed
call    1 never executed
    #####: 3822:  return diff ? diff : cmp (a, b);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3823:}
        -: 3824:
        -: 3825:/* Define the 8 different sort function variants required for each sortkey.
        -: 3826:   KEY_NAME is a token describing the sort key, e.g., ctime, atime, size.
        -: 3827:   KEY_CMP_FUNC is a function to compare records based on that key, e.g.,
        -: 3828:   ctime_cmp, atime_cmp, size_cmp.  Append KEY_NAME to the string,
        -: 3829:   '[rev_][x]str{cmp|coll}[_df]_', to create each function name.  */
        -: 3830:#define DEFINE_SORT_FUNCTIONS(key_name, key_cmp_func)			\
        -: 3831:  /* direct, non-dirfirst versions */					\
        -: 3832:  static int xstrcoll_##key_name (V a, V b)				\
        -: 3833:  { return key_cmp_func (a, b, xstrcoll); }				\
        -: 3834:  ATTRIBUTE_PURE static int strcmp_##key_name (V a, V b)		\
        -: 3835:  { return key_cmp_func (a, b, strcmp); }				\
        -: 3836:                                                                        \
        -: 3837:  /* reverse, non-dirfirst versions */					\
        -: 3838:  static int rev_xstrcoll_##key_name (V a, V b)				\
        -: 3839:  { return key_cmp_func (b, a, xstrcoll); }				\
        -: 3840:  ATTRIBUTE_PURE static int rev_strcmp_##key_name (V a, V b)	\
        -: 3841:  { return key_cmp_func (b, a, strcmp); }				\
        -: 3842:                                                                        \
        -: 3843:  /* direct, dirfirst versions */					\
        -: 3844:  static int xstrcoll_df_##key_name (V a, V b)				\
        -: 3845:  { return dirfirst_check (a, b, xstrcoll_##key_name); }		\
        -: 3846:  ATTRIBUTE_PURE static int strcmp_df_##key_name (V a, V b)		\
        -: 3847:  { return dirfirst_check (a, b, strcmp_##key_name); }			\
        -: 3848:                                                                        \
        -: 3849:  /* reverse, dirfirst versions */					\
        -: 3850:  static int rev_xstrcoll_df_##key_name (V a, V b)			\
        -: 3851:  { return dirfirst_check (a, b, rev_xstrcoll_##key_name); }		\
        -: 3852:  ATTRIBUTE_PURE static int rev_strcmp_df_##key_name (V a, V b)	\
        -: 3853:  { return dirfirst_check (a, b, rev_strcmp_##key_name); }
        -: 3854:
        -: 3855:static int
function cmp_ctime called 0 returned 0% blocks executed 0%
    #####: 3856:cmp_ctime (struct fileinfo const *a, struct fileinfo const *b,
        -: 3857:           int (*cmp) (char const *, char const *))
        -: 3858:{
    #####: 3859:  int diff = timespec_cmp (get_stat_ctime (&b->stat),
        -: 3860:                           get_stat_ctime (&a->stat));
    #####: 3861:  return diff ? diff : cmp (a->name, b->name);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3862:}
        -: 3863:
        -: 3864:static int
function cmp_mtime called 0 returned 0% blocks executed 0%
    #####: 3865:cmp_mtime (struct fileinfo const *a, struct fileinfo const *b,
        -: 3866:           int (*cmp) (char const *, char const *))
        -: 3867:{
    #####: 3868:  int diff = timespec_cmp (get_stat_mtime (&b->stat),
        -: 3869:                           get_stat_mtime (&a->stat));
    #####: 3870:  return diff ? diff : cmp (a->name, b->name);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3871:}
        -: 3872:
        -: 3873:static int
function cmp_atime called 0 returned 0% blocks executed 0%
    #####: 3874:cmp_atime (struct fileinfo const *a, struct fileinfo const *b,
        -: 3875:           int (*cmp) (char const *, char const *))
        -: 3876:{
    #####: 3877:  int diff = timespec_cmp (get_stat_atime (&b->stat),
        -: 3878:                           get_stat_atime (&a->stat));
    #####: 3879:  return diff ? diff : cmp (a->name, b->name);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3880:}
        -: 3881:
        -: 3882:static int
function cmp_btime called 0 returned 0% blocks executed 0%
    #####: 3883:cmp_btime (struct fileinfo const *a, struct fileinfo const *b,
        -: 3884:           int (*cmp) (char const *, char const *))
        -: 3885:{
    #####: 3886:  int diff = timespec_cmp (get_stat_btime (&b->stat),
call    0 never executed
call    1 never executed
        -: 3887:                           get_stat_btime (&a->stat));
    #####: 3888:  return diff ? diff : cmp (a->name, b->name);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3889:}
        -: 3890:
        -: 3891:static int
function off_cmp called 0 returned 0% blocks executed 0%
    #####: 3892:off_cmp (off_t a, off_t b)
        -: 3893:{
    #####: 3894:  return (a > b) - (a < b);
        -: 3895:}
        -: 3896:
        -: 3897:static int
function cmp_size called 0 returned 0% blocks executed 0%
    #####: 3898:cmp_size (struct fileinfo const *a, struct fileinfo const *b,
        -: 3899:          int (*cmp) (char const *, char const *))
        -: 3900:{
    #####: 3901:  int diff = off_cmp (b->stat.st_size, a->stat.st_size);
call    0 never executed
    #####: 3902:  return diff ? diff : cmp (a->name, b->name);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3903:}
        -: 3904:
        -: 3905:static int
function cmp_name called 0 returned 0% blocks executed 0%
    #####: 3906:cmp_name (struct fileinfo const *a, struct fileinfo const *b,
        -: 3907:          int (*cmp) (char const *, char const *))
        -: 3908:{
    #####: 3909:  return cmp (a->name, b->name);
call    0 never executed
        -: 3910:}
        -: 3911:
        -: 3912:/* Compare file extensions.  Files with no extension are 'smallest'.
        -: 3913:   If extensions are the same, compare by file names instead.  */
        -: 3914:
        -: 3915:static int
function cmp_extension called 0 returned 0% blocks executed 0%
    #####: 3916:cmp_extension (struct fileinfo const *a, struct fileinfo const *b,
        -: 3917:               int (*cmp) (char const *, char const *))
        -: 3918:{
    #####: 3919:  char const *base1 = strrchr (a->name, '.');
    #####: 3920:  char const *base2 = strrchr (b->name, '.');
    #####: 3921:  int diff = cmp (base1 ? base1 : "", base2 ? base2 : "");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 3922:  return diff ? diff : cmp (a->name, b->name);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3923:}
        -: 3924:
        -: 3925:/* Return the (cached) screen width,
        -: 3926:   for the NAME associated with the passed fileinfo F.  */
        -: 3927:
        -: 3928:static size_t
function fileinfo_name_width called 0 returned 0% blocks executed 0%
    #####: 3929:fileinfo_name_width (struct fileinfo const *f)
        -: 3930:{
    #####: 3931:  return f->width
        -: 3932:         ? f->width
    #####: 3933:         : quote_name_width (f->name, filename_quoting_options, f->quoted);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3934:}
        -: 3935:
        -: 3936:static int
function cmp_width called 0 returned 0% blocks executed 0%
    #####: 3937:cmp_width (struct fileinfo const *a, struct fileinfo const *b,
        -: 3938:          int (*cmp) (char const *, char const *))
        -: 3939:{
    #####: 3940:  int diff = fileinfo_name_width (a) - fileinfo_name_width (b);
call    0 never executed
call    1 never executed
    #####: 3941:  return diff ? diff : cmp (a->name, b->name);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3942:}
        -: 3943:
    #####: 3944:DEFINE_SORT_FUNCTIONS (ctime, cmp_ctime)
------------------
rev_strcmp_df_ctime:
function rev_strcmp_df_ctime called 0 returned 0% blocks executed 0%
    #####: 3944:DEFINE_SORT_FUNCTIONS (ctime, cmp_ctime)
call    0 never executed
------------------
rev_xstrcoll_df_ctime:
function rev_xstrcoll_df_ctime called 0 returned 0% blocks executed 0%
    #####: 3944:DEFINE_SORT_FUNCTIONS (ctime, cmp_ctime)
call    0 never executed
------------------
strcmp_df_ctime:
function strcmp_df_ctime called 0 returned 0% blocks executed 0%
    #####: 3944:DEFINE_SORT_FUNCTIONS (ctime, cmp_ctime)
call    0 never executed
------------------
xstrcoll_df_ctime:
function xstrcoll_df_ctime called 0 returned 0% blocks executed 0%
    #####: 3944:DEFINE_SORT_FUNCTIONS (ctime, cmp_ctime)
call    0 never executed
------------------
rev_strcmp_ctime:
function rev_strcmp_ctime called 0 returned 0% blocks executed 0%
    #####: 3944:DEFINE_SORT_FUNCTIONS (ctime, cmp_ctime)
call    0 never executed
------------------
rev_xstrcoll_ctime:
function rev_xstrcoll_ctime called 0 returned 0% blocks executed 0%
    #####: 3944:DEFINE_SORT_FUNCTIONS (ctime, cmp_ctime)
call    0 never executed
------------------
strcmp_ctime:
function strcmp_ctime called 0 returned 0% blocks executed 0%
    #####: 3944:DEFINE_SORT_FUNCTIONS (ctime, cmp_ctime)
call    0 never executed
------------------
xstrcoll_ctime:
function xstrcoll_ctime called 0 returned 0% blocks executed 0%
    #####: 3944:DEFINE_SORT_FUNCTIONS (ctime, cmp_ctime)
call    0 never executed
------------------
    #####: 3945:DEFINE_SORT_FUNCTIONS (mtime, cmp_mtime)
------------------
rev_strcmp_df_mtime:
function rev_strcmp_df_mtime called 0 returned 0% blocks executed 0%
    #####: 3945:DEFINE_SORT_FUNCTIONS (mtime, cmp_mtime)
call    0 never executed
------------------
rev_xstrcoll_df_mtime:
function rev_xstrcoll_df_mtime called 0 returned 0% blocks executed 0%
    #####: 3945:DEFINE_SORT_FUNCTIONS (mtime, cmp_mtime)
call    0 never executed
------------------
strcmp_df_mtime:
function strcmp_df_mtime called 0 returned 0% blocks executed 0%
    #####: 3945:DEFINE_SORT_FUNCTIONS (mtime, cmp_mtime)
call    0 never executed
------------------
xstrcoll_df_mtime:
function xstrcoll_df_mtime called 0 returned 0% blocks executed 0%
    #####: 3945:DEFINE_SORT_FUNCTIONS (mtime, cmp_mtime)
call    0 never executed
------------------
rev_strcmp_mtime:
function rev_strcmp_mtime called 0 returned 0% blocks executed 0%
    #####: 3945:DEFINE_SORT_FUNCTIONS (mtime, cmp_mtime)
call    0 never executed
------------------
rev_xstrcoll_mtime:
function rev_xstrcoll_mtime called 0 returned 0% blocks executed 0%
    #####: 3945:DEFINE_SORT_FUNCTIONS (mtime, cmp_mtime)
call    0 never executed
------------------
strcmp_mtime:
function strcmp_mtime called 0 returned 0% blocks executed 0%
    #####: 3945:DEFINE_SORT_FUNCTIONS (mtime, cmp_mtime)
call    0 never executed
------------------
xstrcoll_mtime:
function xstrcoll_mtime called 0 returned 0% blocks executed 0%
    #####: 3945:DEFINE_SORT_FUNCTIONS (mtime, cmp_mtime)
call    0 never executed
------------------
    #####: 3946:DEFINE_SORT_FUNCTIONS (atime, cmp_atime)
------------------
rev_strcmp_df_atime:
function rev_strcmp_df_atime called 0 returned 0% blocks executed 0%
    #####: 3946:DEFINE_SORT_FUNCTIONS (atime, cmp_atime)
call    0 never executed
------------------
rev_xstrcoll_df_atime:
function rev_xstrcoll_df_atime called 0 returned 0% blocks executed 0%
    #####: 3946:DEFINE_SORT_FUNCTIONS (atime, cmp_atime)
call    0 never executed
------------------
strcmp_df_atime:
function strcmp_df_atime called 0 returned 0% blocks executed 0%
    #####: 3946:DEFINE_SORT_FUNCTIONS (atime, cmp_atime)
call    0 never executed
------------------
xstrcoll_df_atime:
function xstrcoll_df_atime called 0 returned 0% blocks executed 0%
    #####: 3946:DEFINE_SORT_FUNCTIONS (atime, cmp_atime)
call    0 never executed
------------------
rev_strcmp_atime:
function rev_strcmp_atime called 0 returned 0% blocks executed 0%
    #####: 3946:DEFINE_SORT_FUNCTIONS (atime, cmp_atime)
call    0 never executed
------------------
rev_xstrcoll_atime:
function rev_xstrcoll_atime called 0 returned 0% blocks executed 0%
    #####: 3946:DEFINE_SORT_FUNCTIONS (atime, cmp_atime)
call    0 never executed
------------------
strcmp_atime:
function strcmp_atime called 0 returned 0% blocks executed 0%
    #####: 3946:DEFINE_SORT_FUNCTIONS (atime, cmp_atime)
call    0 never executed
------------------
xstrcoll_atime:
function xstrcoll_atime called 0 returned 0% blocks executed 0%
    #####: 3946:DEFINE_SORT_FUNCTIONS (atime, cmp_atime)
call    0 never executed
------------------
    #####: 3947:DEFINE_SORT_FUNCTIONS (btime, cmp_btime)
------------------
rev_strcmp_df_btime:
function rev_strcmp_df_btime called 0 returned 0% blocks executed 0%
    #####: 3947:DEFINE_SORT_FUNCTIONS (btime, cmp_btime)
call    0 never executed
------------------
rev_xstrcoll_df_btime:
function rev_xstrcoll_df_btime called 0 returned 0% blocks executed 0%
    #####: 3947:DEFINE_SORT_FUNCTIONS (btime, cmp_btime)
call    0 never executed
------------------
strcmp_df_btime:
function strcmp_df_btime called 0 returned 0% blocks executed 0%
    #####: 3947:DEFINE_SORT_FUNCTIONS (btime, cmp_btime)
call    0 never executed
------------------
xstrcoll_df_btime:
function xstrcoll_df_btime called 0 returned 0% blocks executed 0%
    #####: 3947:DEFINE_SORT_FUNCTIONS (btime, cmp_btime)
call    0 never executed
------------------
rev_strcmp_btime:
function rev_strcmp_btime called 0 returned 0% blocks executed 0%
    #####: 3947:DEFINE_SORT_FUNCTIONS (btime, cmp_btime)
call    0 never executed
------------------
rev_xstrcoll_btime:
function rev_xstrcoll_btime called 0 returned 0% blocks executed 0%
    #####: 3947:DEFINE_SORT_FUNCTIONS (btime, cmp_btime)
call    0 never executed
------------------
strcmp_btime:
function strcmp_btime called 0 returned 0% blocks executed 0%
    #####: 3947:DEFINE_SORT_FUNCTIONS (btime, cmp_btime)
call    0 never executed
------------------
xstrcoll_btime:
function xstrcoll_btime called 0 returned 0% blocks executed 0%
    #####: 3947:DEFINE_SORT_FUNCTIONS (btime, cmp_btime)
call    0 never executed
------------------
    #####: 3948:DEFINE_SORT_FUNCTIONS (size, cmp_size)
------------------
rev_strcmp_df_size:
function rev_strcmp_df_size called 0 returned 0% blocks executed 0%
    #####: 3948:DEFINE_SORT_FUNCTIONS (size, cmp_size)
call    0 never executed
------------------
rev_xstrcoll_df_size:
function rev_xstrcoll_df_size called 0 returned 0% blocks executed 0%
    #####: 3948:DEFINE_SORT_FUNCTIONS (size, cmp_size)
call    0 never executed
------------------
strcmp_df_size:
function strcmp_df_size called 0 returned 0% blocks executed 0%
    #####: 3948:DEFINE_SORT_FUNCTIONS (size, cmp_size)
call    0 never executed
------------------
xstrcoll_df_size:
function xstrcoll_df_size called 0 returned 0% blocks executed 0%
    #####: 3948:DEFINE_SORT_FUNCTIONS (size, cmp_size)
call    0 never executed
------------------
rev_strcmp_size:
function rev_strcmp_size called 0 returned 0% blocks executed 0%
    #####: 3948:DEFINE_SORT_FUNCTIONS (size, cmp_size)
call    0 never executed
------------------
rev_xstrcoll_size:
function rev_xstrcoll_size called 0 returned 0% blocks executed 0%
    #####: 3948:DEFINE_SORT_FUNCTIONS (size, cmp_size)
call    0 never executed
------------------
strcmp_size:
function strcmp_size called 0 returned 0% blocks executed 0%
    #####: 3948:DEFINE_SORT_FUNCTIONS (size, cmp_size)
call    0 never executed
------------------
xstrcoll_size:
function xstrcoll_size called 0 returned 0% blocks executed 0%
    #####: 3948:DEFINE_SORT_FUNCTIONS (size, cmp_size)
call    0 never executed
------------------
    #####: 3949:DEFINE_SORT_FUNCTIONS (name, cmp_name)
------------------
rev_strcmp_df_name:
function rev_strcmp_df_name called 0 returned 0% blocks executed 0%
    #####: 3949:DEFINE_SORT_FUNCTIONS (name, cmp_name)
call    0 never executed
------------------
rev_xstrcoll_df_name:
function rev_xstrcoll_df_name called 0 returned 0% blocks executed 0%
    #####: 3949:DEFINE_SORT_FUNCTIONS (name, cmp_name)
call    0 never executed
------------------
strcmp_df_name:
function strcmp_df_name called 0 returned 0% blocks executed 0%
    #####: 3949:DEFINE_SORT_FUNCTIONS (name, cmp_name)
call    0 never executed
------------------
xstrcoll_df_name:
function xstrcoll_df_name called 0 returned 0% blocks executed 0%
    #####: 3949:DEFINE_SORT_FUNCTIONS (name, cmp_name)
call    0 never executed
------------------
rev_strcmp_name:
function rev_strcmp_name called 0 returned 0% blocks executed 0%
    #####: 3949:DEFINE_SORT_FUNCTIONS (name, cmp_name)
call    0 never executed
------------------
rev_xstrcoll_name:
function rev_xstrcoll_name called 0 returned 0% blocks executed 0%
    #####: 3949:DEFINE_SORT_FUNCTIONS (name, cmp_name)
call    0 never executed
------------------
strcmp_name:
function strcmp_name called 0 returned 0% blocks executed 0%
    #####: 3949:DEFINE_SORT_FUNCTIONS (name, cmp_name)
call    0 never executed
------------------
xstrcoll_name:
function xstrcoll_name called 0 returned 0% blocks executed 0%
    #####: 3949:DEFINE_SORT_FUNCTIONS (name, cmp_name)
call    0 never executed
------------------
    #####: 3950:DEFINE_SORT_FUNCTIONS (extension, cmp_extension)
------------------
rev_strcmp_df_extension:
function rev_strcmp_df_extension called 0 returned 0% blocks executed 0%
    #####: 3950:DEFINE_SORT_FUNCTIONS (extension, cmp_extension)
call    0 never executed
------------------
rev_xstrcoll_df_extension:
function rev_xstrcoll_df_extension called 0 returned 0% blocks executed 0%
    #####: 3950:DEFINE_SORT_FUNCTIONS (extension, cmp_extension)
call    0 never executed
------------------
strcmp_df_extension:
function strcmp_df_extension called 0 returned 0% blocks executed 0%
    #####: 3950:DEFINE_SORT_FUNCTIONS (extension, cmp_extension)
call    0 never executed
------------------
xstrcoll_df_extension:
function xstrcoll_df_extension called 0 returned 0% blocks executed 0%
    #####: 3950:DEFINE_SORT_FUNCTIONS (extension, cmp_extension)
call    0 never executed
------------------
rev_strcmp_extension:
function rev_strcmp_extension called 0 returned 0% blocks executed 0%
    #####: 3950:DEFINE_SORT_FUNCTIONS (extension, cmp_extension)
call    0 never executed
------------------
rev_xstrcoll_extension:
function rev_xstrcoll_extension called 0 returned 0% blocks executed 0%
    #####: 3950:DEFINE_SORT_FUNCTIONS (extension, cmp_extension)
call    0 never executed
------------------
strcmp_extension:
function strcmp_extension called 0 returned 0% blocks executed 0%
    #####: 3950:DEFINE_SORT_FUNCTIONS (extension, cmp_extension)
call    0 never executed
------------------
xstrcoll_extension:
function xstrcoll_extension called 0 returned 0% blocks executed 0%
    #####: 3950:DEFINE_SORT_FUNCTIONS (extension, cmp_extension)
call    0 never executed
------------------
    #####: 3951:DEFINE_SORT_FUNCTIONS (width, cmp_width)
------------------
rev_strcmp_df_width:
function rev_strcmp_df_width called 0 returned 0% blocks executed 0%
    #####: 3951:DEFINE_SORT_FUNCTIONS (width, cmp_width)
call    0 never executed
------------------
rev_xstrcoll_df_width:
function rev_xstrcoll_df_width called 0 returned 0% blocks executed 0%
    #####: 3951:DEFINE_SORT_FUNCTIONS (width, cmp_width)
call    0 never executed
------------------
strcmp_df_width:
function strcmp_df_width called 0 returned 0% blocks executed 0%
    #####: 3951:DEFINE_SORT_FUNCTIONS (width, cmp_width)
call    0 never executed
------------------
xstrcoll_df_width:
function xstrcoll_df_width called 0 returned 0% blocks executed 0%
    #####: 3951:DEFINE_SORT_FUNCTIONS (width, cmp_width)
call    0 never executed
------------------
rev_strcmp_width:
function rev_strcmp_width called 0 returned 0% blocks executed 0%
    #####: 3951:DEFINE_SORT_FUNCTIONS (width, cmp_width)
call    0 never executed
------------------
rev_xstrcoll_width:
function rev_xstrcoll_width called 0 returned 0% blocks executed 0%
    #####: 3951:DEFINE_SORT_FUNCTIONS (width, cmp_width)
call    0 never executed
------------------
strcmp_width:
function strcmp_width called 0 returned 0% blocks executed 0%
    #####: 3951:DEFINE_SORT_FUNCTIONS (width, cmp_width)
call    0 never executed
------------------
xstrcoll_width:
function xstrcoll_width called 0 returned 0% blocks executed 0%
    #####: 3951:DEFINE_SORT_FUNCTIONS (width, cmp_width)
call    0 never executed
------------------
        -: 3952:
        -: 3953:/* Compare file versions.
        -: 3954:   Unlike the other compare functions, cmp_version does not fail
        -: 3955:   because filevercmp and strcmp do not fail; cmp_version uses strcmp
        -: 3956:   instead of xstrcoll because filevercmp is locale-independent so
        -: 3957:   strcmp is its appropriate secondary.
        -: 3958:
        -: 3959:   All the other sort options need xstrcoll and strcmp variants,
        -: 3960:   because they all use xstrcoll (either as the primary or secondary
        -: 3961:   sort key), and xstrcoll has the ability to do a longjmp if strcoll fails for
        -: 3962:   locale reasons.  */
        -: 3963:static int
function cmp_version called 0 returned 0% blocks executed 0%
    #####: 3964:cmp_version (struct fileinfo const *a, struct fileinfo const *b)
        -: 3965:{
    #####: 3966:  int diff = filevercmp (a->name, b->name);
    #####: 3967:  return diff ? diff : strcmp (a->name, b->name);
branch  0 never executed
branch  1 never executed
        -: 3968:}
        -: 3969:
        -: 3970:static int
function xstrcoll_version called 0 returned 0% blocks executed 0%
    #####: 3971:xstrcoll_version (V a, V b)
        -: 3972:{
    #####: 3973:  return cmp_version (a, b);
call    0 never executed
        -: 3974:}
        -: 3975:static int
function rev_xstrcoll_version called 0 returned 0% blocks executed 0%
    #####: 3976:rev_xstrcoll_version (V a, V b)
        -: 3977:{
    #####: 3978:  return cmp_version (b, a);
call    0 never executed
        -: 3979:}
        -: 3980:static int
function xstrcoll_df_version called 0 returned 0% blocks executed 0%
    #####: 3981:xstrcoll_df_version (V a, V b)
        -: 3982:{
    #####: 3983:  return dirfirst_check (a, b, xstrcoll_version);
call    0 never executed
        -: 3984:}
        -: 3985:static int
function rev_xstrcoll_df_version called 0 returned 0% blocks executed 0%
    #####: 3986:rev_xstrcoll_df_version (V a, V b)
        -: 3987:{
    #####: 3988:  return dirfirst_check (a, b, rev_xstrcoll_version);
call    0 never executed
        -: 3989:}
        -: 3990:
        -: 3991:
        -: 3992:/* We have 2^3 different variants for each sort-key function
        -: 3993:   (for 3 independent sort modes).
        -: 3994:   The function pointers stored in this array must be dereferenced as:
        -: 3995:
        -: 3996:    sort_variants[sort_key][use_strcmp][reverse][dirs_first]
        -: 3997:
        -: 3998:   Note that the order in which sort keys are listed in the function pointer
        -: 3999:   array below is defined by the order of the elements in the time_type and
        -: 4000:   sort_type enums!  */
        -: 4001:
        -: 4002:#define LIST_SORTFUNCTION_VARIANTS(key_name)                        \
        -: 4003:  {                                                                 \
        -: 4004:    {                                                               \
        -: 4005:      { xstrcoll_##key_name, xstrcoll_df_##key_name },              \
        -: 4006:      { rev_xstrcoll_##key_name, rev_xstrcoll_df_##key_name },      \
        -: 4007:    },                                                              \
        -: 4008:    {                                                               \
        -: 4009:      { strcmp_##key_name, strcmp_df_##key_name },                  \
        -: 4010:      { rev_strcmp_##key_name, rev_strcmp_df_##key_name },          \
        -: 4011:    }                                                               \
        -: 4012:  }
        -: 4013:
        -: 4014:static qsortFunc const sort_functions[][2][2][2] =
        -: 4015:  {
        -: 4016:    LIST_SORTFUNCTION_VARIANTS (name),
        -: 4017:    LIST_SORTFUNCTION_VARIANTS (extension),
        -: 4018:    LIST_SORTFUNCTION_VARIANTS (width),
        -: 4019:    LIST_SORTFUNCTION_VARIANTS (size),
        -: 4020:
        -: 4021:    {
        -: 4022:      {
        -: 4023:        { xstrcoll_version, xstrcoll_df_version },
        -: 4024:        { rev_xstrcoll_version, rev_xstrcoll_df_version },
        -: 4025:      },
        -: 4026:
        -: 4027:      /* We use nullptr for the strcmp variants of version comparison
        -: 4028:         since as explained in cmp_version definition, version comparison
        -: 4029:         does not rely on xstrcoll, so it will never longjmp, and never
        -: 4030:         need to try the strcmp fallback. */
        -: 4031:      {
        -: 4032:        { nullptr, nullptr },
        -: 4033:        { nullptr, nullptr },
        -: 4034:      }
        -: 4035:    },
        -: 4036:
        -: 4037:    /* last are time sort functions */
        -: 4038:    LIST_SORTFUNCTION_VARIANTS (mtime),
        -: 4039:    LIST_SORTFUNCTION_VARIANTS (ctime),
        -: 4040:    LIST_SORTFUNCTION_VARIANTS (atime),
        -: 4041:    LIST_SORTFUNCTION_VARIANTS (btime)
        -: 4042:  };
        -: 4043:
        -: 4044:/* The number of sort keys is calculated as the sum of
        -: 4045:     the number of elements in the sort_type enum (i.e., sort_numtypes)
        -: 4046:     -2 because neither sort_time nor sort_none use entries themselves
        -: 4047:     the number of elements in the time_type enum (i.e., time_numtypes)
        -: 4048:   This is because when sort_type==sort_time, we have up to
        -: 4049:   time_numtypes possible sort keys.
        -: 4050:
        -: 4051:   This line verifies at compile-time that the array of sort functions has been
        -: 4052:   initialized for all possible sort keys. */
        -: 4053:static_assert (ARRAY_CARDINALITY (sort_functions)
        -: 4054:               == sort_numtypes - 2 + time_numtypes);
        -: 4055:
        -: 4056:/* Set up SORTED_FILE to point to the in-use entries in CWD_FILE, in order.  */
        -: 4057:
        -: 4058:static void
function initialize_ordering_vector called 0 returned 0% blocks executed 0%
    #####: 4059:initialize_ordering_vector (void)
        -: 4060:{
    #####: 4061:  for (size_t i = 0; i < cwd_n_used; i++)
branch  0 never executed
branch  1 never executed
    #####: 4062:    sorted_file[i] = &cwd_file[i];
    #####: 4063:}
        -: 4064:
        -: 4065:/* Cache values based on attributes global to all files.  */
        -: 4066:
        -: 4067:static void
function update_current_files_info called 0 returned 0% blocks executed 0%
    #####: 4068:update_current_files_info (void)
        -: 4069:{
        -: 4070:  /* Cache screen width of name, if needed multiple times.  */
    #####: 4071:  if (sort_type == sort_width
branch  0 never executed
branch  1 never executed
    #####: 4072:      || (line_length && (format == many_per_line || format == horizontal)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 4073:    {
        -: 4074:      size_t i;
    #####: 4075:      for (i = 0; i < cwd_n_used; i++)
branch  0 never executed
branch  1 never executed
        -: 4076:        {
    #####: 4077:          struct fileinfo *f = sorted_file[i];
    #####: 4078:          f->width = fileinfo_name_width (f);
call    0 never executed
        -: 4079:        }
        -: 4080:    }
    #####: 4081:}
        -: 4082:
        -: 4083:/* Sort the files now in the table.  */
        -: 4084:
        -: 4085:static void
function sort_files called 0 returned 0% blocks executed 0%
    #####: 4086:sort_files (void)
        -: 4087:{
        -: 4088:  bool use_strcmp;
        -: 4089:
    #####: 4090:  if (sorted_file_alloc < cwd_n_used + cwd_n_used / 2)
branch  0 never executed
branch  1 never executed
        -: 4091:    {
    #####: 4092:      free (sorted_file);
    #####: 4093:      sorted_file = xnmalloc (cwd_n_used, 3 * sizeof *sorted_file);
call    0 never executed
    #####: 4094:      sorted_file_alloc = 3 * cwd_n_used;
        -: 4095:    }
        -: 4096:
    #####: 4097:  initialize_ordering_vector ();
call    0 never executed
        -: 4098:
    #####: 4099:  update_current_files_info ();
call    0 never executed
        -: 4100:
    #####: 4101:  if (sort_type == sort_none)
branch  0 never executed
branch  1 never executed
    #####: 4102:    return;
        -: 4103:
        -: 4104:  /* Try strcoll.  If it fails, fall back on strcmp.  We can't safely
        -: 4105:     ignore strcoll failures, as a failing strcoll might be a
        -: 4106:     comparison function that is not a total order, and if we ignored
        -: 4107:     the failure this might cause qsort to dump core.  */
        -: 4108:
    #####: 4109:  if (! setjmp (failed_strcoll))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4110:    use_strcmp = false;      /* strcoll() succeeded */
        -: 4111:  else
        -: 4112:    {
    #####: 4113:      use_strcmp = true;
    #####: 4114:      affirm (sort_type != sort_version);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4115:      initialize_ordering_vector ();
call    0 never executed
        -: 4116:    }
        -: 4117:
        -: 4118:  /* When sort_type == sort_time, use time_type as subindex.  */
    #####: 4119:  mpsort ((void const **) sorted_file, cwd_n_used,
    #####: 4120:          sort_functions[sort_type + (sort_type == sort_time ? time_type : 0)]
branch  0 never executed
branch  1 never executed
        -: 4121:                        [use_strcmp][sort_reverse]
    #####: 4122:                        [directories_first]);
call    0 never executed
        -: 4123:}
        -: 4124:
        -: 4125:/* List all the files now in the table.  */
        -: 4126:
        -: 4127:static void
function print_current_files called 0 returned 0% blocks executed 0%
    #####: 4128:print_current_files (void)
        -: 4129:{
        -: 4130:  size_t i;
        -: 4131:
    #####: 4132:  switch (format)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 4133:    {
    #####: 4134:    case one_per_line:
    #####: 4135:      for (i = 0; i < cwd_n_used; i++)
branch  0 never executed
branch  1 never executed
        -: 4136:        {
    #####: 4137:          print_file_name_and_frills (sorted_file[i], 0);
call    0 never executed
    #####: 4138:          putchar (eolbyte);
call    0 never executed
        -: 4139:        }
    #####: 4140:      break;
        -: 4141:
    #####: 4142:    case many_per_line:
    #####: 4143:      if (! line_length)
branch  0 never executed
branch  1 never executed
    #####: 4144:        print_with_separator (' ');
call    0 never executed
        -: 4145:      else
    #####: 4146:        print_many_per_line ();
call    0 never executed
    #####: 4147:      break;
        -: 4148:
    #####: 4149:    case horizontal:
    #####: 4150:      if (! line_length)
branch  0 never executed
branch  1 never executed
    #####: 4151:        print_with_separator (' ');
call    0 never executed
        -: 4152:      else
    #####: 4153:        print_horizontal ();
call    0 never executed
    #####: 4154:      break;
        -: 4155:
    #####: 4156:    case with_commas:
    #####: 4157:      print_with_separator (',');
call    0 never executed
    #####: 4158:      break;
        -: 4159:
    #####: 4160:    case long_format:
    #####: 4161:      for (i = 0; i < cwd_n_used; i++)
branch  0 never executed
branch  1 never executed
        -: 4162:        {
    #####: 4163:          set_normal_color ();
call    0 never executed
    #####: 4164:          print_long_format (sorted_file[i]);
call    0 never executed
    #####: 4165:          dired_outbyte (eolbyte);
call    0 never executed
        -: 4166:        }
    #####: 4167:      break;
        -: 4168:    }
    #####: 4169:}
        -: 4170:
        -: 4171:/* Replace the first %b with precomputed aligned month names.
        -: 4172:   Note on glibc-2.7 at least, this speeds up the whole 'ls -lU'
        -: 4173:   process by around 17%, compared to letting strftime() handle the %b.  */
        -: 4174:
        -: 4175:static size_t
function align_nstrftime called 0 returned 0% blocks executed 0%
    #####: 4176:align_nstrftime (char *buf, size_t size, bool recent, struct tm const *tm,
        -: 4177:                 timezone_t tz, int ns)
        -: 4178:{
    #####: 4179:  char const *nfmt = (use_abformat
    #####: 4180:                      ? abformat[recent][tm->tm_mon]
    #####: 4181:                      : long_time_format[recent]);
branch  0 never executed
branch  1 never executed
    #####: 4182:  return nstrftime (buf, size, nfmt, tm, tz, ns);
call    0 never executed
        -: 4183:}
        -: 4184:
        -: 4185:/* Return the expected number of columns in a long-format timestamp,
        -: 4186:   or zero if it cannot be calculated.  */
        -: 4187:
        -: 4188:static int
function long_time_expected_width called 0 returned 0% blocks executed 0%
    #####: 4189:long_time_expected_width (void)
        -: 4190:{
        -: 4191:  static int width = -1;
        -: 4192:
    #####: 4193:  if (width < 0)
branch  0 never executed
branch  1 never executed
        -: 4194:    {
    #####: 4195:      time_t epoch = 0;
        -: 4196:      struct tm tm;
        -: 4197:      char buf[TIME_STAMP_LEN_MAXIMUM + 1];
        -: 4198:
        -: 4199:      /* In case you're wondering if localtime_rz can fail with an input time_t
        -: 4200:         value of 0, let's just say it's very unlikely, but not inconceivable.
        -: 4201:         The TZ environment variable would have to specify a time zone that
        -: 4202:         is 2**31-1900 years or more ahead of UTC.  This could happen only on
        -: 4203:         a 64-bit system that blindly accepts e.g., TZ=UTC+20000000000000.
        -: 4204:         However, this is not possible with Solaris 10 or glibc-2.3.5, since
        -: 4205:         their implementations limit the offset to 167:59 and 24:00, resp.  */
    #####: 4206:      if (localtime_rz (localtz, &epoch, &tm))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 4207:        {
    #####: 4208:          size_t len = align_nstrftime (buf, sizeof buf, false,
call    0 never executed
        -: 4209:                                        &tm, localtz, 0);
    #####: 4210:          if (len != 0)
branch  0 never executed
branch  1 never executed
    #####: 4211:            width = mbsnwidth (buf, len, 0);
call    0 never executed
        -: 4212:        }
        -: 4213:
    #####: 4214:      if (width < 0)
branch  0 never executed
branch  1 never executed
    #####: 4215:        width = 0;
        -: 4216:    }
        -: 4217:
    #####: 4218:  return width;
        -: 4219:}
        -: 4220:
        -: 4221:/* Print the user or group name NAME, with numeric id ID, using a
        -: 4222:   print width of WIDTH columns.  */
        -: 4223:
        -: 4224:static void
function format_user_or_group called 0 returned 0% blocks executed 0%
    #####: 4225:format_user_or_group (char const *name, uintmax_t id, int width)
        -: 4226:{
    #####: 4227:  if (name)
branch  0 never executed
branch  1 never executed
        -: 4228:    {
    #####: 4229:      int width_gap = width - mbswidth (name, 0);
call    0 never executed
    #####: 4230:      int pad = MAX (0, width_gap);
    #####: 4231:      dired_outstring (name);
call    0 never executed
        -: 4232:
        -: 4233:      do
    #####: 4234:        dired_outbyte (' ');
call    0 never executed
    #####: 4235:      while (pad--);
branch  0 never executed
branch  1 never executed
        -: 4236:    }
        -: 4237:  else
    #####: 4238:    dired_pos += printf ("%*"PRIuMAX" ", width, id);
call    0 never executed
    #####: 4239:}
        -: 4240:
        -: 4241:/* Print the name or id of the user with id U, using a print width of
        -: 4242:   WIDTH.  */
        -: 4243:
        -: 4244:static void
function format_user called 0 returned 0% blocks executed 0%
    #####: 4245:format_user (uid_t u, int width, bool stat_ok)
        -: 4246:{
    #####: 4247:  format_user_or_group (! stat_ok ? "?" :
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4248:                        (numeric_ids ? nullptr : getuser (u)), u, width);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4249:}
        -: 4250:
        -: 4251:/* Likewise, for groups.  */
        -: 4252:
        -: 4253:static void
function format_group called 0 returned 0% blocks executed 0%
    #####: 4254:format_group (gid_t g, int width, bool stat_ok)
        -: 4255:{
    #####: 4256:  format_user_or_group (! stat_ok ? "?" :
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4257:                        (numeric_ids ? nullptr : getgroup (g)), g, width);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4258:}
        -: 4259:
        -: 4260:/* Return the number of columns that format_user_or_group will print.  */
        -: 4261:
        -: 4262:static int
function format_user_or_group_width called 0 returned 0% blocks executed 0%
    #####: 4263:format_user_or_group_width (char const *name, uintmax_t id)
        -: 4264:{
    #####: 4265:  if (name)
branch  0 never executed
branch  1 never executed
        -: 4266:    {
    #####: 4267:      int len = mbswidth (name, 0);
call    0 never executed
    #####: 4268:      return MAX (0, len);
        -: 4269:    }
        -: 4270:  else
    #####: 4271:    return snprintf (nullptr, 0, "%"PRIuMAX, id);
        -: 4272:}
        -: 4273:
        -: 4274:/* Return the number of columns that format_user will print.  */
        -: 4275:
        -: 4276:static int
function format_user_width called 0 returned 0% blocks executed 0%
    #####: 4277:format_user_width (uid_t u)
        -: 4278:{
    #####: 4279:  return format_user_or_group_width (numeric_ids ? nullptr : getuser (u), u);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -: 4280:}
        -: 4281:
        -: 4282:/* Likewise, for groups.  */
        -: 4283:
        -: 4284:static int
function format_group_width called 0 returned 0% blocks executed 0%
    #####: 4285:format_group_width (gid_t g)
        -: 4286:{
    #####: 4287:  return format_user_or_group_width (numeric_ids ? nullptr : getgroup (g), g);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -: 4288:}
        -: 4289:
        -: 4290:/* Return a pointer to a formatted version of F->stat.st_ino,
        -: 4291:   possibly using buffer, which must be at least
        -: 4292:   INT_BUFSIZE_BOUND (uintmax_t) bytes.  */
        -: 4293:static char *
function format_inode called 0 returned 0% blocks executed 0%
    #####: 4294:format_inode (char buf[INT_BUFSIZE_BOUND (uintmax_t)],
        -: 4295:              const struct fileinfo *f)
        -: 4296:{
    #####: 4297:  return (f->stat_ok && f->stat.st_ino != NOT_AN_INODE_NUMBER
branch  0 never executed
branch  1 never executed
    #####: 4298:          ? umaxtostr (f->stat.st_ino, buf)
call    0 never executed
    #####: 4299:          : (char *) "?");
branch  0 never executed
branch  1 never executed
        -: 4300:}
        -: 4301:
        -: 4302:/* Print information about F in long format.  */
        -: 4303:static void
function print_long_format called 0 returned 0% blocks executed 0%
    #####: 4304:print_long_format (const struct fileinfo *f)
        -: 4305:{
        -: 4306:  char modebuf[12];
        -: 4307:  char buf
        -: 4308:    [LONGEST_HUMAN_READABLE + 1		/* inode */
        -: 4309:     + LONGEST_HUMAN_READABLE + 1	/* size in blocks */
        -: 4310:     + sizeof (modebuf) - 1 + 1		/* mode string */
        -: 4311:     + INT_BUFSIZE_BOUND (uintmax_t)	/* st_nlink */
        -: 4312:     + LONGEST_HUMAN_READABLE + 2	/* major device number */
        -: 4313:     + LONGEST_HUMAN_READABLE + 1	/* minor device number */
        -: 4314:     + TIME_STAMP_LEN_MAXIMUM + 1	/* max length of time/date */
        -: 4315:     ];
        -: 4316:  size_t s;
        -: 4317:  char *p;
        -: 4318:  struct timespec when_timespec;
        -: 4319:  struct tm when_local;
    #####: 4320:  bool btime_ok = true;
        -: 4321:
        -: 4322:  /* Compute the mode string, except remove the trailing space if no
        -: 4323:     file in this directory has an ACL or security context.  */
    #####: 4324:  if (f->stat_ok)
branch  0 never executed
branch  1 never executed
    #####: 4325:    filemodestring (&f->stat, modebuf);
call    0 never executed
        -: 4326:  else
        -: 4327:    {
    #####: 4328:      modebuf[0] = filetype_letter[f->filetype];
    #####: 4329:      memset (modebuf + 1, '?', 10);
    #####: 4330:      modebuf[11] = '\0';
        -: 4331:    }
    #####: 4332:  if (! any_has_acl)
branch  0 never executed
branch  1 never executed
    #####: 4333:    modebuf[10] = '\0';
    #####: 4334:  else if (f->acl_type == ACL_T_LSM_CONTEXT_ONLY)
branch  0 never executed
branch  1 never executed
    #####: 4335:    modebuf[10] = '.';
    #####: 4336:  else if (f->acl_type == ACL_T_YES)
branch  0 never executed
branch  1 never executed
    #####: 4337:    modebuf[10] = '+';
        -: 4338:
    #####: 4339:  switch (time_type)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 4340:    {
    #####: 4341:    case time_ctime:
    #####: 4342:      when_timespec = get_stat_ctime (&f->stat);
    #####: 4343:      break;
    #####: 4344:    case time_mtime:
    #####: 4345:      when_timespec = get_stat_mtime (&f->stat);
    #####: 4346:      break;
    #####: 4347:    case time_atime:
    #####: 4348:      when_timespec = get_stat_atime (&f->stat);
    #####: 4349:      break;
    #####: 4350:    case time_btime:
    #####: 4351:      when_timespec = get_stat_btime (&f->stat);
call    0 never executed
    #####: 4352:      if (when_timespec.tv_sec == -1 && when_timespec.tv_nsec == -1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4353:        btime_ok = false;
    #####: 4354:      break;
    #####: 4355:    default:
    #####: 4356:      unreachable ();
call    0 never executed
        -: 4357:    }
        -: 4358:
    #####: 4359:  p = buf;
        -: 4360:
    #####: 4361:  if (print_inode)
branch  0 never executed
branch  1 never executed
        -: 4362:    {
        -: 4363:      char hbuf[INT_BUFSIZE_BOUND (uintmax_t)];
    #####: 4364:      p += sprintf (p, "%*s ", inode_number_width, format_inode (hbuf, f));
call    0 never executed
        -: 4365:    }
        -: 4366:
    #####: 4367:  if (print_block_size)
branch  0 never executed
branch  1 never executed
    #####: 4368:    {
        -: 4369:      char hbuf[LONGEST_HUMAN_READABLE + 1];
    #####: 4370:      char const *blocks =
    #####: 4371:        (! f->stat_ok
        -: 4372:         ? "?"
    #####: 4373:         : human_readable (ST_NBLOCKS (f->stat), hbuf, human_output_opts,
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 4374:                           ST_NBLOCKSIZE, output_block_size));
        -: 4375:      int pad;
    #####: 4376:      for (pad = block_size_width - mbswidth (blocks, 0); 0 < pad; pad--)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4377:        *p++ = ' ';
    #####: 4378:      while ((*p++ = *blocks++))
branch  0 never executed
branch  1 never executed
    #####: 4379:        continue;
    #####: 4380:      p[-1] = ' ';
        -: 4381:    }
        -: 4382:
        -: 4383:  /* The last byte of the mode string is the POSIX
        -: 4384:     "optional alternate access method flag".  */
        -: 4385:  {
        -: 4386:    char hbuf[INT_BUFSIZE_BOUND (uintmax_t)];
    #####: 4387:    p += sprintf (p, "%s %*s ", modebuf, nlink_width,
    #####: 4388:                  ! f->stat_ok ? "?" : umaxtostr (f->stat.st_nlink, hbuf));
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 4389:  }
        -: 4390:
    #####: 4391:  dired_indent ();
call    0 never executed
        -: 4392:
    #####: 4393:  if (print_owner || print_group || print_author || print_scontext)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 4394:    {
    #####: 4395:      dired_outbuf (buf, p - buf);
call    0 never executed
        -: 4396:
    #####: 4397:      if (print_owner)
branch  0 never executed
branch  1 never executed
    #####: 4398:        format_user (f->stat.st_uid, owner_width, f->stat_ok);
call    0 never executed
        -: 4399:
    #####: 4400:      if (print_group)
branch  0 never executed
branch  1 never executed
    #####: 4401:        format_group (f->stat.st_gid, group_width, f->stat_ok);
call    0 never executed
        -: 4402:
    #####: 4403:      if (print_author)
branch  0 never executed
branch  1 never executed
    #####: 4404:        format_user (f->stat.st_author, author_width, f->stat_ok);
call    0 never executed
        -: 4405:
    #####: 4406:      if (print_scontext)
branch  0 never executed
branch  1 never executed
    #####: 4407:        format_user_or_group (f->scontext, 0, scontext_width);
call    0 never executed
        -: 4408:
    #####: 4409:      p = buf;
        -: 4410:    }
        -: 4411:
    #####: 4412:  if (f->stat_ok
branch  0 never executed
branch  1 never executed
    #####: 4413:      && (S_ISCHR (f->stat.st_mode) || S_ISBLK (f->stat.st_mode)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4414:    {
        -: 4415:      char majorbuf[INT_BUFSIZE_BOUND (uintmax_t)];
        -: 4416:      char minorbuf[INT_BUFSIZE_BOUND (uintmax_t)];
    #####: 4417:      int blanks_width = (file_size_width
    #####: 4418:                          - (major_device_number_width + 2
    #####: 4419:                             + minor_device_number_width));
    #####: 4420:      p += sprintf (p, "%*s, %*s ",
    #####: 4421:                    major_device_number_width + MAX (0, blanks_width),
    #####: 4422:                    umaxtostr (major (f->stat.st_rdev), majorbuf),
call    0 never executed
        -: 4423:                    minor_device_number_width,
    #####: 4424:                    umaxtostr (minor (f->stat.st_rdev), minorbuf));
call    0 never executed
        -: 4425:    }
        -: 4426:  else
    #####: 4427:    {
        -: 4428:      char hbuf[LONGEST_HUMAN_READABLE + 1];
    #####: 4429:      char const *size =
    #####: 4430:        (! f->stat_ok
        -: 4431:         ? "?"
    #####: 4432:         : human_readable (unsigned_file_size (f->stat.st_size),
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -: 4433:                           hbuf, file_human_output_opts, 1,
        -: 4434:                           file_output_block_size));
        -: 4435:      int pad;
    #####: 4436:      for (pad = file_size_width - mbswidth (size, 0); 0 < pad; pad--)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4437:        *p++ = ' ';
    #####: 4438:      while ((*p++ = *size++))
branch  0 never executed
branch  1 never executed
    #####: 4439:        continue;
    #####: 4440:      p[-1] = ' ';
        -: 4441:    }
        -: 4442:
    #####: 4443:  s = 0;
    #####: 4444:  *p = '\1';
        -: 4445:
    #####: 4446:  if (f->stat_ok && btime_ok
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4447:      && localtime_rz (localtz, &when_timespec.tv_sec, &when_local))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 4448:    {
        -: 4449:      struct timespec six_months_ago;
        -: 4450:      bool recent;
        -: 4451:
        -: 4452:      /* If the file appears to be in the future, update the current
        -: 4453:         time, in case the file happens to have been modified since
        -: 4454:         the last time we checked the clock.  */
    #####: 4455:      if (timespec_cmp (current_time, when_timespec) < 0)
branch  0 never executed
branch  1 never executed
    #####: 4456:        gettime (&current_time);
call    0 never executed
        -: 4457:
        -: 4458:      /* Consider a time to be recent if it is within the past six months.
        -: 4459:         A Gregorian year has 365.2425 * 24 * 60 * 60 == 31556952 seconds
        -: 4460:         on the average.  Write this value as an integer constant to
        -: 4461:         avoid floating point hassles.  */
    #####: 4462:      six_months_ago.tv_sec = current_time.tv_sec - 31556952 / 2;
    #####: 4463:      six_months_ago.tv_nsec = current_time.tv_nsec;
        -: 4464:
    #####: 4465:      recent = (timespec_cmp (six_months_ago, when_timespec) < 0
    #####: 4466:                && timespec_cmp (when_timespec, current_time) < 0);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4467:
        -: 4468:      /* We assume here that all time zones are offset from UTC by a
        -: 4469:         whole number of seconds.  */
    #####: 4470:      s = align_nstrftime (p, TIME_STAMP_LEN_MAXIMUM + 1, recent,
    #####: 4471:                           &when_local, localtz, when_timespec.tv_nsec);
call    0 never executed
        -: 4472:    }
        -: 4473:
    #####: 4474:  if (s || !*p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4475:    {
    #####: 4476:      p += s;
    #####: 4477:      *p++ = ' ';
        -: 4478:    }
        -: 4479:  else
        -: 4480:    {
        -: 4481:      /* The time cannot be converted using the desired format, so
        -: 4482:         print it as a huge integer number of seconds.  */
        -: 4483:      char hbuf[INT_BUFSIZE_BOUND (intmax_t)];
    #####: 4484:      p += sprintf (p, "%*s ", long_time_expected_width (),
call    0 never executed
    #####: 4485:                    (! f->stat_ok || ! btime_ok
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4486:                     ? "?"
    #####: 4487:                     : timetostr (when_timespec.tv_sec, hbuf)));
call    0 never executed
        -: 4488:      /* FIXME: (maybe) We discarded when_timespec.tv_nsec. */
        -: 4489:    }
        -: 4490:
    #####: 4491:  dired_outbuf (buf, p - buf);
call    0 never executed
    #####: 4492:  size_t w = print_name_with_quoting (f, false, &dired_obstack, p - buf);
call    0 never executed
        -: 4493:
    #####: 4494:  if (f->filetype == symbolic_link)
branch  0 never executed
branch  1 never executed
        -: 4495:    {
    #####: 4496:      if (f->linkname)
branch  0 never executed
branch  1 never executed
        -: 4497:        {
    #####: 4498:          dired_outstring (" -> ");
call    0 never executed
    #####: 4499:          print_name_with_quoting (f, true, nullptr, (p - buf) + w + 4);
call    0 never executed
    #####: 4500:          if (indicator_style != none)
branch  0 never executed
branch  1 never executed
    #####: 4501:            print_type_indicator (true, f->linkmode, unknown);
call    0 never executed
        -: 4502:        }
        -: 4503:    }
    #####: 4504:  else if (indicator_style != none)
branch  0 never executed
branch  1 never executed
    #####: 4505:    print_type_indicator (f->stat_ok, f->stat.st_mode, f->filetype);
call    0 never executed
    #####: 4506:}
        -: 4507:
        -: 4508:/* Write to *BUF a quoted representation of the file name NAME, if non-null,
        -: 4509:   using OPTIONS to control quoting.  *BUF is set to NAME if no quoting
        -: 4510:   is required.  *BUF is allocated if more space required (and the original
        -: 4511:   *BUF is not deallocated).
        -: 4512:   Store the number of screen columns occupied by NAME's quoted
        -: 4513:   representation into WIDTH, if non-null.
        -: 4514:   Store into PAD whether an initial space is needed for padding.
        -: 4515:   Return the number of bytes in *BUF.  */
        -: 4516:
        -: 4517:static size_t
function quote_name_buf called 0 returned 0% blocks executed 0%
    #####: 4518:quote_name_buf (char **inbuf, size_t bufsize, char *name,
        -: 4519:                struct quoting_options const *options,
        -: 4520:                int needs_general_quoting, size_t *width, bool *pad)
        -: 4521:{
    #####: 4522:  char *buf = *inbuf;
        -: 4523:  size_t displayed_width IF_LINT ( = 0);
    #####: 4524:  size_t len = 0;
        -: 4525:  bool quoted;
        -: 4526:
    #####: 4527:  enum quoting_style qs = get_quoting_style (options);
call    0 never executed
    #####: 4528:  bool needs_further_quoting = qmark_funny_chars
    #####: 4529:                               && (qs == shell_quoting_style
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4530:                                   || qs == shell_always_quoting_style
branch  0 never executed
branch  1 never executed
    #####: 4531:                                   || qs == literal_quoting_style);
branch  0 never executed
branch  1 never executed
        -: 4532:
    #####: 4533:  if (needs_general_quoting != 0)
branch  0 never executed
branch  1 never executed
        -: 4534:    {
    #####: 4535:      len = quotearg_buffer (buf, bufsize, name, -1, options);
call    0 never executed
    #####: 4536:      if (bufsize <= len)
branch  0 never executed
branch  1 never executed
        -: 4537:        {
    #####: 4538:          buf = xmalloc (len + 1);
call    0 never executed
    #####: 4539:          quotearg_buffer (buf, len + 1, name, -1, options);
call    0 never executed
        -: 4540:        }
        -: 4541:
    #####: 4542:      quoted = (*name != *buf) || strlen (name) != len;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4543:    }
    #####: 4544:  else if (needs_further_quoting)
branch  0 never executed
branch  1 never executed
        -: 4545:    {
    #####: 4546:      len = strlen (name);
    #####: 4547:      if (bufsize <= len)
branch  0 never executed
branch  1 never executed
    #####: 4548:        buf = xmalloc (len + 1);
call    0 never executed
    #####: 4549:      memcpy (buf, name, len + 1);
        -: 4550:
    #####: 4551:      quoted = false;
        -: 4552:    }
        -: 4553:  else
        -: 4554:    {
    #####: 4555:      len = strlen (name);
    #####: 4556:      buf = name;
    #####: 4557:      quoted = false;
        -: 4558:    }
        -: 4559:
    #####: 4560:  if (needs_further_quoting)
branch  0 never executed
branch  1 never executed
        -: 4561:    {
    #####: 4562:      if (MB_CUR_MAX > 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 4563:        {
    #####: 4564:          char const *p = buf;
    #####: 4565:          char const *plimit = buf + len;
    #####: 4566:          char *q = buf;
    #####: 4567:          displayed_width = 0;
        -: 4568:
    #####: 4569:          while (p < plimit)
branch  0 never executed
branch  1 never executed
    #####: 4570:            switch (*p)
branch  0 never executed
branch  1 never executed
        -: 4571:              {
    #####: 4572:                case ' ': case '!': case '"': case '#': case '%':
        -: 4573:                case '&': case '\'': case '(': case ')': case '*':
        -: 4574:                case '+': case ',': case '-': case '.': case '/':
        -: 4575:                case '0': case '1': case '2': case '3': case '4':
        -: 4576:                case '5': case '6': case '7': case '8': case '9':
        -: 4577:                case ':': case ';': case '<': case '=': case '>':
        -: 4578:                case '?':
        -: 4579:                case 'A': case 'B': case 'C': case 'D': case 'E':
        -: 4580:                case 'F': case 'G': case 'H': case 'I': case 'J':
        -: 4581:                case 'K': case 'L': case 'M': case 'N': case 'O':
        -: 4582:                case 'P': case 'Q': case 'R': case 'S': case 'T':
        -: 4583:                case 'U': case 'V': case 'W': case 'X': case 'Y':
        -: 4584:                case 'Z':
        -: 4585:                case '[': case '\\': case ']': case '^': case '_':
        -: 4586:                case 'a': case 'b': case 'c': case 'd': case 'e':
        -: 4587:                case 'f': case 'g': case 'h': case 'i': case 'j':
        -: 4588:                case 'k': case 'l': case 'm': case 'n': case 'o':
        -: 4589:                case 'p': case 'q': case 'r': case 's': case 't':
        -: 4590:                case 'u': case 'v': case 'w': case 'x': case 'y':
        -: 4591:                case 'z': case '{': case '|': case '}': case '~':
        -: 4592:                  /* These characters are printable ASCII characters.  */
    #####: 4593:                  *q++ = *p++;
    #####: 4594:                  displayed_width += 1;
    #####: 4595:                  break;
    #####: 4596:                default:
        -: 4597:                  /* If we have a multibyte sequence, copy it until we
        -: 4598:                     reach its end, replacing each non-printable multibyte
        -: 4599:                     character with a single question mark.  */
        -: 4600:                  {
    #####: 4601:                    mbstate_t mbstate = { 0, };
        -: 4602:                    do
        -: 4603:                      {
        -: 4604:                        wchar_t wc;
        -: 4605:                        size_t bytes;
        -: 4606:                        int w;
        -: 4607:
    #####: 4608:                        bytes = mbrtowc (&wc, p, plimit - p, &mbstate);
call    0 never executed
        -: 4609:
    #####: 4610:                        if (bytes == (size_t) -1)
branch  0 never executed
branch  1 never executed
        -: 4611:                          {
        -: 4612:                            /* An invalid multibyte sequence was
        -: 4613:                               encountered.  Skip one input byte, and
        -: 4614:                               put a question mark.  */
    #####: 4615:                            p++;
    #####: 4616:                            *q++ = '?';
    #####: 4617:                            displayed_width += 1;
    #####: 4618:                            break;
        -: 4619:                          }
        -: 4620:
    #####: 4621:                        if (bytes == (size_t) -2)
branch  0 never executed
branch  1 never executed
        -: 4622:                          {
        -: 4623:                            /* An incomplete multibyte character
        -: 4624:                               at the end.  Replace it entirely with
        -: 4625:                               a question mark.  */
    #####: 4626:                            p = plimit;
    #####: 4627:                            *q++ = '?';
    #####: 4628:                            displayed_width += 1;
    #####: 4629:                            break;
        -: 4630:                          }
        -: 4631:
    #####: 4632:                        if (bytes == 0)
branch  0 never executed
branch  1 never executed
        -: 4633:                          /* A null wide character was encountered.  */
    #####: 4634:                          bytes = 1;
        -: 4635:
    #####: 4636:                        w = wcwidth (wc);
call    0 never executed
    #####: 4637:                        if (w >= 0)
branch  0 never executed
branch  1 never executed
        -: 4638:                          {
        -: 4639:                            /* A printable multibyte character.
        -: 4640:                               Keep it.  */
    #####: 4641:                            for (; bytes > 0; --bytes)
branch  0 never executed
branch  1 never executed
    #####: 4642:                              *q++ = *p++;
    #####: 4643:                            displayed_width += w;
        -: 4644:                          }
        -: 4645:                        else
        -: 4646:                          {
        -: 4647:                            /* An nonprintable multibyte character.
        -: 4648:                               Replace it entirely with a question
        -: 4649:                               mark.  */
    #####: 4650:                            p += bytes;
    #####: 4651:                            *q++ = '?';
    #####: 4652:                            displayed_width += 1;
        -: 4653:                          }
        -: 4654:                      }
    #####: 4655:                    while (! mbsinit (&mbstate));
branch  0 never executed
branch  1 never executed
        -: 4656:                  }
    #####: 4657:                  break;
        -: 4658:              }
        -: 4659:
        -: 4660:          /* The buffer may have shrunk.  */
    #####: 4661:          len = q - buf;
        -: 4662:        }
        -: 4663:      else
        -: 4664:        {
    #####: 4665:          char *p = buf;
    #####: 4666:          char const *plimit = buf + len;
        -: 4667:
    #####: 4668:          while (p < plimit)
branch  0 never executed
branch  1 never executed
        -: 4669:            {
    #####: 4670:              if (! isprint (to_uchar (*p)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4671:                *p = '?';
    #####: 4672:              p++;
        -: 4673:            }
    #####: 4674:          displayed_width = len;
        -: 4675:        }
        -: 4676:    }
    #####: 4677:  else if (width != nullptr)
branch  0 never executed
branch  1 never executed
        -: 4678:    {
    #####: 4679:      if (MB_CUR_MAX > 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4680:        displayed_width = mbsnwidth (buf, len, 0);
call    0 never executed
        -: 4681:      else
        -: 4682:        {
    #####: 4683:          char const *p = buf;
    #####: 4684:          char const *plimit = buf + len;
        -: 4685:
    #####: 4686:          displayed_width = 0;
    #####: 4687:          while (p < plimit)
branch  0 never executed
branch  1 never executed
        -: 4688:            {
    #####: 4689:              if (isprint (to_uchar (*p)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4690:                displayed_width++;
    #####: 4691:              p++;
        -: 4692:            }
        -: 4693:        }
        -: 4694:    }
        -: 4695:
        -: 4696:  /* Set padding to better align quoted items,
        -: 4697:     and also give a visual indication that quotes are
        -: 4698:     not actually part of the name.  */
    #####: 4699:  *pad = (align_variable_outer_quotes && cwd_some_quoted && ! quoted);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 4700:
    #####: 4701:  if (width != nullptr)
branch  0 never executed
branch  1 never executed
    #####: 4702:    *width = displayed_width;
        -: 4703:
    #####: 4704:  *inbuf = buf;
        -: 4705:
    #####: 4706:  return len;
        -: 4707:}
        -: 4708:
        -: 4709:static size_t
function quote_name_width called 0 returned 0% blocks executed 0%
    #####: 4710:quote_name_width (char const *name, struct quoting_options const *options,
        -: 4711:                  int needs_general_quoting)
        -: 4712:{
        -: 4713:  char smallbuf[BUFSIZ];
    #####: 4714:  char *buf = smallbuf;
        -: 4715:  size_t width;
        -: 4716:  bool pad;
        -: 4717:
    #####: 4718:  quote_name_buf (&buf, sizeof smallbuf, (char *) name, options,
call    0 never executed
        -: 4719:                  needs_general_quoting, &width, &pad);
        -: 4720:
    #####: 4721:  if (buf != smallbuf && buf != name)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4722:    free (buf);
        -: 4723:
    #####: 4724:  width += pad;
        -: 4725:
    #####: 4726:  return width;
        -: 4727:}
        -: 4728:
        -: 4729:/* %XX escape any input out of range as defined in RFC3986,
        -: 4730:   and also if PATH, convert all path separators to '/'.  */
        -: 4731:static char *
function file_escape called 0 returned 0% blocks executed 0%
    #####: 4732:file_escape (char const *str, bool path)
        -: 4733:{
    #####: 4734:  char *esc = xnmalloc (3, strlen (str) + 1);
call    0 never executed
    #####: 4735:  char *p = esc;
    #####: 4736:  while (*str)
branch  0 never executed
branch  1 never executed
        -: 4737:    {
    #####: 4738:      if (path && ISSLASH (*str))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4739:        {
    #####: 4740:          *p++ = '/';
    #####: 4741:          str++;
        -: 4742:        }
    #####: 4743:      else if (RFC3986[to_uchar (*str)])
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4744:        *p++ = *str++;
        -: 4745:      else
    #####: 4746:        p += sprintf (p, "%%%02x", to_uchar (*str++));
call    0 never executed
        -: 4747:    }
    #####: 4748:  *p = '\0';
    #####: 4749:  return esc;
        -: 4750:}
        -: 4751:
        -: 4752:static size_t
function quote_name called 0 returned 0% blocks executed 0%
    #####: 4753:quote_name (char const *name, struct quoting_options const *options,
        -: 4754:            int needs_general_quoting, const struct bin_str *color,
        -: 4755:            bool allow_pad, struct obstack *stack, char const *absolute_name)
        -: 4756:{
        -: 4757:  char smallbuf[BUFSIZ];
    #####: 4758:  char *buf = smallbuf;
        -: 4759:  size_t len;
        -: 4760:  bool pad;
        -: 4761:
    #####: 4762:  len = quote_name_buf (&buf, sizeof smallbuf, (char *) name, options,
call    0 never executed
        -: 4763:                        needs_general_quoting, nullptr, &pad);
        -: 4764:
    #####: 4765:  if (pad && allow_pad)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4766:    dired_outbyte (' ');
call    0 never executed
        -: 4767:
    #####: 4768:  if (color)
branch  0 never executed
branch  1 never executed
    #####: 4769:    print_color_indicator (color);
call    0 never executed
        -: 4770:
        -: 4771:  /* If we're padding, then don't include the outer quotes in
        -: 4772:     the --hyperlink, to improve the alignment of those links.  */
    #####: 4773:  bool skip_quotes = false;
        -: 4774:
    #####: 4775:  if (absolute_name)
branch  0 never executed
branch  1 never executed
        -: 4776:    {
    #####: 4777:      if (align_variable_outer_quotes && cwd_some_quoted && ! pad)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 4778:        {
    #####: 4779:          skip_quotes = true;
    #####: 4780:          putchar (*buf);
call    0 never executed
        -: 4781:        }
    #####: 4782:      char *h = file_escape (hostname, /* path= */ false);
call    0 never executed
    #####: 4783:      char *n = file_escape (absolute_name, /* path= */ true);
call    0 never executed
        -: 4784:      /* TODO: It would be good to be able to define parameters
        -: 4785:         to give hints to the terminal as how best to render the URI.
        -: 4786:         For example since ls is outputting a dense block of URIs
        -: 4787:         it would be best to not underline by default, and only
        -: 4788:         do so upon hover etc.  */
    #####: 4789:      printf ("\033]8;;file://%s%s%s\a", h, *n == '/' ? "" : "/", n);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4790:      free (h);
    #####: 4791:      free (n);
        -: 4792:    }
        -: 4793:
    #####: 4794:  if (stack)
branch  0 never executed
branch  1 never executed
    #####: 4795:    push_current_dired_pos (stack);
call    0 never executed
        -: 4796:
    #####: 4797:  fwrite (buf + skip_quotes, 1, len - (skip_quotes * 2), stdout);
call    0 never executed
        -: 4798:
    #####: 4799:  dired_pos += len;
        -: 4800:
    #####: 4801:  if (stack)
branch  0 never executed
branch  1 never executed
    #####: 4802:    push_current_dired_pos (stack);
call    0 never executed
        -: 4803:
    #####: 4804:  if (absolute_name)
branch  0 never executed
branch  1 never executed
        -: 4805:    {
    #####: 4806:      fputs ("\033]8;;\a", stdout);
call    0 never executed
    #####: 4807:      if (skip_quotes)
branch  0 never executed
branch  1 never executed
    #####: 4808:        putchar (*(buf + len - 1));
call    0 never executed
        -: 4809:    }
        -: 4810:
    #####: 4811:  if (buf != smallbuf && buf != name)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4812:    free (buf);
        -: 4813:
    #####: 4814:  return len + pad;
        -: 4815:}
        -: 4816:
        -: 4817:static size_t
function print_name_with_quoting called 0 returned 0% blocks executed 0%
    #####: 4818:print_name_with_quoting (const struct fileinfo *f,
        -: 4819:                         bool symlink_target,
        -: 4820:                         struct obstack *stack,
        -: 4821:                         size_t start_col)
        -: 4822:{
    #####: 4823:  char const *name = symlink_target ? f->linkname : f->name;
branch  0 never executed
branch  1 never executed
        -: 4824:
    #####: 4825:  const struct bin_str *color
    #####: 4826:    = print_with_color ? get_color_indicator (f, symlink_target) : nullptr;
branch  0 never executed
branch  1 never executed
        -: 4827:
    #####: 4828:  bool used_color_this_time = (print_with_color
    #####: 4829:                               && (color || is_colored (C_NORM)));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -: 4830:
    #####: 4831:  size_t len = quote_name (name, filename_quoting_options, f->quoted,
    #####: 4832:                           color, !symlink_target, stack, f->absolute_name);
call    0 never executed
        -: 4833:
    #####: 4834:  process_signals ();
call    0 never executed
    #####: 4835:  if (used_color_this_time)
branch  0 never executed
branch  1 never executed
        -: 4836:    {
    #####: 4837:      prep_non_filename_text ();
call    0 never executed
        -: 4838:
        -: 4839:      /* We use the byte length rather than display width here as
        -: 4840:         an optimization to avoid accurately calculating the width,
        -: 4841:         because we only output the clear to EOL sequence if the name
        -: 4842:         _might_ wrap to the next line.  This may output a sequence
        -: 4843:         unnecessarily in multi-byte locales for example,
        -: 4844:         but in that case it's inconsequential to the output.  */
    #####: 4845:      if (line_length
branch  0 never executed
branch  1 never executed
    #####: 4846:          && (start_col / line_length != (start_col + len - 1) / line_length))
branch  0 never executed
branch  1 never executed
    #####: 4847:        put_indicator (&color_indicator[C_CLR_TO_EOL]);
call    0 never executed
        -: 4848:    }
        -: 4849:
    #####: 4850:  return len;
        -: 4851:}
        -: 4852:
        -: 4853:static void
function prep_non_filename_text called 0 returned 0% blocks executed 0%
    #####: 4854:prep_non_filename_text (void)
        -: 4855:{
    #####: 4856:  if (color_indicator[C_END].string != nullptr)
branch  0 never executed
branch  1 never executed
    #####: 4857:    put_indicator (&color_indicator[C_END]);
call    0 never executed
        -: 4858:  else
        -: 4859:    {
    #####: 4860:      put_indicator (&color_indicator[C_LEFT]);
call    0 never executed
    #####: 4861:      put_indicator (&color_indicator[C_RESET]);
call    0 never executed
    #####: 4862:      put_indicator (&color_indicator[C_RIGHT]);
call    0 never executed
        -: 4863:    }
    #####: 4864:}
        -: 4865:
        -: 4866:/* Print the file name of 'f' with appropriate quoting.
        -: 4867:   Also print file size, inode number, and filetype indicator character,
        -: 4868:   as requested by switches.  */
        -: 4869:
        -: 4870:static size_t
function print_file_name_and_frills called 0 returned 0% blocks executed 0%
    #####: 4871:print_file_name_and_frills (const struct fileinfo *f, size_t start_col)
        -: 4872:{
        -: 4873:  char buf[MAX (LONGEST_HUMAN_READABLE + 1, INT_BUFSIZE_BOUND (uintmax_t))];
        -: 4874:
    #####: 4875:  set_normal_color ();
call    0 never executed
        -: 4876:
    #####: 4877:  if (print_inode)
branch  0 never executed
branch  1 never executed
    #####: 4878:    printf ("%*s ", format == with_commas ? 0 : inode_number_width,
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 4879:            format_inode (buf, f));
        -: 4880:
    #####: 4881:  if (print_block_size)
branch  0 never executed
branch  1 never executed
    #####: 4882:    printf ("%*s ", format == with_commas ? 0 : block_size_width,
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4883:            ! f->stat_ok ? "?"
branch  0 never executed
branch  1 never executed
    #####: 4884:            : human_readable (ST_NBLOCKS (f->stat), buf, human_output_opts,
call    0 never executed
        -: 4885:                              ST_NBLOCKSIZE, output_block_size));
        -: 4886:
    #####: 4887:  if (print_scontext)
branch  0 never executed
branch  1 never executed
    #####: 4888:    printf ("%*s ", format == with_commas ? 0 : scontext_width, f->scontext);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 4889:
    #####: 4890:  size_t width = print_name_with_quoting (f, false, nullptr, start_col);
call    0 never executed
        -: 4891:
    #####: 4892:  if (indicator_style != none)
branch  0 never executed
branch  1 never executed
    #####: 4893:    width += print_type_indicator (f->stat_ok, f->stat.st_mode, f->filetype);
call    0 never executed
        -: 4894:
    #####: 4895:  return width;
        -: 4896:}
        -: 4897:
        -: 4898:/* Given these arguments describing a file, return the single-byte
        -: 4899:   type indicator, or 0.  */
        -: 4900:static char
function get_type_indicator called 0 returned 0% blocks executed 0%
    #####: 4901:get_type_indicator (bool stat_ok, mode_t mode, enum filetype type)
        -: 4902:{
        -: 4903:  char c;
        -: 4904:
    #####: 4905:  if (stat_ok ? S_ISREG (mode) : type == normal)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4906:    {
    #####: 4907:      if (stat_ok && indicator_style == classify && (mode & S_IXUGO))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 4908:        c = '*';
        -: 4909:      else
    #####: 4910:        c = 0;
        -: 4911:    }
        -: 4912:  else
        -: 4913:    {
    #####: 4914:      if (stat_ok ? S_ISDIR (mode) : type == directory || type == arg_directory)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 4915:        c = '/';
    #####: 4916:      else if (indicator_style == slash)
branch  0 never executed
branch  1 never executed
    #####: 4917:        c = 0;
    #####: 4918:      else if (stat_ok ? S_ISLNK (mode) : type == symbolic_link)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4919:        c = '@';
    #####: 4920:      else if (stat_ok ? S_ISFIFO (mode) : type == fifo)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4921:        c = '|';
    #####: 4922:      else if (stat_ok ? S_ISSOCK (mode) : type == sock)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4923:        c = '=';
        -: 4924:      else if (stat_ok && S_ISDOOR (mode))
        -: 4925:        c = '>';
        -: 4926:      else
    #####: 4927:        c = 0;
        -: 4928:    }
    #####: 4929:  return c;
        -: 4930:}
        -: 4931:
        -: 4932:static bool
function print_type_indicator called 0 returned 0% blocks executed 0%
    #####: 4933:print_type_indicator (bool stat_ok, mode_t mode, enum filetype type)
        -: 4934:{
    #####: 4935:  char c = get_type_indicator (stat_ok, mode, type);
call    0 never executed
    #####: 4936:  if (c)
branch  0 never executed
branch  1 never executed
    #####: 4937:    dired_outbyte (c);
call    0 never executed
    #####: 4938:  return !!c;
        -: 4939:}
        -: 4940:
        -: 4941:/* Returns if color sequence was printed.  */
        -: 4942:static bool
function print_color_indicator called 0 returned 0% blocks executed 0%
    #####: 4943:print_color_indicator (const struct bin_str *ind)
        -: 4944:{
    #####: 4945:  if (ind)
branch  0 never executed
branch  1 never executed
        -: 4946:    {
        -: 4947:      /* Need to reset so not dealing with attribute combinations */
    #####: 4948:      if (is_colored (C_NORM))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4949:        restore_default_color ();
call    0 never executed
    #####: 4950:      put_indicator (&color_indicator[C_LEFT]);
call    0 never executed
    #####: 4951:      put_indicator (ind);
call    0 never executed
    #####: 4952:      put_indicator (&color_indicator[C_RIGHT]);
call    0 never executed
        -: 4953:    }
        -: 4954:
    #####: 4955:  return ind != nullptr;
        -: 4956:}
        -: 4957:
        -: 4958:/* Returns color indicator or nullptr if none.  */
        -: 4959:ATTRIBUTE_PURE
        -: 4960:static const struct bin_str*
function get_color_indicator called 0 returned 0% blocks executed 0%
    #####: 4961:get_color_indicator (const struct fileinfo *f, bool symlink_target)
        -: 4962:{
        -: 4963:  enum indicator_no type;
        -: 4964:  struct color_ext_type *ext;	/* Color extension */
        -: 4965:  size_t len;			/* Length of name */
        -: 4966:
        -: 4967:  char const *name;
        -: 4968:  mode_t mode;
        -: 4969:  int linkok;
    #####: 4970:  if (symlink_target)
branch  0 never executed
branch  1 never executed
        -: 4971:    {
    #####: 4972:      name = f->linkname;
    #####: 4973:      mode = f->linkmode;
    #####: 4974:      linkok = f->linkok ? 0 : -1;
branch  0 never executed
branch  1 never executed
        -: 4975:    }
        -: 4976:  else
        -: 4977:    {
    #####: 4978:      name = f->name;
    #####: 4979:      mode = file_or_link_mode (f);
call    0 never executed
    #####: 4980:      linkok = f->linkok;
        -: 4981:    }
        -: 4982:
        -: 4983:  /* Is this a nonexistent file?  If so, linkok == -1.  */
        -: 4984:
    #####: 4985:  if (linkok == -1 && is_colored (C_MISSING))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4986:    type = C_MISSING;
    #####: 4987:  else if (!f->stat_ok)
branch  0 never executed
branch  1 never executed
        -: 4988:    {
        -: 4989:      static enum indicator_no filetype_indicator[] = FILETYPE_INDICATORS;
    #####: 4990:      type = filetype_indicator[f->filetype];
        -: 4991:    }
        -: 4992:  else
        -: 4993:    {
    #####: 4994:      if (S_ISREG (mode))
branch  0 never executed
branch  1 never executed
        -: 4995:        {
    #####: 4996:          type = C_FILE;
        -: 4997:
    #####: 4998:          if ((mode & S_ISUID) != 0 && is_colored (C_SETUID))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4999:            type = C_SETUID;
    #####: 5000:          else if ((mode & S_ISGID) != 0 && is_colored (C_SETGID))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 5001:            type = C_SETGID;
    #####: 5002:          else if (is_colored (C_CAP) && f->has_capability)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 5003:            type = C_CAP;
    #####: 5004:          else if ((mode & S_IXUGO) != 0 && is_colored (C_EXEC))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 5005:            type = C_EXEC;
    #####: 5006:          else if ((1 < f->stat.st_nlink) && is_colored (C_MULTIHARDLINK))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 5007:            type = C_MULTIHARDLINK;
        -: 5008:        }
    #####: 5009:      else if (S_ISDIR (mode))
branch  0 never executed
branch  1 never executed
        -: 5010:        {
    #####: 5011:          type = C_DIR;
        -: 5012:
    #####: 5013:          if ((mode & S_ISVTX) && (mode & S_IWOTH)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5014:              && is_colored (C_STICKY_OTHER_WRITABLE))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5015:            type = C_STICKY_OTHER_WRITABLE;
    #####: 5016:          else if ((mode & S_IWOTH) != 0 && is_colored (C_OTHER_WRITABLE))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 5017:            type = C_OTHER_WRITABLE;
    #####: 5018:          else if ((mode & S_ISVTX) != 0 && is_colored (C_STICKY))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 5019:            type = C_STICKY;
        -: 5020:        }
    #####: 5021:      else if (S_ISLNK (mode))
branch  0 never executed
branch  1 never executed
    #####: 5022:        type = C_LINK;
    #####: 5023:      else if (S_ISFIFO (mode))
branch  0 never executed
branch  1 never executed
    #####: 5024:        type = C_FIFO;
    #####: 5025:      else if (S_ISSOCK (mode))
branch  0 never executed
branch  1 never executed
    #####: 5026:        type = C_SOCK;
    #####: 5027:      else if (S_ISBLK (mode))
branch  0 never executed
branch  1 never executed
    #####: 5028:        type = C_BLK;
    #####: 5029:      else if (S_ISCHR (mode))
branch  0 never executed
branch  1 never executed
    #####: 5030:        type = C_CHR;
        -: 5031:      else if (S_ISDOOR (mode))
        -: 5032:        type = C_DOOR;
        -: 5033:      else
        -: 5034:        {
        -: 5035:          /* Classify a file of some other type as C_ORPHAN.  */
    #####: 5036:          type = C_ORPHAN;
        -: 5037:        }
        -: 5038:    }
        -: 5039:
        -: 5040:  /* Check the file's suffix only if still classified as C_FILE.  */
    #####: 5041:  ext = nullptr;
    #####: 5042:  if (type == C_FILE)
branch  0 never executed
branch  1 never executed
        -: 5043:    {
        -: 5044:      /* Test if NAME has a recognized suffix.  */
        -: 5045:
    #####: 5046:      len = strlen (name);
    #####: 5047:      name += len;		/* Pointer to final \0.  */
    #####: 5048:      for (ext = color_ext_list; ext != nullptr; ext = ext->next)
branch  0 never executed
branch  1 never executed
        -: 5049:        {
    #####: 5050:          if (ext->ext.len <= len)
branch  0 never executed
branch  1 never executed
        -: 5051:            {
    #####: 5052:              if (ext->exact_match)
branch  0 never executed
branch  1 never executed
        -: 5053:                {
    #####: 5054:                  if (STREQ_LEN (name - ext->ext.len, ext->ext.string,
branch  0 never executed
branch  1 never executed
        -: 5055:                                 ext->ext.len))
    #####: 5056:                    break;
        -: 5057:                }
        -: 5058:              else
        -: 5059:                {
    #####: 5060:                  if (c_strncasecmp (name - ext->ext.len, ext->ext.string,
branch  0 never executed
branch  1 never executed
        -: 5061:                                     ext->ext.len) == 0)
    #####: 5062:                    break;
        -: 5063:                }
        -: 5064:            }
        -: 5065:        }
        -: 5066:    }
        -: 5067:
        -: 5068:  /* Adjust the color for orphaned symlinks.  */
    #####: 5069:  if (type == C_LINK && !linkok)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5070:    {
    #####: 5071:      if (color_symlink_as_referent || is_colored (C_ORPHAN))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 5072:        type = C_ORPHAN;
        -: 5073:    }
        -: 5074:
    #####: 5075:  const struct bin_str *const s
branch  0 never executed
branch  1 never executed
        -: 5076:    = ext ? &(ext->seq) : &color_indicator[type];
        -: 5077:
    #####: 5078:  return s->string ? s : nullptr;
branch  0 never executed
branch  1 never executed
        -: 5079:}
        -: 5080:
        -: 5081:/* Output a color indicator (which may contain nulls).  */
        -: 5082:static void
function put_indicator called 0 returned 0% blocks executed 0%
    #####: 5083:put_indicator (const struct bin_str *ind)
        -: 5084:{
    #####: 5085:  if (! used_color)
branch  0 never executed
branch  1 never executed
        -: 5086:    {
    #####: 5087:      used_color = true;
        -: 5088:
        -: 5089:      /* If the standard output is a controlling terminal, watch out
        -: 5090:         for signals, so that the colors can be restored to the
        -: 5091:         default state if "ls" is suspended or interrupted.  */
        -: 5092:
    #####: 5093:      if (0 <= tcgetpgrp (STDOUT_FILENO))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5094:        signal_init ();
call    0 never executed
        -: 5095:
    #####: 5096:      prep_non_filename_text ();
call    0 never executed
        -: 5097:    }
        -: 5098:
    #####: 5099:  fwrite (ind->string, ind->len, 1, stdout);
call    0 never executed
    #####: 5100:}
        -: 5101:
        -: 5102:static size_t
function length_of_file_name_and_frills called 0 returned 0% blocks executed 0%
    #####: 5103:length_of_file_name_and_frills (const struct fileinfo *f)
        -: 5104:{
    #####: 5105:  size_t len = 0;
        -: 5106:  char buf[MAX (LONGEST_HUMAN_READABLE + 1, INT_BUFSIZE_BOUND (uintmax_t))];
        -: 5107:
    #####: 5108:  if (print_inode)
branch  0 never executed
branch  1 never executed
    #####: 5109:    len += 1 + (format == with_commas
branch  0 never executed
branch  1 never executed
    #####: 5110:                ? strlen (umaxtostr (f->stat.st_ino, buf))
call    0 never executed
        -: 5111:                : inode_number_width);
        -: 5112:
    #####: 5113:  if (print_block_size)
branch  0 never executed
branch  1 never executed
    #####: 5114:    len += 1 + (format == with_commas
branch  0 never executed
branch  1 never executed
    #####: 5115:                ? strlen (! f->stat_ok ? "?"
branch  0 never executed
branch  1 never executed
    #####: 5116:                          : human_readable (ST_NBLOCKS (f->stat), buf,
call    0 never executed
        -: 5117:                                            human_output_opts, ST_NBLOCKSIZE,
        -: 5118:                                            output_block_size))
        -: 5119:                : block_size_width);
        -: 5120:
    #####: 5121:  if (print_scontext)
branch  0 never executed
branch  1 never executed
    #####: 5122:    len += 1 + (format == with_commas ? strlen (f->scontext) : scontext_width);
branch  0 never executed
branch  1 never executed
        -: 5123:
    #####: 5124:  len += fileinfo_name_width (f);
call    0 never executed
        -: 5125:
    #####: 5126:  if (indicator_style != none)
branch  0 never executed
branch  1 never executed
        -: 5127:    {
    #####: 5128:      char c = get_type_indicator (f->stat_ok, f->stat.st_mode, f->filetype);
call    0 never executed
    #####: 5129:      len += (c != 0);
        -: 5130:    }
        -: 5131:
    #####: 5132:  return len;
        -: 5133:}
        -: 5134:
        -: 5135:static void
function print_many_per_line called 0 returned 0% blocks executed 0%
    #####: 5136:print_many_per_line (void)
        -: 5137:{
        -: 5138:  size_t row;			/* Current row.  */
    #####: 5139:  size_t cols = calculate_columns (true);
call    0 never executed
    #####: 5140:  struct column_info const *line_fmt = &column_info[cols - 1];
        -: 5141:
        -: 5142:  /* Calculate the number of rows that will be in each column except possibly
        -: 5143:     for a short column on the right.  */
    #####: 5144:  size_t rows = cwd_n_used / cols + (cwd_n_used % cols != 0);
        -: 5145:
    #####: 5146:  for (row = 0; row < rows; row++)
branch  0 never executed
branch  1 never executed
        -: 5147:    {
    #####: 5148:      size_t col = 0;
    #####: 5149:      size_t filesno = row;
    #####: 5150:      size_t pos = 0;
        -: 5151:
        -: 5152:      /* Print the next row.  */
        -: 5153:      while (true)
    #####: 5154:        {
    #####: 5155:          struct fileinfo const *f = sorted_file[filesno];
    #####: 5156:          size_t name_length = length_of_file_name_and_frills (f);
call    0 never executed
    #####: 5157:          size_t max_name_length = line_fmt->col_arr[col++];
    #####: 5158:          print_file_name_and_frills (f, pos);
call    0 never executed
        -: 5159:
    #####: 5160:          filesno += rows;
    #####: 5161:          if (filesno >= cwd_n_used)
branch  0 never executed
branch  1 never executed
    #####: 5162:            break;
        -: 5163:
    #####: 5164:          indent (pos + name_length, pos + max_name_length);
call    0 never executed
    #####: 5165:          pos += max_name_length;
        -: 5166:        }
    #####: 5167:      putchar (eolbyte);
call    0 never executed
        -: 5168:    }
    #####: 5169:}
        -: 5170:
        -: 5171:static void
function print_horizontal called 0 returned 0% blocks executed 0%
    #####: 5172:print_horizontal (void)
        -: 5173:{
        -: 5174:  size_t filesno;
    #####: 5175:  size_t pos = 0;
    #####: 5176:  size_t cols = calculate_columns (false);
call    0 never executed
    #####: 5177:  struct column_info const *line_fmt = &column_info[cols - 1];
    #####: 5178:  struct fileinfo const *f = sorted_file[0];
    #####: 5179:  size_t name_length = length_of_file_name_and_frills (f);
call    0 never executed
    #####: 5180:  size_t max_name_length = line_fmt->col_arr[0];
        -: 5181:
        -: 5182:  /* Print first entry.  */
    #####: 5183:  print_file_name_and_frills (f, 0);
call    0 never executed
        -: 5184:
        -: 5185:  /* Now the rest.  */
    #####: 5186:  for (filesno = 1; filesno < cwd_n_used; ++filesno)
branch  0 never executed
branch  1 never executed
        -: 5187:    {
    #####: 5188:      size_t col = filesno % cols;
        -: 5189:
    #####: 5190:      if (col == 0)
branch  0 never executed
branch  1 never executed
        -: 5191:        {
    #####: 5192:          putchar (eolbyte);
call    0 never executed
    #####: 5193:          pos = 0;
        -: 5194:        }
        -: 5195:      else
        -: 5196:        {
    #####: 5197:          indent (pos + name_length, pos + max_name_length);
call    0 never executed
    #####: 5198:          pos += max_name_length;
        -: 5199:        }
        -: 5200:
    #####: 5201:      f = sorted_file[filesno];
    #####: 5202:      print_file_name_and_frills (f, pos);
call    0 never executed
        -: 5203:
    #####: 5204:      name_length = length_of_file_name_and_frills (f);
call    0 never executed
    #####: 5205:      max_name_length = line_fmt->col_arr[col];
        -: 5206:    }
    #####: 5207:  putchar (eolbyte);
call    0 never executed
    #####: 5208:}
        -: 5209:
        -: 5210:/* Output name + SEP + ' '.  */
        -: 5211:
        -: 5212:static void
function print_with_separator called 0 returned 0% blocks executed 0%
    #####: 5213:print_with_separator (char sep)
        -: 5214:{
        -: 5215:  size_t filesno;
    #####: 5216:  size_t pos = 0;
        -: 5217:
    #####: 5218:  for (filesno = 0; filesno < cwd_n_used; filesno++)
branch  0 never executed
branch  1 never executed
        -: 5219:    {
    #####: 5220:      struct fileinfo const *f = sorted_file[filesno];
    #####: 5221:      size_t len = line_length ? length_of_file_name_and_frills (f) : 0;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 5222:
    #####: 5223:      if (filesno != 0)
branch  0 never executed
branch  1 never executed
        -: 5224:        {
        -: 5225:          char separator;
        -: 5226:
    #####: 5227:          if (! line_length
branch  0 never executed
branch  1 never executed
    #####: 5228:              || ((pos + len + 2 < line_length)
branch  0 never executed
branch  1 never executed
    #####: 5229:                  && (pos <= SIZE_MAX - len - 2)))
branch  0 never executed
branch  1 never executed
        -: 5230:            {
    #####: 5231:              pos += 2;
    #####: 5232:              separator = ' ';
        -: 5233:            }
        -: 5234:          else
        -: 5235:            {
    #####: 5236:              pos = 0;
    #####: 5237:              separator = eolbyte;
        -: 5238:            }
        -: 5239:
    #####: 5240:          putchar (sep);
call    0 never executed
    #####: 5241:          putchar (separator);
call    0 never executed
        -: 5242:        }
        -: 5243:
    #####: 5244:      print_file_name_and_frills (f, pos);
call    0 never executed
    #####: 5245:      pos += len;
        -: 5246:    }
    #####: 5247:  putchar (eolbyte);
call    0 never executed
    #####: 5248:}
        -: 5249:
        -: 5250:/* Assuming cursor is at position FROM, indent up to position TO.
        -: 5251:   Use a TAB character instead of two or more spaces whenever possible.  */
        -: 5252:
        -: 5253:static void
function indent called 0 returned 0% blocks executed 0%
    #####: 5254:indent (size_t from, size_t to)
        -: 5255:{
    #####: 5256:  while (from < to)
branch  0 never executed
branch  1 never executed
        -: 5257:    {
    #####: 5258:      if (tabsize != 0 && to / tabsize > (from + 1) / tabsize)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5259:        {
    #####: 5260:          putchar ('\t');
call    0 never executed
    #####: 5261:          from += tabsize - from % tabsize;
        -: 5262:        }
        -: 5263:      else
        -: 5264:        {
    #####: 5265:          putchar (' ');
call    0 never executed
    #####: 5266:          from++;
        -: 5267:        }
        -: 5268:    }
    #####: 5269:}
        -: 5270:
        -: 5271:/* Put DIRNAME/NAME into DEST, handling '.' and '/' properly.  */
        -: 5272:/* FIXME: maybe remove this function someday.  See about using a
        -: 5273:   non-malloc'ing version of file_name_concat.  */
        -: 5274:
        -: 5275:static void
function attach called 0 returned 0% blocks executed 0%
    #####: 5276:attach (char *dest, char const *dirname, char const *name)
        -: 5277:{
    #####: 5278:  char const *dirnamep = dirname;
        -: 5279:
        -: 5280:  /* Copy dirname if it is not ".".  */
    #####: 5281:  if (dirname[0] != '.' || dirname[1] != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5282:    {
    #####: 5283:      while (*dirnamep)
branch  0 never executed
branch  1 never executed
    #####: 5284:        *dest++ = *dirnamep++;
        -: 5285:      /* Add '/' if 'dirname' doesn't already end with it.  */
    #####: 5286:      if (dirnamep > dirname && dirnamep[-1] != '/')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5287:        *dest++ = '/';
        -: 5288:    }
    #####: 5289:  while (*name)
branch  0 never executed
branch  1 never executed
    #####: 5290:    *dest++ = *name++;
    #####: 5291:  *dest = 0;
    #####: 5292:}
        -: 5293:
        -: 5294:/* Allocate enough column info suitable for the current number of
        -: 5295:   files and display columns, and initialize the info to represent the
        -: 5296:   narrowest possible columns.  */
        -: 5297:
        -: 5298:static void
function init_column_info called 0 returned 0% blocks executed 0%
    #####: 5299:init_column_info (size_t max_cols)
        -: 5300:{
        -: 5301:  size_t i;
        -: 5302:
        -: 5303:  /* Currently allocated columns in column_info.  */
        -: 5304:  static size_t column_info_alloc;
        -: 5305:
    #####: 5306:  if (column_info_alloc < max_cols)
branch  0 never executed
branch  1 never executed
        -: 5307:    {
        -: 5308:      size_t new_column_info_alloc;
        -: 5309:      size_t *p;
        -: 5310:
    #####: 5311:      if (!max_idx || max_cols < max_idx / 2)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5312:        {
        -: 5313:          /* The number of columns is far less than the display width
        -: 5314:             allows.  Grow the allocation, but only so that it's
        -: 5315:             double the current requirements.  If the display is
        -: 5316:             extremely wide, this avoids allocating a lot of memory
        -: 5317:             that is never needed.  */
    #####: 5318:          column_info = xnrealloc (column_info, max_cols,
call    0 never executed
        -: 5319:                                   2 * sizeof *column_info);
    #####: 5320:          new_column_info_alloc = 2 * max_cols;
        -: 5321:        }
        -: 5322:      else
        -: 5323:        {
    #####: 5324:          column_info = xnrealloc (column_info, max_idx, sizeof *column_info);
call    0 never executed
    #####: 5325:          new_column_info_alloc = max_idx;
        -: 5326:        }
        -: 5327:
        -: 5328:      /* Allocate the new size_t objects by computing the triangle
        -: 5329:         formula n * (n + 1) / 2, except that we don't need to
        -: 5330:         allocate the part of the triangle that we've already
        -: 5331:         allocated.  Check for address arithmetic overflow.  */
        -: 5332:      {
    #####: 5333:        size_t column_info_growth = new_column_info_alloc - column_info_alloc;
    #####: 5334:        size_t s = column_info_alloc + 1 + new_column_info_alloc;
    #####: 5335:        size_t t = s * column_info_growth;
    #####: 5336:        if (s < new_column_info_alloc || t / column_info_growth != s)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5337:          xalloc_die ();
call    0 never executed
    #####: 5338:        p = xnmalloc (t / 2, sizeof *p);
call    0 never executed
        -: 5339:      }
        -: 5340:
        -: 5341:      /* Grow the triangle by parceling out the cells just allocated.  */
    #####: 5342:      for (i = column_info_alloc; i < new_column_info_alloc; i++)
branch  0 never executed
branch  1 never executed
        -: 5343:        {
    #####: 5344:          column_info[i].col_arr = p;
    #####: 5345:          p += i + 1;
        -: 5346:        }
        -: 5347:
    #####: 5348:      column_info_alloc = new_column_info_alloc;
        -: 5349:    }
        -: 5350:
    #####: 5351:  for (i = 0; i < max_cols; ++i)
branch  0 never executed
branch  1 never executed
        -: 5352:    {
        -: 5353:      size_t j;
        -: 5354:
    #####: 5355:      column_info[i].valid_len = true;
    #####: 5356:      column_info[i].line_len = (i + 1) * MIN_COLUMN_WIDTH;
    #####: 5357:      for (j = 0; j <= i; ++j)
branch  0 never executed
branch  1 never executed
    #####: 5358:        column_info[i].col_arr[j] = MIN_COLUMN_WIDTH;
        -: 5359:    }
    #####: 5360:}
        -: 5361:
        -: 5362:/* Calculate the number of columns needed to represent the current set
        -: 5363:   of files in the current display width.  */
        -: 5364:
        -: 5365:static size_t
function calculate_columns called 0 returned 0% blocks executed 0%
    #####: 5366:calculate_columns (bool by_columns)
        -: 5367:{
        -: 5368:  size_t filesno;		/* Index into cwd_file.  */
        -: 5369:  size_t cols;			/* Number of files across.  */
        -: 5370:
        -: 5371:  /* Normally the maximum number of columns is determined by the
        -: 5372:     screen width.  But if few files are available this might limit it
        -: 5373:     as well.  */
    #####: 5374:  size_t max_cols = 0 < max_idx && max_idx < cwd_n_used ? max_idx : cwd_n_used;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5375:
    #####: 5376:  init_column_info (max_cols);
call    0 never executed
        -: 5377:
        -: 5378:  /* Compute the maximum number of possible columns.  */
    #####: 5379:  for (filesno = 0; filesno < cwd_n_used; ++filesno)
branch  0 never executed
branch  1 never executed
        -: 5380:    {
    #####: 5381:      struct fileinfo const *f = sorted_file[filesno];
    #####: 5382:      size_t name_length = length_of_file_name_and_frills (f);
call    0 never executed
        -: 5383:
    #####: 5384:      for (size_t i = 0; i < max_cols; ++i)
branch  0 never executed
branch  1 never executed
        -: 5385:        {
    #####: 5386:          if (column_info[i].valid_len)
branch  0 never executed
branch  1 never executed
        -: 5387:            {
    #####: 5388:              size_t idx = (by_columns
    #####: 5389:                            ? filesno / ((cwd_n_used + i) / (i + 1))
    #####: 5390:                            : filesno % (i + 1));
branch  0 never executed
branch  1 never executed
    #####: 5391:              size_t real_length = name_length + (idx == i ? 0 : 2);
branch  0 never executed
branch  1 never executed
        -: 5392:
    #####: 5393:              if (column_info[i].col_arr[idx] < real_length)
branch  0 never executed
branch  1 never executed
        -: 5394:                {
    #####: 5395:                  column_info[i].line_len += (real_length
    #####: 5396:                                              - column_info[i].col_arr[idx]);
    #####: 5397:                  column_info[i].col_arr[idx] = real_length;
    #####: 5398:                  column_info[i].valid_len = (column_info[i].line_len
    #####: 5399:                                              < line_length);
        -: 5400:                }
        -: 5401:            }
        -: 5402:        }
        -: 5403:    }
        -: 5404:
        -: 5405:  /* Find maximum allowed columns.  */
    #####: 5406:  for (cols = max_cols; 1 < cols; --cols)
branch  0 never executed
branch  1 never executed
        -: 5407:    {
    #####: 5408:      if (column_info[cols - 1].valid_len)
branch  0 never executed
branch  1 never executed
    #####: 5409:        break;
        -: 5410:    }
        -: 5411:
    #####: 5412:  return cols;
        -: 5413:}
        -: 5414:
        -: 5415:void
function usage called 1 returned 0% blocks executed 5%
        1: 5416:usage (int status)
        -: 5417:{
        1: 5418:  if (status != EXIT_SUCCESS)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 5419:    emit_try_help ();
call    0 returned 100%
        -: 5420:  else
        -: 5421:    {
    #####: 5422:      printf (_("Usage: %s [OPTION]... [FILE]...\n"), program_name);
call    0 never executed
    #####: 5423:      fputs (_("\
call    0 never executed
        -: 5424:List information about the FILEs (the current directory by default).\n\
        -: 5425:Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n\
        -: 5426:"), stdout);
        -: 5427:
    #####: 5428:      emit_mandatory_arg_note ();
call    0 never executed
        -: 5429:
    #####: 5430:      fputs (_("\
call    0 never executed
        -: 5431:  -a, --all                  do not ignore entries starting with .\n\
        -: 5432:  -A, --almost-all           do not list implied . and ..\n\
        -: 5433:      --author               with -l, print the author of each file\n\
        -: 5434:  -b, --escape               print C-style escapes for nongraphic characters\n\
        -: 5435:"), stdout);
    #####: 5436:      fputs (_("\
call    0 never executed
        -: 5437:      --block-size=SIZE      with -l, scale sizes by SIZE when printing them;\n\
        -: 5438:                             e.g., '--block-size=M'; see SIZE format below\n\
        -: 5439:\n\
        -: 5440:"), stdout);
    #####: 5441:      fputs (_("\
call    0 never executed
        -: 5442:  -B, --ignore-backups       do not list implied entries ending with ~\n\
        -: 5443:"), stdout);
    #####: 5444:      fputs (_("\
call    0 never executed
        -: 5445:  -c                         with -lt: sort by, and show, ctime (time of last\n\
        -: 5446:                             change of file status information);\n\
        -: 5447:                             with -l: show ctime and sort by name;\n\
        -: 5448:                             otherwise: sort by ctime, newest first\n\
        -: 5449:\n\
        -: 5450:"), stdout);
    #####: 5451:      fputs (_("\
call    0 never executed
        -: 5452:  -C                         list entries by columns\n\
        -: 5453:      --color[=WHEN]         color the output WHEN; more info below\n\
        -: 5454:  -d, --directory            list directories themselves, not their contents\n\
        -: 5455:  -D, --dired                generate output designed for Emacs' dired mode\n\
        -: 5456:"), stdout);
    #####: 5457:      fputs (_("\
call    0 never executed
        -: 5458:  -f                         list all entries in directory order\n\
        -: 5459:  -F, --classify[=WHEN]      append indicator (one of */=>@|) to entries WHEN\n\
        -: 5460:      --file-type            likewise, except do not append '*'\n\
        -: 5461:"), stdout);
    #####: 5462:      fputs (_("\
call    0 never executed
        -: 5463:      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n\
        -: 5464:                             single-column -1, verbose -l, vertical -C\n\
        -: 5465:\n\
        -: 5466:"), stdout);
    #####: 5467:      fputs (_("\
call    0 never executed
        -: 5468:      --full-time            like -l --time-style=full-iso\n\
        -: 5469:"), stdout);
    #####: 5470:      fputs (_("\
call    0 never executed
        -: 5471:  -g                         like -l, but do not list owner\n\
        -: 5472:"), stdout);
    #####: 5473:      fputs (_("\
call    0 never executed
        -: 5474:      --group-directories-first\n\
        -: 5475:                             group directories before files;\n\
        -: 5476:                             can be augmented with a --sort option, but any\n\
        -: 5477:                             use of --sort=none (-U) disables grouping\n\
        -: 5478:\n\
        -: 5479:"), stdout);
    #####: 5480:      fputs (_("\
call    0 never executed
        -: 5481:  -G, --no-group             in a long listing, don't print group names\n\
        -: 5482:"), stdout);
    #####: 5483:      fputs (_("\
call    0 never executed
        -: 5484:  -h, --human-readable       with -l and -s, print sizes like 1K 234M 2G etc.\n\
        -: 5485:      --si                   likewise, but use powers of 1000 not 1024\n\
        -: 5486:"), stdout);
    #####: 5487:      fputs (_("\
call    0 never executed
        -: 5488:  -H, --dereference-command-line\n\
        -: 5489:                             follow symbolic links listed on the command line\n\
        -: 5490:"), stdout);
    #####: 5491:      fputs (_("\
call    0 never executed
        -: 5492:      --dereference-command-line-symlink-to-dir\n\
        -: 5493:                             follow each command line symbolic link\n\
        -: 5494:                             that points to a directory\n\
        -: 5495:\n\
        -: 5496:"), stdout);
    #####: 5497:      fputs (_("\
call    0 never executed
        -: 5498:      --hide=PATTERN         do not list implied entries matching shell PATTERN\
        -: 5499:\n\
        -: 5500:                             (overridden by -a or -A)\n\
        -: 5501:\n\
        -: 5502:"), stdout);
    #####: 5503:      fputs (_("\
call    0 never executed
        -: 5504:      --hyperlink[=WHEN]     hyperlink file names WHEN\n\
        -: 5505:"), stdout);
    #####: 5506:      fputs (_("\
call    0 never executed
        -: 5507:      --indicator-style=WORD\n\
        -: 5508:                             append indicator with style WORD to entry names:\n\
        -: 5509:                             none (default), slash (-p),\n\
        -: 5510:                             file-type (--file-type), classify (-F)\n\
        -: 5511:\n\
        -: 5512:"), stdout);
    #####: 5513:      fputs (_("\
call    0 never executed
        -: 5514:  -i, --inode                print the index number of each file\n\
        -: 5515:  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN\
        -: 5516:\n\
        -: 5517:"), stdout);
    #####: 5518:      fputs (_("\
call    0 never executed
        -: 5519:  -k, --kibibytes            default to 1024-byte blocks for file system usage;\
        -: 5520:\n\
        -: 5521:                             used only with -s and per directory totals\n\
        -: 5522:\n\
        -: 5523:"), stdout);
    #####: 5524:      fputs (_("\
call    0 never executed
        -: 5525:  -l                         use a long listing format\n\
        -: 5526:"), stdout);
    #####: 5527:      fputs (_("\
call    0 never executed
        -: 5528:  -L, --dereference          when showing file information for a symbolic\n\
        -: 5529:                             link, show information for the file the link\n\
        -: 5530:                             references rather than for the link itself\n\
        -: 5531:\n\
        -: 5532:"), stdout);
    #####: 5533:      fputs (_("\
call    0 never executed
        -: 5534:  -m                         fill width with a comma separated list of entries\
        -: 5535:\n\
        -: 5536:"), stdout);
    #####: 5537:      fputs (_("\
call    0 never executed
        -: 5538:  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n\
        -: 5539:  -N, --literal              print entry names without quoting\n\
        -: 5540:  -o                         like -l, but do not list group information\n\
        -: 5541:  -p, --indicator-style=slash\n\
        -: 5542:                             append / indicator to directories\n\
        -: 5543:"), stdout);
    #####: 5544:      fputs (_("\
call    0 never executed
        -: 5545:  -q, --hide-control-chars   print ? instead of nongraphic characters\n\
        -: 5546:"), stdout);
    #####: 5547:      fputs (_("\
call    0 never executed
        -: 5548:      --show-control-chars   show nongraphic characters as-is (the default,\n\
        -: 5549:                             unless program is 'ls' and output is a terminal)\
        -: 5550:\n\
        -: 5551:\n\
        -: 5552:"), stdout);
    #####: 5553:      fputs (_("\
call    0 never executed
        -: 5554:  -Q, --quote-name           enclose entry names in double quotes\n\
        -: 5555:"), stdout);
    #####: 5556:      fputs (_("\
call    0 never executed
        -: 5557:      --quoting-style=WORD   use quoting style WORD for entry names:\n\
        -: 5558:                             literal, locale, shell, shell-always,\n\
        -: 5559:                             shell-escape, shell-escape-always, c, escape\n\
        -: 5560:                             (overrides QUOTING_STYLE environment variable)\n\
        -: 5561:\n\
        -: 5562:"), stdout);
    #####: 5563:      fputs (_("\
call    0 never executed
        -: 5564:  -r, --reverse              reverse order while sorting\n\
        -: 5565:  -R, --recursive            list subdirectories recursively\n\
        -: 5566:  -s, --size                 print the allocated size of each file, in blocks\n\
        -: 5567:"), stdout);
    #####: 5568:      fputs (_("\
call    0 never executed
        -: 5569:  -S                         sort by file size, largest first\n\
        -: 5570:"), stdout);
    #####: 5571:      fputs (_("\
call    0 never executed
        -: 5572:      --sort=WORD            sort by WORD instead of name: none (-U), size (-S)\
        -: 5573:,\n\
        -: 5574:                             time (-t), version (-v), extension (-X), width\n\
        -: 5575:\n\
        -: 5576:"), stdout);
    #####: 5577:      fputs (_("\
call    0 never executed
        -: 5578:      --time=WORD            select which timestamp used to display or sort;\n\
        -: 5579:                               access time (-u): atime, access, use;\n\
        -: 5580:                               metadata change time (-c): ctime, status;\n\
        -: 5581:                               modified time (default): mtime, modification;\n\
        -: 5582:                               birth time: birth, creation;\n\
        -: 5583:                             with -l, WORD determines which time to show;\n\
        -: 5584:                             with --sort=time, sort by WORD (newest first)\n\
        -: 5585:\n\
        -: 5586:"), stdout);
    #####: 5587:      fputs (_("\
call    0 never executed
        -: 5588:      --time-style=TIME_STYLE\n\
        -: 5589:                             time/date format with -l; see TIME_STYLE below\n\
        -: 5590:"), stdout);
    #####: 5591:      fputs (_("\
call    0 never executed
        -: 5592:  -t                         sort by time, newest first; see --time\n\
        -: 5593:  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n\
        -: 5594:"), stdout);
    #####: 5595:      fputs (_("\
call    0 never executed
        -: 5596:  -u                         with -lt: sort by, and show, access time;\n\
        -: 5597:                             with -l: show access time and sort by name;\n\
        -: 5598:                             otherwise: sort by access time, newest first\n\
        -: 5599:\n\
        -: 5600:"), stdout);
    #####: 5601:      fputs (_("\
call    0 never executed
        -: 5602:  -U                         do not sort; list entries in directory order\n\
        -: 5603:"), stdout);
    #####: 5604:      fputs (_("\
call    0 never executed
        -: 5605:  -v                         natural sort of (version) numbers within text\n\
        -: 5606:"), stdout);
    #####: 5607:      fputs (_("\
call    0 never executed
        -: 5608:  -w, --width=COLS           set output width to COLS.  0 means no limit\n\
        -: 5609:  -x                         list entries by lines instead of by columns\n\
        -: 5610:  -X                         sort alphabetically by entry extension\n\
        -: 5611:  -Z, --context              print any security context of each file\n\
        -: 5612:      --zero                 end each output line with NUL, not newline\n\
        -: 5613:  -1                         list one file per line\n\
        -: 5614:"), stdout);
    #####: 5615:      fputs (HELP_OPTION_DESCRIPTION, stdout);
call    0 never executed
    #####: 5616:      fputs (VERSION_OPTION_DESCRIPTION, stdout);
call    0 never executed
    #####: 5617:      emit_size_note ();
call    0 never executed
    #####: 5618:      fputs (_("\
call    0 never executed
        -: 5619:\n\
        -: 5620:The TIME_STYLE argument can be full-iso, long-iso, iso, locale, or +FORMAT.\n\
        -: 5621:FORMAT is interpreted like in date(1).  If FORMAT is FORMAT1<newline>FORMAT2,\n\
        -: 5622:then FORMAT1 applies to non-recent files and FORMAT2 to recent files.\n\
        -: 5623:TIME_STYLE prefixed with 'posix-' takes effect only outside the POSIX locale.\n\
        -: 5624:Also the TIME_STYLE environment variable sets the default style to use.\n\
        -: 5625:"), stdout);
    #####: 5626:      fputs (_("\
call    0 never executed
        -: 5627:\n\
        -: 5628:The WHEN argument defaults to 'always' and can also be 'auto' or 'never'.\n\
        -: 5629:"), stdout);
    #####: 5630:      fputs (_("\
call    0 never executed
        -: 5631:\n\
        -: 5632:Using color to distinguish file types is disabled both by default and\n\
        -: 5633:with --color=never.  With --color=auto, ls emits color codes only when\n\
        -: 5634:standard output is connected to a terminal.  The LS_COLORS environment\n\
        -: 5635:variable can change the settings.  Use the dircolors(1) command to set it.\n\
        -: 5636:"), stdout);
    #####: 5637:      fputs (_("\
call    0 never executed
        -: 5638:\n\
        -: 5639:Exit status:\n\
        -: 5640: 0  if OK,\n\
        -: 5641: 1  if minor problems (e.g., cannot access subdirectory),\n\
        -: 5642: 2  if serious trouble (e.g., cannot access command-line argument).\n\
        -: 5643:"), stdout);
    #####: 5644:      emit_ancillary_info (PROGRAM_NAME);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 5645:    }
        1: 5646:  exit (status);
        -: 5647:}
